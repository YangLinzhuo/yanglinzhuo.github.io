{
    "version": "https://jsonfeed.org/version/1",
    "title": "林•初夏 • All posts by \"computer-science\" category",
    "description": "Linn 的个人博客",
    "home_page_url": "https://linn-ylz.com",
    "items": [
        {
            "id": "https://linn-ylz.com/Computer-Science/CUDA/CUTLASS/cute-layout/",
            "url": "https://linn-ylz.com/Computer-Science/CUDA/CUTLASS/cute-layout/",
            "title": "CUTLASS 中的 CuTe Layout",
            "date_published": "2025-01-17T06:53:03.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>CUTLASS（CUDA Templates for Linear Algebra Subroutines and Solvers）是 NVIDIA 的一个用于高性能矩阵计算的 CUDA 库，类似于 cuBLAS 和 cuDNN。它将数据移动等操作封装成了 C++ 模板，帮助开发者在 NVIDIA GPU 上实现高效的线性代数操作。支持 Tensor Core 矩阵运算，FP32/TF32/FP16/BF16/FP64/Int4/Int8/Int1 等多种类型的数据格式。目前大模型中的 Flash Attention 算法就是基于 CUTLASS 实现的。</p>\n<p>CUTLASS 的 3.0 版本提出了一套新的用于描述 Tensor 排布的模板库，并封装了许多数据索引相关的运算。这篇文章将会介绍一些 CuTe 相关的基础概念，如果想要更加深入了解，可以参看知乎用户 <a href=\"https://www.zhihu.com/people/reed-84-49\">reed</a> 的系列文章<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup><sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>。</p>\n<h2 id=\"cute\"><a class=\"anchor\" href=\"#cute\">#</a> CuTe</h2>\n<p>计算机的内存是一个一维的线性地址空间，我们通常所用的矩阵或者更高维度的 Tensor 的坐标，都需要经过映射对应到其真实的物理内存地址。在目前常见的深度学习框架中，通常都采用  <code>Shape</code>  和  <code>Stride</code>  的形式来描述一个 Tensor 的坐标到物理地址的映射。而 CuTe 的描述形式则是基于这个  <code>Shape</code>  和  <code>Stride</code>  形式拓展而来的  <code>Hierarchy Tensor</code> 。相比于简单的  <code>Shape</code>  和  <code>Stride</code> ，这种描述形式可以表达更为复杂的映射关系。</p>\n<p>接下来我们将通过一些例子来展现这两种描述方式的能力差异。</p>\n<h3 id=\"shape-stride\"><a class=\"anchor\" href=\"#shape-stride\">#</a>  <code>Shape</code>  +  <code>Stride</code></h3>\n<p>目前深度学习框架中通常使用的都是  <code>Shape</code>  +  <code>Stride</code>  的形式来描述逻辑地址和实际物理地址的映射关系。以一个二维矩阵为例，常用的内存排布模式有「行优先」和「列优先」两种，下面是一个  <code>Shape</code>  为  <code>(2, 4)</code>  的矩阵在两种情形下的内存排布：</p>\n<div class=\"tab\" data-id=\"layout\" data-title=\"行优先\">\n<p><img loading=\"lazy\" data-src=\"/images/cuda/cutlass/row-major.png\" alt=\"row-major\" title=\"行优先\" /></p>\n</div>\n<div class=\"tab\" data-id=\"layout\" data-title=\"列优先\">\n<p><img loading=\"lazy\" data-src=\"/images/cuda/cutlass/col-major.png\" alt=\"col-major\" title=\"列优先\" /></p>\n</div>\n<p>图中每个方格中的数字表示该位置元素在内存中按顺序排列时的下标。可以看到，相同的矩阵下标位置，在不同的排布方式，其在内存中的顺序可能是不同的。例如，矩阵坐标  <code>(1, 0)</code>  在行优先和列优先的情况下，对应元素在内存中的顺序分别是  <code>4</code>  和  <code>1</code>  （从  <code>0</code>  开始计数）。在大部分编程语言中，常用的排布方式是行优先，例如  <code>C/C++</code> ，列优先方式一般是  <code>Fortran</code> 。在  <code>Python</code>  的  <code>numpy</code>  库中，创建  <code>tensor</code>  时默认是行优先，可以传入  <code>order=&quot;F&quot;</code>  参数指定使用列优先排布。</p>\n<p>我们在编写循环遍历矩阵时，一般都会将第二个下标作为内层循环，就是因为通常的矩阵都采用行优先排布。如果是列优先排布，那么就需要将第二个下标的循环放在外层以保证数据的局部性。</p>\n<p>这里的矩阵的  <code>Shape</code>  就是  <code>(2, 4)</code> ，而  <code>Stride</code>  则用于区分不同的排布：</p>\n<ul>\n<li>行优先： <code>Shape (2, 4)</code>  +  <code>Stride (4, 1)</code></li>\n<li>列优先： <code>Shape (2, 4)</code>  +  <code>Stride (1, 2)</code></li>\n</ul>\n<p>如果要根据矩阵的坐标对应的内存地址映射，则将坐标  <code>(i, j)</code>  与  <code>Stride</code>  对应的元素相乘再求和即可。例如  <code>(1, 0)</code>  的坐标在行优先和列优先对应的内存地址映射就是分别和  <code>Stride</code>   <code>(4, 1)</code>  以及  <code>(1, 2)</code>  相乘再求和的结果，这与我们在图中所见的结果一致。</p>\n<h3 id=\"hierarchy-tensor\"><a class=\"anchor\" href=\"#hierarchy-tensor\">#</a> Hierarchy Tensor</h3>\n<p>上述  <code>Shape</code>  +  <code>Stride</code>  的描述方式在常见情况下基本能够满足使用，但是在  <code>CUDA</code>  编写中可能会遇到更复杂的内存排布情况无法用这种方式来表述。Graphene<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup> 这篇论文提出了一种新的层次化的排布表述方式。我们可以看下面的 4 个例子：</p>\n<div class=\"tab\" data-id=\"graphene\" data-title=\"A（列优先）\">\n<p><img loading=\"lazy\" data-src=\"/images/cuda/cutlass/layout_A.png\" alt=\"Layout A-col-major\" title=\"Layout A\" /></p>\n</div>\n<div class=\"tab\" data-id=\"graphene\" data-title=\"B（行优先）\">\n<p><img loading=\"lazy\" data-src=\"/images/cuda/cutlass/layout_B.png\" alt=\"Layout B-row-major\" title=\"Layout B\" /></p>\n</div>\n<div class=\"tab\" data-id=\"graphene\" data-title=\"C\">\n<p><img loading=\"lazy\" data-src=\"/images/cuda/cutlass/layout_C.png\" alt=\"Layout C\" title=\"Layout C\" /></p>\n</div>\n<div class=\"tab\" data-id=\"graphene\" data-title=\"D\">\n<p><img loading=\"lazy\" data-src=\"/images/cuda/cutlass/layout_D.png\" alt=\"Layout D\" title=\"Layout D\" /></p>\n</div>\n<p>这里先解释一下  <code>Layout</code>  的表述格式。在图片中，使用类似矩阵的形式来表达  <code>Layout</code> ，第一行是  <code>Shape</code> ，第二行是  <code>Stride</code> 。可以看到行优先和列优先的表述，与上文的  <code>Shape</code>  +  <code>Stride</code>  表述是一致的，也就是其能够兼容这种表述方式。而  <code>C</code>  和  <code>D</code>  两种排布方式则是原有的  <code>Shape</code>  +  <code>Stride</code>  无法表达的情形。 <code>C</code>  和  <code>D</code>  中的  <code>Shape</code>  和  <code>Stride</code>  是嵌套的，通常的  <code>Shape</code>  或者  <code>Stride</code>  中的元素是一个单独的整数，而层次化表述中，元素可以是一个元组。</p>\n<p>那么，这种嵌套的情形应该如何直观理解？对于第一行的  <code>Shape</code> ， <code>C</code>  和  <code>D</code>  中的元素虽然有元组，但是他们的元素个数依然是 2 个，即上述 4 个例子的  <code>Shape</code>  的  <code>rank</code>  均为 2 （ <code>CuTe</code>  中使用  <code>rank</code>  来表述元素的个数），也就是一个整数和一个元组对于计数的贡献是一样的。上述 4 个矩阵都能够用二维的图形来表述，因为他们的  <code>rank</code>  是 2。</p>\n<p>以最中间的逗号分隔，第一个元素描述的是行上的层次分布，第二个元素描述的是列上的层次分布。如果元素是整数，那么就和通常的矩阵描述一致，例如上面的  <code>A</code>   <code>B</code>  以及  <code>C</code>  中的第一个元素，均描述了这个矩阵有几行。而如果元素是一个元组，那么其中描述的就是不同层次中矩阵的行数。以  <code>D</code>  为例，其第一个元素为  <code>(2, 2)</code> ，这两个 2 分别描述了内层矩阵和外层矩阵的行数。内层矩阵为内部用灰色粗线包裹的矩阵，如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>0</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>1</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\begin{bmatrix} 0, &amp; 2\\\\1, &amp; 3 \\end{bmatrix}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4em;vertical-align:-0.95em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span> 这个矩阵，这个矩阵行数为 2。而外层矩阵则是将内层矩阵视为一个「元素」时的行数。例如  <code>D</code>  中在行方向有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>0</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>1</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\begin{bmatrix} 0, &amp; 2\\\\1, &amp; 3 \\end{bmatrix}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4em;vertical-align:-0.95em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>4</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>6</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>5</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>7</mn></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\begin{bmatrix} 4, &amp; 6\\\\5, &amp; 7 \\end{bmatrix}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4em;vertical-align:-0.95em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">4</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">6</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">7</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span> 这两个矩阵，故行数也为 2。由此我们可以总结出第一个元素的表述方式是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>r</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>r</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(r_0, r_1, \\cdots, r_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，其中每个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">r_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 表示由内而外第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 层的矩阵的行数，列的描述也同理。</p>\n<p>故对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>r</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>r</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><msub><mi>c</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(r_0, r_1, \\cdots, r_n), (c_0, c_1, \\cdots, c_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 表示的  <code>Shape</code> ，第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个行 - 列对 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(r_i, c_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 表示的是将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>r</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>r</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><msub><mi>c</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>c</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(r_0, r_1, \\cdots, r_{i-1}), (c_0, c_1, \\cdots, c_{i-1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 为  <code>Shape</code>  的矩阵视为一个元素时，矩阵的行数和列数分别为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">r_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>再看  <code>Stride</code> ，其每个元素与  <code>Shape</code>  中的元素对应，表示该对应维度下，相邻元素「首地址」在内存地址上的间隔。例如  <code>C</code>  中，在行方向移动一格，其内存地址相差 2；在内层列上移动一格，内存地址相差 1；在外层列上移动一个，内存地址相差 8。 <code>D</code>  的表述同理。图片中用箭头表示了每个维度相邻元素首地址差。</p>\n<p>计算实际的内存地址时，只需要将  <code>Shape</code>  与  <code>Stride</code>  对应元素相乘求和即可，这与  <code>Shape</code>  +  <code>Stride</code>  表述方式的计算是一致的。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这篇文章介绍了  <code>CuTe</code>  这一种新的  <code>Tensor</code>  逻辑地址和物理地址的映射方式。上文种介绍的主要是二维的情形，理论上更高维也可以描述，但是已经不方便直观理解了。从我目前看到的相关内容来看，二维的情况占了绝大多数。本篇文章是基于自己个人理解的表述，可以参看知乎用户 <a href=\"https://www.zhihu.com/people/reed-84-49\">reed</a> 的「cute 之 Layout」<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1:1\">[1:1]</a></sup>这篇文章。</p>\n<p>本文的图片使用的代码基于 CUTLASS 库官方代码修改而来的  <code>pycute</code>  库<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>，放在我的个人仓库中，有需要可以自取。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://zhuanlan.zhihu.com/p/661182311\">cute 之 Layout</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a> <a href=\"#fnref1:1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://zhuanlan.zhihu.com/p/662089556\">cute Layout 的代数和几何解释</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"https://dl.acm.org/doi/abs/10.1145/3582016.3582018\">Graphene: An IR for Optimized Tensor Computations on GPUs</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"https://github.com/YangLinzhuo/cutlass-learning/tree/main/pycute\">pycute</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "CUDA",
                "CUTLASS",
                "CUTE"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Algorithm/binary-search-revision/",
            "url": "https://linn-ylz.com/Computer-Science/Algorithm/binary-search-revision/",
            "title": "二分搜索再探",
            "date_published": "2023-10-21T01:58:50.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>经典的二分查找写法，相信许多人都动手写过，但是在编写代码的过程中，经常遇到类似这样的问题：</p>\n<ul>\n<li>如何确定起始端点下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的位置？是写成闭区间还是开区间？</li>\n<li>如何确定循环结束条件？是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>&lt;</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L &lt; R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 还是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>≤</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L\\le R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> ？</li>\n<li>如果确定下标的变化方式？是直接赋值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 给 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>，还是需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">+</span><span class=\"mord\">1</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span> ？</li>\n<li>最后返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 还是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> ？还是其他形式？</li>\n</ul>\n<p>二分查找代码虽然只有短短数行，但是这些问题让编写正确的代码显得非常棘手。在之前的文章 <a href=\"/Computer-Science/Algorithm/about-binary-search/\" title=\"二分搜索探究\">《二分搜索探究》</a> 中我曾经编写过当时的心得体会。最近在复习的时候，对照 B 站 Up 主<a href=\"https://space.bilibili.com/206214\">灵茶山艾府</a>的视频，加上评论区其他观众的回复讨论，又有了更新的感悟，因此在此记录下来。</p>\n<p>为了方便讨论，我们定义一个二分查找函数的功能如下：</p>\n<ul>\n<li>返回有序数组  <code>arr</code>  中目标值  <code>target</code>  对应的下标</li>\n<li>如果  <code>arr</code>  不存在  <code>target</code>  值，则返回第一个大于  <code>target</code>  的值的下标</li>\n</ul>\n<p>总结而言，就是返回数组  <code>arr</code>  第一个大于等于  <code>target</code>  的值的下标。</p>\n<p>对照开头提出的三个问题，我们一个一个来思考解决的办法。</p>\n<h2 id=\"区间的确定\"><a class=\"anchor\" href=\"#区间的确定\">#</a> 区间的确定</h2>\n<p>我们在编写二分查找代码的时候，第一个问题在于如何确定起始端点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的数值。事实上，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的选取决定了我们使用何种区间表示来解决后续的代码。</p>\n<p>我们当前有两个端点，每个端点可以开，可以闭，则总共有四种形式：</p>\n<ul>\n<li>闭区间（左闭右闭）</li>\n<li>开区间（左开右开）</li>\n<li>左闭右开</li>\n<li>左开右闭</li>\n</ul>\n<p>理论上，基于这四种形式，我们都可以编写出正确的二分查找代码。但是采用不同形式编写出的代码可能在形式上具有某种区别，对于某些更复杂的问题，在编写代码的难易度上也有差别。像  <code>Python</code>   <code>C++</code>  等语言，选择的就是左闭右开的方式，而  <code>Java</code>  则采用的闭区间的写法。我个人是偏向左闭右开写法的。</p>\n<p>接下来我们一个个查看每种表示形式。</p>\n<p>闭区间，即表示我们每次处理的是下标范围在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L, R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 中的元素。这里我们需要注意，这里的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L, R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 区间中的元素是我们代码后续需要处理的对象，也就是说这些元素还尚未明确与目标值  <code>target</code>  的关系。而与此相反，区间外的元素 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty, L-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R+1,+\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> 则已经确定了与目标值  <code>target</code>  的关系，也因此我们能够将其排除。这里 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">-\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">∞</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">+\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span></span></span></span> 分别表示任意下标小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 或者大于数组长度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 的情况。这些数组外的元素我们可以认为其为无穷小或者无穷大（保证有序）。</p>\n<p>这也是我从某个评论中获得的灵感，即思考区间问题时，<strong>我们关注的不是区间内的元素具有何种性质，而是区间外的元素具有何种性质</strong>。二分查找的本质就是，根据某种性质，一步步排除掉一半的元素，不断缩小查找范围，直到找到对应的元素，或者确认目标元素不存在。</p>\n<p>那么对应闭区间，我们可以确定以下性质：</p>\n<ul>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L, R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 中的元素是待查找对象</li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty, L-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 中的元素均<strong>小于</strong>目标值  <code>target</code></li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R+1, +\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> 中的元素均<strong>大于或等于</strong>目标值  <code>target</code></li>\n</ul>\n<p>小于和大于的关系相信很容易想到，那么这里如何确定是否带 “等于” 的关系呢？我们可以这样思考，下标区间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L, R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 是我们的待查找区间，对于左边被排除的下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty, L-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，如果其中可能存在<strong>等于</strong>  <code>target</code>  的值，那么返回的下标必然应该在此区间内，我们不可能将其排除在我们的搜索范围之外，因此这里不能取等于。而对于右边被排除的下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R+1,+\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span>，因为数组  <code>arr</code>  中可能存在多个  <code>target</code>  值，第一个  <code>target</code>  下标之后其他  <code>target</code>  值的下标也需要排除，否则我们找到的就不是<strong>第一个</strong>大于等于目标值  <code>target</code>  的目标了。</p>\n<p>我们可以按照类似方式定义出其他区间形式的区间性质。</p>\n<p>对应开区间：</p>\n<ul>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> 中的元素是待查找对象</li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty, L]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">]</span></span></span></span> 中的元素均<strong>小于</strong>目标值  <code>target</code></li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R, +\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> 中的元素均<strong>大于或等于</strong>目标值  <code>target</code></li>\n</ul>\n<p>对应左闭右开区间：</p>\n<ul>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> 中的元素是待查找对象</li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty, L-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 中的元素均<strong>小于</strong>目标值  <code>target</code></li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R, +\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> 中的元素均<strong>大于或等于</strong>目标值  <code>target</code></li>\n</ul>\n<p>对应左开右闭区间：</p>\n<ul>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 中的元素是待查找对象</li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty, L]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">]</span></span></span></span> 中的元素均<strong>小于</strong>目标值  <code>target</code></li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R+1, +\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> 中的元素均<strong>大于或等于</strong>目标值  <code>target</code></li>\n</ul>\n<p>这样一来，我们就确定了所有区间表示方式下区间内元素的性质。</p>\n<h2 id=\"如何确定循环结束条件\"><a class=\"anchor\" href=\"#如何确定循环结束条件\">#</a> 如何确定循环结束条件</h2>\n<p>循环结束的判断条件到底是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>&lt;</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L&lt;R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 还是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>≤</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L \\le R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> ？</p>\n<p>因为 “小于” 判断是肯定的，那么确定循环结束条件的关键在于到底是否需要添加 “等于” 判断。我们不妨针对每个区间表示形式分析一下。</p>\n<p>对于闭区间，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 是我们的待搜索区间。当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L=R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 时，表示我们的待搜索区间只有一个元素，而根据我们的定义，左右两个端点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 表示的下标都是有效的待搜索对象下标，显然这个下标对应的元素也符合我们继续搜索判断的要求。那么，在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L=R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的时候可以添加 “等于” 判断。或者我们可以这样理解，当我们表示的区间中的元素不为空的时候，我们就进入循环；否则，退出循环。对于闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L=R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 时，区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 不为空，因此我们需要继续判断。不过，我们其实可以不添加这个 “等于” 判断。根据我们的定义，所有<strong>小于</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 的下标，其对应值均<strong>小于</strong>  <code>target</code> ；而所有<strong>大于</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的下标，其对应值均<strong>大于等于</strong>  <code>target</code> ；在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L=R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的时候，此时 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 指向的已经是第一个<strong>大于等于</strong>  <code>target</code>  的元素了。我们不进入这次循环也无大碍。所以，对于闭区间，是否添加 “等于” 判断都正确。</p>\n<p>当然，这里的判断是针对我们的题目设定而言。如果某个题目要求未找到时返回下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>，那么我们就必须加上 “等于” 的判断，因为我们不知道最后的这一个元素究竟是否是我们的  <code>target</code> ，仍需要最后一次判断。如果不是  <code>targeet</code> ，则返回下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>。<strong>因此，这里推荐加上 “等于” 的判断。</strong></p>\n<p>基于闭区间的结论，我们可以继续确定其他表现形式的循环结束条件。</p>\n<ul>\n<li>对于开区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>，等价于闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，那么判断条件就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn><mo>&lt;</mo><mi>R</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L+1&lt;R-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>R</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L+1\\le R-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；我们不妨化采用包含 “等于” 判断的形式，这样条件可以等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn><mo>&lt;</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L+1&lt;R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的形式；</li>\n<li>对于左闭右开区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>，等价于闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，那么判断条件就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>&lt;</mo><mi>R</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L&lt;R-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>≤</mo><mi>R</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L\\le R-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；我们不妨化采用包含 “等于” 判断的形式，这样条件可以等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>&lt;</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L&lt;R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的形式；</li>\n<li>对于左开右闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>，等价于闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>，那么判断条件就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn><mo>&lt;</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L+1&lt;R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L+1\\le R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>。</li>\n</ul>\n<h2 id=\"如何计算-m-的数值\"><a class=\"anchor\" href=\"#如何计算-m-的数值\">#</a> 如何计算 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 的数值</h2>\n<p>以闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 为例子，一般在计算中间下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 的方式就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mi>L</mi><mo>+</mo><mi>R</mi></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{L+R}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2223em;vertical-align:-0.35em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">⌋</span></span></span></span></span></span> ，具体的代码如下：</p>\n<pre><code class=\"language-cpp\">int mid = (left + right) / 2;\n</code></pre>\n<p>对于  <code>C++</code>  这样的语言，在计算  <code>mid</code>  的时候， <code>left + right</code>  可能会产生溢出，因此更加正确的方式如下：</p>\n<pre><code class=\"language-cpp\">int mid = left + (right - left) / 2;\n</code></pre>\n<p>类似地，我们可以得到其他区间形式的计算方式：</p>\n<ul>\n<li>开区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>，等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，则 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{(L+1)+(R-1)}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8em;vertical-align:-0.65em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">+</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌋</span></span></span></span></span></span>，即等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo>+</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{(L+R)}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8em;vertical-align:-0.65em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌋</span></span></span></span></span></span>，代码为  <code>int mid = (left + 1) + (right - 1 - (left + 1)) / 2;</code> ，也就是  <code>int mid = left + (right - left) / 2;</code> ；</li>\n<li>左闭右开区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>，等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，则 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mi>L</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{L+(R-1)}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8em;vertical-align:-0.65em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌋</span></span></span></span></span></span>，代码为  <code>int mid = left + (right - 1 - left) / 2;</code> ，也等价于  <code>int mid = left + (right - left) / 2;</code> ；</li>\n<li>左开右闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>，等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>，则 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>R</mi></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{(L+1)+R}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8em;vertical-align:-0.65em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌋</span></span></span></span></span></span>，代码为  <code>int mid = (left + 1) + (right - left) / 2;</code> 。</li>\n</ul>\n<p>总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>区间</th>\n<th>等价形式</th>\n<th>计算方式</th>\n<th>计算代码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mi>L</mi><mo>+</mo><mi>R</mi></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{L+R}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2223em;vertical-align:-0.35em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">⌋</span></span></span></span></span></span></td>\n<td><code>int mid = left + (right - left) / 2;</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mi>L</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{L+(R-1)}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8em;vertical-align:-0.65em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌋</span></span></span></span></span></span></td>\n<td><code>int mid = left + (right - left) / 2;</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>R</mi></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{(L+1)+R}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8em;vertical-align:-0.65em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌋</span></span></span></span></span></span></td>\n<td><code>int mid = (left + 1) + (right - left) / 2;</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence=\"true\">⌊</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow></mrow><annotation encoding=\"application/x-tex\">M=\\left\\lfloor\\frac{(L+1)+(R-1)}{2}\\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8em;vertical-align:-0.65em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">+</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⌋</span></span></span></span></span></span></td>\n<td><code>int mid = left + (right - left) / 2;</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"如何确定端点下标的变化方式\"><a class=\"anchor\" href=\"#如何确定端点下标的变化方式\">#</a> 如何确定端点下标的变化方式</h2>\n<p>在循环中，计算得到中间下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 之后，我们会判断其是否是我们的目标值  <code>target</code> 。显然，如果相等，那么我们找到了目标值，直接返回下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 即可。那么我们重点关注不等于的情况。</p>\n<p>仍然先以闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 为例。我们在循环中改变 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的值时，仍然要保证其表示的区间仍然满足我们最开始定义的性质：</p>\n<ul>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L, R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 中的元素是待查找对象</li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty, L-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 中的元素均<strong>小于</strong>目标值  <code>target</code></li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R+1, +\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> 中的元素均<strong>大于或等于</strong>目标值  <code>target</code></li>\n</ul>\n<p>因为我们有了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 下标对应值和目标值  <code>target</code>  之间的关系，那么我们可以根据这个新的信息来更新区间，以缩小我们的查找范围。</p>\n<p>对于  <code>arr[mid] &gt; target</code>  的情况，我们要移动下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>，而 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 是我们之后待查找的区间。由于  <code>arr[mid] &gt; target</code> ，则必然下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 已经被排除了，于是应当更新为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">R=M-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；类似地，如果是  <code>arr[mid] &lt; target</code> ，则应当更新为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L=M+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<p>对于其他区间，我们可以用类似的方式来分析，或者也可以用等价替换的方式，得到更新的具体方式：</p>\n<ul>\n<li>开区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 表示的下标是不在之后的判断区间之内的，因此更新方式为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">R=M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">L=M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>；又开区间等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，则依据上文闭区间的方式，有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>−</mo><mn>1</mn><mo>=</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">R-1=M-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">R=M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>，以及 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>M</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L+1=M+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">L=M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>；</li>\n<li>左闭右开区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 表示的下标在判断范围之内，更新方式为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L=M+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 表示的下标不在判断范围之内，更新方式为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">R=M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>；又此区间等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，则有更新方式 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>−</mo><mn>1</mn><mo>=</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">R-1=M-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">R=M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>，以及 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L=M+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；</li>\n<li>左开右闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 表示的下标不在判断范围之内，更新方式为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">L=M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 表示的下标在判断范围之内，更新方式为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">R=M-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；又此区间等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>，则有更新方式 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>M</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L+1=M+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，等价于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">L=M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>，以及 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">R=M-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。</li>\n</ul>\n<p>总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>区间</th>\n<th>等价形式</th>\n<th><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 更新方式</th>\n<th><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 更新方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><code>int left = mid + 1;</code></td>\n<td><code>int right = mid - 1;</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><code>int left = mid;</code></td>\n<td><code>int right = mid;</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><code>int left = mid + 1;</code></td>\n<td><code>int right = mid;</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><code>int left = mid;</code></td>\n<td><code>int right = mid - 1;</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"如何确定返回值\"><a class=\"anchor\" href=\"#如何确定返回值\">#</a> 如何确定返回值</h2>\n<p>如果数组中存在目标值  <code>target</code> ，那么在循环中会成功返回。而在循环外，该返回哪个下标呢？</p>\n<p>如果题目要求未找到时返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mi mathvariant=\"normal\">‘</mi></mrow><annotation encoding=\"application/x-tex\">-`</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">‘</span></span></span></span> 或者其他特殊值，那么直接返回特殊值即可。如果是我们前文的要求，返回第一个大于等于  <code>target</code>  的值的下标，则我们仍然可以根据区间性质来确定返回值。</p>\n<p>仍以闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 为例，我们有如下定义的区间性质：</p>\n<ul>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L, R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 中的元素是待查找对象</li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty, L-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 中的元素均<strong>小于</strong>目标值  <code>target</code></li>\n<li>下标区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R+1, +\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> 中的元素均<strong>大于或等于</strong>目标值  <code>target</code></li>\n</ul>\n<p>因为在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L=R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的情况下，仍然会进入循环，此时 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 也满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L=M=R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>，那么在循环退出之后，要么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">R=M-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，要么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mi>M</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L=M+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 的前一个位置。此时，区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty,L-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，也就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(-\\infty,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 中的所有元素均<strong>小于</strong>目标值  <code>target</code> ，区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[R+1,+\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span>，即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,+\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> 中的所有元素均<strong>大于或等于</strong>目标值  <code>target</code> 。那么根据题目的设定，我们可以返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">R+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，或者返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>。</p>\n<ul>\n<li>对于开区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>，等价于闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；</li>\n<li>对于左闭右开区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>，等价于闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 均可；</li>\n<li>对于左开右闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>，等价于闭区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span>，返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">R+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">L+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 均可。</li>\n</ul>\n<p>总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>区间</th>\n<th>等价形式</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><code>left</code>  或者  <code>right + 1</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><code>left + 1</code>  或者  <code>right</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[L,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L,R-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><code>left</code>  或者  <code>right</code></td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(L,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L+1,R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span></td>\n<td><code>left + 1</code>  或者  <code>right + 1</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"其他题目条件\"><a class=\"anchor\" href=\"#其他题目条件\">#</a> 其他题目条件</h2>\n<p>在本文的最开始，我们定义的二分查找是返回第一个<strong>大于等于</strong>  <code>target</code>  的元素。如果是其他的大于、小于或者小于等于的条件，我们也可以使用类似的方法来求取结果。</p>\n<p>前文介绍的了<strong>大于等于</strong>  <code>target</code>  的情况，对于<strong>大于</strong>  <code>target</code>  的情况，由于整数元素的性质，相当于查找大于等于  <code>target + 1</code>  的情况，这样就转化为了我们这里介绍的情形。</p>\n<p>对于<strong>小于</strong>  <code>target</code>  的情况，我们定义是返回小于  <code>target</code>  的<strong>最后一个</strong>元素，那么相当于找到<strong>大于等于</strong>  <code>target</code>  的元素下标  <code>n</code> ，然后返回前一个元素的下标  <code>n - 1</code> 。</p>\n<p>对于<strong>小于等于</strong>  <code>target</code>  的情况，依然定义是返回<strong>小于等于</strong>的<strong>最后一个</strong>元素，那么相当于找到<strong>大于</strong>  <code>target</code>  的第一个元素下标  <code>n</code> ，然后返回前一个元素的下标  <code>n - 1</code> 。</p>\n<p>综上，无论何种情形，我们都可以转化到我们本文介绍的情形。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>本文介绍了二分查找法的通用解决办法，在之前文章的基础上又有了更深的思考。其他二分类的查找问题也可以基于这个模板去思考，减少出错的概率。</p>\n",
            "tags": [
                "Computer-Science",
                "Algorithm",
                "Cpp",
                "Binary-Search"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/CUDA/CUDA-SGEMM-optimization-notes/",
            "url": "https://linn-ylz.com/Computer-Science/CUDA/CUDA-SGEMM-optimization-notes/",
            "title": "CUDA SGEMM优化笔记",
            "date_published": "2023-10-01T01:19:53.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>本篇博客记录了最近学习的 CUDA 单精度 GEMM 算法的优化过程。</p>\n<p>GEMM 算法是指 General Matrix Multiplication 算法，可以说是大多数线性代数算法的基础，也是目前热门的深度学习中最常用的基础计算，因此优化 GEMM 算法对于许多的应用有着重大意义。本篇博客关注的是 NVIDIA 的 GPU 设备上的 GEMM 算法实现，以 cuBLAS 库的算法性能作为比较基线，不断优化算法以逼近该基线。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-cublas.png\" alt=\"cuBLAS kernel\" /></p>\n<h2 id=\"基础知识\"><a class=\"anchor\" href=\"#基础知识\">#</a> 基础知识</h2>\n<p>本节将简要介绍 GPU 的计算模型和内存模型的基础知识。因为算法优化部分的内容较长，本节尽量精简。如果之后有时间，后续可能会详细介绍该部分的内容。</p>\n<h3 id=\"gpu-计算模型\"><a class=\"anchor\" href=\"#gpu-计算模型\">#</a> GPU 计算模型</h3>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/CUDA-computation-model.png\" alt=\"CUDA Computation Model\" /></p>\n<p>GPU 的计算模型可以分为上图所示的三级。最基础的执行单元是 thread，用于执行控制单元下发的指令。每个 thread 都属于某一个 block，block 可以有三个维度，在线程中可以通过 CUDA 内置的变量来获取线程对应的 id。每个 block 则又属于一个 grid，grid 也可以有三个维度，有 CUDA 内置变量用于确定 block 的 id。</p>\n<p>对于 thread，可以使用  <code>threadIdx.x</code> ， <code>threadIdx.y</code> ， <code>threadIdx.z</code>  获取其在三个维度上的坐标以确定其 “身份”。当然，如果某一个维度的大小为 1，那么我们计算时可以省略。我们可以通过  <code>blockDim.x</code> ， <code>blockDim.y</code> ， <code>blockDim.z</code>  获取线程所在 block 三个维度的大小。类似地，block 可以使用  <code>blockIdx.x</code> ， <code>bloxkIdx.y</code> ， <code>blockIdx.z</code>  获取其在三个维度上的坐标， <code>gridDim.x</code> ， <code>gridDim.y</code> ， <code>gridDim.z</code>  可以获取 block 所在 grid 的三个维度的大小。</p>\n<p>而具体到调度层面，需要注意，CUDA 以 block 为单位，将其中的线程调度到某一个 SM（Streaming Multiprocessor）上执行，而在真正执行的时候，CUDA 会将 block 中的线程以 32 个为一个 warp 进行调度，它们的线程 id 连续。如果线程数量不是 32 的倍数，那么 CUDA 会将其补齐。所以我们为每个 block 分配线程时，尽量将数量设置为 32 的倍数。</p>\n<p>另外提一句，在访存的时候，会以 half-warp 为单位访存，也就是线程 id 连续的 16 个线程一组进行访存，在考虑 bank conflict 的时候需要注意这一点。</p>\n<p>在调用编写的核函数时，我们需要指定 grid 和 block 的维度，一个简单的示例如下：</p>\n<pre><code class=\"language-c\">// Kernel definition  \n__global__ void MatAdd(float A[N][N], float B[N][N], float C[N][N])  \n&#123;  \n    int i = blockIdx.x * blockDim.x + threadIdx.x;  \n    int j = blockIdx.y * blockDim.y + threadIdx.y;  \n    if (i &lt; N &amp;&amp; j &lt; N)  \n        C[i][j] = A[i][j] + B[i][j];  \n&#125;  \nint main()  \n&#123;  \n    ...  \n    // Kernel invocation  \n    dim3 threadsPerBlock(16, 16);  \n    dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y);  \n    MatAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C);  \n    ...  \n&#125;\n</code></pre>\n<h3 id=\"gpu-内存模型\"><a class=\"anchor\" href=\"#gpu-内存模型\">#</a> GPU 内存模型</h3>\n<p>GPU 的内存可以分为 off-chip 和 on-chip 内存两大类别。off-chip 的特点是容量大，但是访存延迟高；on-chip 的特点则是容量小，但是访存延迟低。</p>\n<p>off-chip 内存主要有 global memory，on-chip 内存则主要有 shared memory 和 register。三者中，register 的访存速度最快，shared memory 次之，global memory 最慢。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/memory-hierarchy.png\" alt=\"CUDA Memory Hierarchy\" /></p>\n<p>如上图所示，每个 block 之间共享 global memory，而每个 block 自己则有一块 shared memory，block 中的每个 thread 共享这块 shared memory。此外，每个线程有自己独占的 register 和 local memory，local memory 一般也存放在 global memory 中。</p>\n<p>由于 global memory 访存延迟较高，我们很多时候都会将数据读取到 shared memory 中；在某些情况下，甚至会手动使用 register 来缓存 shared memory 中的数据。</p>\n<p>可以说，想要优化好 CUDA 上的算法，必须要注意降低或者隐藏访存延迟的开销，在后续的算法优化中我们可以看到这一点。</p>\n<p>在调用编写的核函数之前，我们需要使用  <code>cudaMalloc</code>  和  <code>cudaMemcpy</code>  函数来在 GPU 上分配内存，并将 host 侧的数据拷贝到 device 侧。</p>\n<h2 id=\"gemm-算法优化\"><a class=\"anchor\" href=\"#gemm-算法优化\">#</a> GEMM 算法优化</h2>\n<p>cuBLAS 中实现的通用的 GEMM 算法形式为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>=</mo><mi>α</mi><mi>A</mi><mi>B</mi><mo>+</mo><mi>β</mi><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C=\\alpha AB+\\beta C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">βC</span></span></span></span>。其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A,B,C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 均为矩阵，shape 为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>×</mo><mi>K</mi><mo separator=\"true\">,</mo><mi>K</mi><mo>×</mo><mi>N</mi><mo separator=\"true\">,</mo><mi>M</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M\\times K,K\\times N,M \\times N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span> 为标量。</p>\n<p>最简单的实现是 CPU 的串行算法。如果我们对于某个算法在 GPU 中的实现感到难以下手，那么我们可以先从 CPU 算法开始。</p>\n<pre><code class=\"language-cpp\">#define OFFSET(row, col, stride) ((row) * (stride) + (col))\nvoid cpu_naive_matmul(int M, int N, int K, float alpha, float *A, float *B, float beta, float *C) &#123;\n    for (int m = 0; m &lt; M; ++m) &#123;\n        for (int n = 0; n &lt; N; ++n) &#123;\n            float val = 0.;\n            for (int k = 0; k &lt; K; ++k) &#123;\n                val += A[OFFSET(m, k, K)] * B[OFFSET(k, n, N)];\n            &#125;\n            C[OFFSET(m, n, N)] = alpha * val + beta * C[OFFSET(m, n, N)];\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"naive-实现\"><a class=\"anchor\" href=\"#naive-实现\">#</a> Naive 实现</h3>\n<p>本节介绍最简单的 CUDA SGEMM 实现，每个线程负责矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 中的一个元素的计算。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/naive-kernel.png\" alt=\"CUDA naive kernel 实现\" /></p>\n<p>假定我们启动核函数时的 block 大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>M</mi><mo>×</mo><mi>B</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">BM\\times BN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BN</span></span></span></span>，那么我们可以计算每个线程对应的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 中元素的下标：</p>\n<pre><code class=\"language-c\">int col = blockIdx.x * blockDim.x + threadIdx.x;  \nint row = blockIdx.y * blockDim.y + threadIdx.y;\n</code></pre>\n<p>我们在启动核函数时，一个 grid 中可能会包含多个 block，所以这里还要使用  <code>blockIdx.x</code> ， <code>blockIdx.y</code>  和  <code>blockDim.x</code>  和  <code>blockDim.y</code>  相乘获取每个 block 的基址，即每个 block 最左上方的元素对应的下标。然后再分别加上线程在 block 中的偏移  <code>threadIdx.x</code>  和  <code>threadIdx.y</code> 。</p>\n<p>后续的步骤就和 CPU 版本的代码相差无几了：</p>\n<pre><code class=\"language-c\">if (row &lt; M &amp;&amp; col &lt; N) &#123;  \n    float val = 0.;  \n    for (int k = 0; k &lt; K; ++k) &#123;  \n        val += A[OFFSET(row, k, K)] * B[OFFSET(k, col, N)];  \n    &#125;  \n    C[OFFSET(row, col, N)] = alpha * val + beta * C[OFFSET(row, col, N)];  \n&#125;\n</code></pre>\n<p>这里加上了  <code>if (row &lt; M &amp;&amp; col &lt; N)</code>  判断以防越界，因为有时候<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 无法被 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">BM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span></span></span></span>，或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 无法被 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">BN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BN</span></span></span></span> 整除。</p>\n<p>完整代码如下：</p>\n<pre><code class=\"language-c\">#define OFFSET(row, col, stride) ((row) * (stride) + (col))  \n__global__ void naive_kernel(int M, int N, int K, \n                             float alpha, float *A, float *B, float beta, float *C) &#123;  \n    int col = blockIdx.x * blockDim.x + threadIdx.x;  \n    int row = blockIdx.y * blockDim.y + threadIdx.y;  \n    if (row &lt; M &amp;&amp; col &lt; N) &#123;  \n        float val = 0.;  \n        for (int k = 0; k &lt; K; ++k) &#123;  \n            val += A[OFFSET(row, k, K)] * B[OFFSET(k, col, N)];  \n        &#125;  \n        C[OFFSET(row, col, N)] = alpha * val + beta * C[OFFSET(row, col, N)];  \n    &#125;  \n&#125;\n</code></pre>\n<p>性能比较如下：</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-naive.png\" alt=\"naive kernel\" /></p>\n<p>可以看到，朴素实现的性能基本都在 1000 GFLOPS 左右，只有 cuBLAS 库性能的十分之一。</p>\n<p>我们可以做一个简单的计算。对于矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 中的每个元素，我们需要访问 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 中各 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 个元素，总共 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">2K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 次全局内存访问。同时，循环中进行了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 次乘法和加法共 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">2K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 次运算。计算下来，平均每一次计算就需要一次访存。考虑到 global memory 的访存延迟，这样的做法显然是非常没有效率的。</p>\n<p>通过 Nsight Compute 工具也可以看到， <code>warp</code>  花费了大量时间等待全局内存的读写：</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/naive-kernel-warp-state.png\" alt=\"naive kernel warp state\" /></p>\n<p>切换到代码页面也能看到具体是哪些代码导致了这些 stall。可以发现，我们的核心计算语句耗费了大量时间等待访存读写，这也是我们可以优化的着手点。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/naive-kernel-hotspot-code.png\" alt=\"naive kernel hotspot code\" /></p>\n<h3 id=\"使用-shared-memory-优化访存\"><a class=\"anchor\" href=\"#使用-shared-memory-优化访存\">#</a> 使用 Shared Memory 优化访存</h3>\n<p>朴素实现中对输入的访问全部都是直接对全局内存进行操作。前文中我们提到，全局内存的访存速度是最慢的，这限制了核函数的计算效率，每个线程耗费了大量的时间等待访存。我们可以尝试使用共享内存来缓存一部分的输入。</p>\n<p>可以发现，对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 中的每一行元素，在计算过程中都需要访问 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 矩阵中的同一行元素；对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 中每一列元素，在计算过程中需要访问 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 矩阵中的同一列元素。那么，对于一个 block 中需要计算的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>M</mi><mo>×</mo><mi>B</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">BM \\times BN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BN</span></span></span></span> 元素，有许多对相同地址的重复访问。因此，我们可以使用共享内存预先读取全局内存中所需要的元素，然后计算时直接读取共享内存，节省访存时的等待时间。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/shared-memory-kernel.png\" alt=\"CUDA 使用 shared memory 的实现\" /></p>\n<p>我们开辟两块 shared memory 中的空间，分别用于存储从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 中读取的元素：</p>\n<pre><code class=\"language-c\">__shared__ float As[BM][BK];  \n__shared__ float Bs[BK][BN];\n</code></pre>\n<p>计算时，我们每次需要读取每行或者每列中的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">BK</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 个元素，那么需要迭代 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>B</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K/BK</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 次，每次读取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 中的一块区域的元素。然后对读取的元素，每个线程使用其所需的元素进行计算。</p>\n<pre><code class=\"language-c\">float val = 0.;  \nint num_shared_block = CEIL_DIV(K, BK); \nA = &amp;A[OFFSET(blockIdx.y * BM, 0, K)]; // Relative position \nB = &amp;B[OFFSET(0, blockIdx.x * BN, N)]; // Relative position\nC = &amp;C[OFFSET(blockIdx.y * BM, blockIdx.x * BN, N)]; // Relative position\n  \nfor (int i = 0; i &lt; num_shared_block; ++i) &#123;  \n    // Copy data from global memory to shared memory  \n    int A_row = threadIdx.y;  \n    int A_col = threadIdx.x;  \n    if ((blockIdx.y * BM + A_row) &lt; M &amp;&amp; (i * BK + A_col) &lt; K) &#123;  \n        As[threadIdx.y][threadIdx.x] = A[OFFSET(A_row, A_col, K)];  \n    &#125; else &#123;  \n        As[threadIdx.y][threadIdx.x] = 0.;  \n    &#125;  \n    int B_row = threadIdx.y;  \n    int B_col = threadIdx.x;  \n    if ((i * BK + B_row) &lt; K &amp;&amp; (blockIdx.x * BN + B_col) &lt; N) &#123;  \n        Bs[threadIdx.y][threadIdx.x] = B[OFFSET(B_row, B_col, N)];  \n    &#125; else &#123;  \n        Bs[threadIdx.y][threadIdx.x] = 0.;  \n    &#125;  \n    __syncthreads();  \n    A += BK;  // Add offset\n    B += BK * N;  // Add offset\n    for (int k = 0; k &lt; BK; ++k) &#123;  \n        val += As[threadIdx.y][k] * Bs[k][threadIdx.x];  \n    &#125;  \n    __syncthreads();  \n&#125;  \n</code></pre>\n<p>注意上述代码中，我们为三个矩阵的指针添加了偏移量，后续计算坐标时，只需要计算其在子矩阵中的相对位置即可。不过也要注意，在判断是否越界时，需要转换为全局的下标，否则会判断错误。</p>\n<p>每次迭代中，我们只计算了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 中对应元素值的一部分，待到迭代完毕，便得到了最终的结果。注意迭代过程中，使用了  <code>__syncthreads()</code>  来同步每个线程，防止数据读取不同步，造成读取的数据错误。</p>\n<p>最后，将计算结果写回：</p>\n<pre><code class=\"language-c\">int C_row = threadIdx.y;  \nint C_col = threadIdx.x;  \nif ((blockIdx.y * BM + C_row) &lt; M &amp;&amp; (blockIdx.x * BN + C_col) &lt; N) &#123;  \n    C[OFFSET(C_row, C_col, N)] = alpha * val + beta * C[OFFSET(C_row, C_col, N)];  \n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-sm.png\" alt=\"shared memory kernel\" /></p>\n<p>emmm，理论上而言，每个 block 需要从全局内存中读取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>K</mi><mrow><mi>B</mi><mi>K</mi></mrow></mfrac><mo>×</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mi>M</mi><mo>×</mo><mi>B</mi><mi>K</mi><mo>+</mo><mi>B</mi><mi>K</mi><mo>×</mo><mi>B</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{K}{BK}\\times(BM\\times BK + BK\\times BN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2173em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BN</span><span class=\"mclose\">)</span></span></span></span> 个浮点数。而朴素算法中，一个 block 总共需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>K</mi><mo>×</mo><mi>B</mi><mi>M</mi><mo>×</mo><mi>B</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">2K\\times BM \\times BN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BN</span></span></span></span> 次访存。可以看到，使用了一维 Tile 方法之后，访存降为了原来的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy=\"false\">(</mo><mfrac><mn>1</mn><mrow><mi>B</mi><mi>N</mi></mrow></mfrac><mo>+</mo><mfrac><mn>1</mn><mrow><mi>B</mi><mi>M</mi></mrow></mfrac><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{2}(\\frac{1}{BN}+\\frac{1}{BM})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BN</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BM</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span></span></span></span>。一般有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>M</mi><mo>=</mo><mi>B</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">BM=BN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BN</span></span></span></span>，因此，全局内存访问将为了原来的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>B</mi><mi>M</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{BM}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BM</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。而每个线程的计算量不变，则计算访存比也降低为原来的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>B</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{BN}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BN</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。不过从我测试的结果来看，和 naive 的结果比较并没有明显的区别，甚至还变差了一丢丢。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/shared-memory-kernel-warp-state.png\" alt=\"shared memory kernel warp state\" /></p>\n<p>可以看到，这次是  <code>Stall MIO Throttle</code>  这一项的 stall cycles 最多。这一项根据文档说明，一般是某些特殊的数学计算函数、动态分支、共享内存读写导致的，放在我们的上下文中，那就可以肯定是共享内存导致的瓶颈，在横轴上几乎和使用全局内存的代码一致，数值也很接近。这也是为什么这段代码和直接使用全局代码的性能几乎没有变化。</p>\n<h3 id=\"一维-tile\"><a class=\"anchor\" href=\"#一维-tile\">#</a> 一维 Tile</h3>\n<p>要进一步优化，可以从前文的 profiling 结果入手。我们无论是使用全局内存还是共享内存，主要的瓶颈都在访存上。为了进一步掩盖访存开销，我们要么可以提高访存的效率，要么让每个线程的负载更多一点，以使得能够掩盖访存的开销。</p>\n<p>这里我们先尝试提高每个线程的负载， 让每个线程多计算一些元素的输出。这里我们让每个线程计算矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 一列中连续几个元素的值。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/thread-tile-1d-kernel.png\" alt=\"一维 Tile\" /></p>\n<p>在使用共享内存的基础上，我们添加了一维 Tile 的代码。</p>\n<pre><code class=\"language-c\">float val[TM] = &#123;0.&#125;;\n</code></pre>\n<p>因为每个线程需要计算 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">TM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span></span></span></span> 个元素的结果，我们使用一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">TM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span></span></span></span> 大小的数组来存储中间结果。</p>\n<p>在拷贝数据时，每个线程需要在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 矩阵中多拷贝 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">TM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span></span></span></span> 次：</p>\n<pre><code class=\"language-c\">// Copy data from global memory to shared memory  \nfor (int m = 0; m &lt; TM; ++m) &#123;  \n    int A_row = threadIdx.y * TM + m;  \n    int A_col = threadIdx.x;  \n    if ((blockIdx.y * BM + A_row) &lt; M &amp;&amp; (i * BK + A_col) &lt; K) &#123;  \n        As[A_row][A_col] = A[OFFSET(A_row, A_col, K)];  \n    &#125; else &#123;  \n        As[A_row][A_col] = 0.;  \n    &#125;  \n&#125;\n</code></pre>\n<p>计算中间结果时，也需要多一层循环：</p>\n<pre><code class=\"language-c\">for (int k = 0; k &lt; BK; ++k) &#123;  \n    for (int m = 0; m &lt; TM; ++m) &#123;  \n        int A_row = threadIdx.y * TM + m;  \n        int B_col = threadIdx.x;  \n        val[m] += As[A_row][k] * Bs[k][B_col];  \n    &#125;  \n&#125;\n</code></pre>\n<p>最后，将计算结果写回：</p>\n<pre><code class=\"language-c\">for (int m = 0; m &lt; TM; ++m) &#123;  \n    int C_row = threadIdx.y * TM + m;  \n    int C_col = threadIdx.x;  \n    if ((blockIdx.y * BM + C_row) &lt; M &amp;&amp; (blockIdx.x * BN + C_col) &lt; N) &#123;  \n        C[OFFSET(C_row, C_col, N)] = alpha * val[m] + beta * C[OFFSET(C_row, C_col, N)];  \n    &#125;  \n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-tile-1d.png\" alt=\"1d tile kernel\" /></p>\n<p>可以看到，使用 Tile 之后，性能得到了一定的提升，逼近了 2000 GFLOPS。一个 block 全局访存的数量依然为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">K(M+N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，但是每个线程负责的计算量为原来的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">TM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span></span></span></span> 倍，因此计算访存比提升了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">TM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span></span></span></span> 倍。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/tile-1d-kernel-warp-state.png\" alt=\"tile 1d kernel warp state\" /></p>\n<p>这次可以看到，相比仅使用共享内存，增加线程计算负载之后  <code>Stall MIO Throttle</code>  这一项的横轴数值有了减小，之前超过了 20 cycles per instruction，现在已经在 20 以下了。不过也可以看出，这一项的延时依然较高，我们还可以有提升空间。</p>\n<h3 id=\"二维-tile\"><a class=\"anchor\" href=\"#二维-tile\">#</a> 二维 Tile</h3>\n<p>和一维 Tile 类似，这次我们让每个线程负责计算矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 中一小块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi><mo>×</mo><mi>T</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">TM \\times TN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TN</span></span></span></span> 区域中的元素，进一步提升每个线程的负载。有了一维 Tile 的代码，我们简单地在其基础之上做少许修改，便可以得到二维 Tile 的代码。</p>\n<p>存储中间结果需要分配 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi><mo>×</mo><mi>T</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">TM \\times TN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TN</span></span></span></span> 大小的空间：</p>\n<pre><code class=\"language-c\">float val[TM][TN] = &#123;0.&#125;;\n</code></pre>\n<p>注意这里的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">TM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">TN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TN</span></span></span></span> 不能设置过大，否则可能寄存器资源不够，导致 register spill，这时中间数据便会使用 local memory 存储，访存速度会慢很多。</p>\n<p>拷贝数据时，在矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 上也要多拷贝 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">TN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TN</span></span></span></span> 次：</p>\n<pre><code class=\"language-c\">for (int n = 0; n &lt; TN; ++n) &#123;  \n    int B_row = threadIdx.y;  \n    int B_col = threadIdx.x * TN + n;  \n    if ((i * BK + B_row) &lt; K &amp;&amp; (blockIdx.x * BN + B_col) &lt; N) &#123;  \n        Bs[B_row][B_col] = B[OFFSET(B_row, B_col, N)];  \n    &#125; else &#123;  \n        Bs[B_row][B_col] = 0.;  \n    &#125;  \n&#125;\n</code></pre>\n<p>同理，计算结果时需要使用二重循环：</p>\n<pre><code class=\"language-c\">for (int k = 0; k &lt; BK; ++k) &#123;  \n    for (int m = 0; m &lt; TM; ++m) &#123;  \n        int A_row = threadIdx.y * TM + m;  \n        for (int n = 0; n &lt; TN; ++n) &#123;  \n            int B_col = threadIdx.x * TN + n;  \n            val[m][n] += As[A_row][k] * Bs[k][B_col];  \n        &#125;  \n    &#125;  \n&#125;\n</code></pre>\n<p>结果写回：</p>\n<pre><code class=\"language-c\">for (int m = 0; m &lt; TM; ++m) &#123;  \n    int C_row = threadIdx.y * TM + m;  \n    for (int n = 0; n &lt; TN; ++n) &#123;  \n        int C_col = threadIdx.x * TN + n;  \n        if ((blockIdx.y * BM + C_row) &lt; M &amp;&amp; (blockIdx.x * BN + C_col) &lt; N) &#123;  \n            C[OFFSET(C_row, C_col, N)] = alpha * val[m][n] + beta * C[OFFSET(C_row, C_col, N)];  \n        &#125;  \n    &#125;  \n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-tile-2d.png\" alt=\"2d tile kernel\" /></p>\n<p>可以看到，现在的性能相比朴素的实现有了很大的提升，性能接近了 4000 GFLOPS。在一维 Tile 的基础之上，计算访存比进一步提升了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">TN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TN</span></span></span></span> 倍。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/tile-2d-kernel-warp-state.png\" alt=\"tile 2d kernel warp state\" /></p>\n<p>可以看到，现在的  <code>Stall MIO Throttle</code>  已经降低到 11 cycles per instruction。相比仅使用共享内存，降低到了原来的不到一半。性能的数值也和 profiling 的结果能够互相印证。</p>\n<h3 id=\"使用寄存器进一步优化访存\"><a class=\"anchor\" href=\"#使用寄存器进一步优化访存\">#</a> 使用寄存器进一步优化访存</h3>\n<p>对于二维 Tile 中计算矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 结果的代码：</p>\n<pre><code class=\"language-c\">for (int k = 0; k &lt; BK; ++k) &#123;  \n    for (int m = 0; m &lt; TM; ++m) &#123;  \n        int A_row = threadIdx.y * TM + m;  \n        for (int n = 0; n &lt; TN; ++n) &#123;  \n            int B_col = threadIdx.x * TN + n;  \n            val[m][n] += As[A_row][k] * Bs[k][B_col];  \n        &#125;  \n    &#125;  \n&#125;\n</code></pre>\n<p>可以看到，对于  <code>As</code>  中的内容重复访问了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">TN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TN</span></span></span></span> 次；对于  <code>Bs</code>  中的内容，在外层的  <code>m</code>  迭代中，也会重复访问 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">TM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span></span></span></span> 次。因此，我们可以使用寄存器将这部分内容缓存下来，进一步提升访存。</p>\n<pre><code class=\"language-c\">for (int k = 0; k &lt; BK; ++k) &#123;  \n    for (int m = 0; m &lt; TM; ++m) &#123;  \n        int A_row = threadIdx.y * TM + m;  \n        As_cache[m] = As[A_row][k];  \n    &#125;  \n    for (int n = 0; n &lt; TN; ++n) &#123;  \n        int B_col = threadIdx.x * TN + n;  \n        Bs_cache[n] = Bs[k][B_col];  \n    &#125;  \n    for (int m = 0; m &lt; TM; ++m) &#123;  \n        for (int n = 0; n &lt; TN; ++n) &#123;  \n            val[m][n] += As_cache[m] * Bs_cache[n];  \n        &#125;  \n    &#125;  \n&#125;\n</code></pre>\n<p>不过这部分的优化在我的测试中对性能的提升并不明显。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-reg-cache.png\" alt=\"register cache kernel\" /></p>\n<p>在 profiling 的结果中发现，和使用之前对于  <code>Stall MIO Throttle</code>  指标几乎没有降低，也就是并没有降低访存的开销。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/reg-cache-kernel-code.png\" alt=\"register cache kernel code\" /></p>\n<p>从代码对应图中可以看到，虽然我们使用了寄存器，但是从共享内存读取数据到寄存器中的时候依然存在较大的  <code>MIO</code>  延迟，即这个延迟只是从一条语句转移到了其他语句之上，并没有被我们掩盖掉，所以没有性能提升也就是正常的了。</p>\n<h3 id=\"使用-float4-指令优化访存\"><a class=\"anchor\" href=\"#使用-float4-指令优化访存\">#</a> 使用 FLOAT4 指令优化访存</h3>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/tile-2d-performance-analysis.png\" alt=\"tile 2d performance analysis\" /></p>\n<p>通过前面 profiling 的结果，能够发现很大一部分时间仍然花在了等待访存之上。可以看到，内存带宽的使用负载大于计算的负载。访存延迟依然是程序性能的瓶颈。</p>\n<p>我们可以进一步利用 GPU  <code>float4</code>  访存特性来进一步优化，让每个元素一次获取 4 个浮点数，进一步减少访存次数。相比于访存 4 次获取 4 个浮点数，通过  <code>float4</code>  向量内存指令所需的访存指令数更少，减少了对内存访问的竞争；另一方面，使用向量加载每个字节需要的索引计算更少，我们只需要计算一次索引即可读取 4 个浮点数。但是这样一来，代码也会变得略显复杂。</p>\n<p>同时，我们在读取矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 的内容时，还要对其进行转置，然后再存储到 shared memory 中，以方便后续线程计算时使用  <code>float4</code>  读取，以避免共享内存的 bank conflict。</p>\n<p>我们使用以下宏来定义一次访问 4 个浮点数的操作：</p>\n<pre><code class=\"language-c\">#define FETCH_FLOAT4(pointer) (reinterpret_cast&lt;float4*&gt;(&amp;(pointer))[0])\n</code></pre>\n<p>需要注意，因为使用了 FLOAT4 访存的缘故，矩阵的元素数量必须是 4 的倍数，不再能够支持任意大小的矩阵<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n<p>对于  <code>As</code>  缓存，其分配的空间能够存储 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>M</mi><mo>×</mo><mi>B</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">BM\\times BK</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 个浮点数，在一个 block 中共有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>B</mi><mi>M</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi><mi>M</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mi>N</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(BM/TM)\\times (BN/TN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TM</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BN</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">TN</span><span class=\"mclose\">)</span></span></span></span> 个线程，每个线程一次读取 4 个浮点数，那么总共需要读取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>B</mi><mi>M</mi><mo>×</mo><mi>B</mi><mi>K</mi></mrow><mrow><mi>B</mi><mi>M</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi><mi>M</mi><mo>×</mo><mi>B</mi><mi>N</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi><mi>N</mi><mo>×</mo><mn>4</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{BM\\times BK}{BM/TM\\times BN/TN \\times 4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3923em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mord mtight\">/</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">TM</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BN</span><span class=\"mord mtight\">/</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">TN</span><span class=\"mbin mtight\">×</span><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 次；同理， <code>Bs</code>  缓存需要读取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>B</mi><mi>K</mi><mo>×</mo><mi>B</mi><mi>N</mi></mrow><mrow><mi>B</mi><mi>M</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi><mi>M</mi><mo>×</mo><mi>B</mi><mi>N</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi><mi>N</mi><mo>×</mo><mn>4</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{BK\\times BN}{BM/TM\\times BN/TN \\times 4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3923em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mord mtight\">/</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">TM</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BN</span><span class=\"mord mtight\">/</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">TN</span><span class=\"mbin mtight\">×</span><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">BN</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</p>\n<pre><code class=\"language-c\">const int block_row_thread = BN / TN;  \nconst int block_col_thread = BM / TM;  \nconst int thread_num = block_row_thread * block_col_thread;\nconst int load_a_cache_time = (BK * BM) / thread_num / 4;  // Each thread load 4 float\nconst int load_b_cache_time = (BK * BN) / thread_num / 4;  // Each thread load 4 float\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/float4-kernel.png\" alt=\"使用 float4 访存\" /></p>\n<p>如上图所示，假设 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>K</mi><mo>=</mo><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">BK=16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">16</span></span></span></span>，共有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 个线程，那么一次读取就能够读完  <code>As</code>  中的两行。那么每个线程下一次读取时间隔的行数就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mi>K</mi><mi mathvariant=\"normal\">/</mi><mn>4</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">8/(BK/4)=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">8/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/4</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>。</p>\n<p>其实，我们不妨把  <code>As</code>  看成一个矩阵元素是  <code>float4</code>  的矩阵，那么原来的  <code>As</code>  就相当于一个大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>M</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mi>K</mi><mi mathvariant=\"normal\">/</mi><mn>4</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">BM\\times (BK/4)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/4</span><span class=\"mclose\">)</span></span></span></span> 大小的新矩阵  <code>As_new</code> 。那么，我们可以根据线程的  <code>id</code>  来计算其对应放置的地址偏移，我们不妨把线程看成一维的，这样更方便计算。</p>\n<p>首先，计算出线程的 id：</p>\n<pre><code class=\"language-c\">int thread_id = threadIdx.y * blockDim.x + threadIdx.x;\n</code></pre>\n<p><code>As</code>  中每一行需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>K</mi><mi mathvariant=\"normal\">/</mi><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">BK/4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/4</span></span></span></span> 个线程读取，那么线程对应的行数为：</p>\n<pre><code class=\"language-c\">int a_tile_row = thread_id / (BK / 4);\n</code></pre>\n<p>同理，对应的列数为  <code>thread_id % (BK / 4)</code> 。不过这是  <code>As_new</code>  中地址便宜，换算回  <code>As</code>  还得乘 4，也就是：</p>\n<pre><code class=\"language-c\">int a_tile_col = thread_id % (BK / 4) * 4;\n</code></pre>\n<p>按照上述方式，我们也可以计算得出  <code>Bs</code>  的对应偏移：</p>\n<pre><code class=\"language-c\">int b_tile_row = thread_id / (BN / 4);  \nint b_tile_col = thread_id % (BN / 4) * 4;\n</code></pre>\n<p>上述计算的地址是每次读取的子矩阵中的相对偏移，每次读取时，我们还需要添加一个基址偏移。对于  <code>As</code> ，共有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">BM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">BM</span></span></span></span> 行，上面计算得到了共需要读取  <code>load_a_cache_time</code> ，那么可以知道每次需要偏移的大小为：</p>\n<pre><code class=\"language-c\">int a_tile_stride = BM / load_a_cache_time;\n</code></pre>\n<p>同理， <code>Bs</code>  中的对应大小为：</p>\n<pre><code class=\"language-c\">int b_tile_stride = BK / load_b_cache_time;\n</code></pre>\n<p>在读取  <code>As</code>  时，注意还需要对其进行转置，其代码如下：</p>\n<pre><code class=\"language-c\">for (int i = 0; i &lt; BM; i += a_tile_stride) &#123;  \n    int cache_idx = i / a_tile_stride * 4;  \n    FETCH_FLOAT4(load_a_cache[cache_idx]) =  \n            FETCH_FLOAT4(A[OFFSET(a_tile_row + i, a_tile_col, K)]);  \n    // Use load_a_cache for load 4 float at a time  \n    // As is saved as transpose matrix  \n    As[a_tile_col][a_tile_row + i] = load_a_cache[cache_idx];  \n    As[a_tile_col + 1][a_tile_row + i] = load_a_cache[cache_idx + 1];  \n    As[a_tile_col + 2][a_tile_row + i] = load_a_cache[cache_idx + 2];  \n    As[a_tile_col + 3][a_tile_row + i] = load_a_cache[cache_idx + 3];  \n&#125;\n</code></pre>\n<p>这里开辟了一个寄存器缓存  <code>load_a_cache</code> ，作为转置时的临时存放空间，其大小为  <code>load_a_cache_time * 4</code> 。注意下面为每次读取单独开辟了空间存储，而不是复用之前的空间。我在测试的时候发现，如果复用之前的空间，会因为数据写入地址的依赖导致计算结果出错。</p>\n<pre><code class=\"language-c\">float load_a_cache[4 * load_a_cache_time];\n</code></pre>\n<p>每次读取时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 矩阵的基础行偏移量为循环变量中的  <code>i</code> ，其每次变化  <code>a_tile_stride</code> ，在此基础之上，每个线程本身还需要添加一个行偏移量  <code>a_tile_row</code> ，和列偏移量  <code>a_tile_col</code> 。每次读取 4 个元素，将其存放在  <code>load_a_cache</code>  中的对应位置， <code>cache_idx</code>  可以由  <code>i / a_tile_stride * 4</code>  计算得到， <code>i / a_tile_stride</code>  表示迭代的次数，乘 4 表示每次存放 4 个元素。</p>\n<p>读取之后，我们将  <code>load_a_cache</code>  中的元素转置存放在  <code>As</code>  中，注意下标的计算。</p>\n<p>类似地， <code>Bs</code>  的读取代码如下：</p>\n<pre><code class=\"language-c\">for (int i = 0; i &lt; BK; i += b_tile_stride) &#123;  \n    FETCH_FLOAT4(Bs[b_tile_row + i][b_tile_col]) =  \n            FETCH_FLOAT4(B[OFFSET(b_tile_row + i, b_tile_col, N)]);  \n&#125;\n</code></pre>\n<p>因为  <code>Bs</code>  不需要转置，我们可以直接将其存放在  <code>Bs</code>  对应位置中。</p>\n<p>注意上述代码中的  <code>A</code>  和  <code>B</code>  都预先添加了偏移量， <code>C</code>  也是：</p>\n<pre><code class=\"language-c\">A = &amp;A[OFFSET(blockIdx.x * BN;, 0, K)]; // Set block start position  \nB = &amp;B[OFFSET(0, blockIdx.y * BM;, N)];  \nC = &amp;C[OFFSET(blockIdx.x * BN, blockIdx.y * BM, N)];\n</code></pre>\n<p>后续的计算基本和二维 Tile 中的代码一致，只不过我们会一次性读取 4 个浮点数：</p>\n<pre><code class=\"language-c\">for (int i = 0; i &lt; BK; ++i) &#123;  \n    for (int m = 0; m &lt; TM; m += 4) &#123;  \n        FETCH_FLOAT4(As_cache[m]) = FETCH_FLOAT4(As[i][ty + m]);  \n    &#125;  \n    for (int n = 0; n &lt; TN; n += 4) &#123;  \n        FETCH_FLOAT4(Bs_cache[n]) = FETCH_FLOAT4(Bs[i][tx + n]);  \n    &#125;  \n    for (int m = 0; m &lt; TM; ++m) &#123;  \n        for (int n = 0; n &lt; TN; ++n) &#123;  \n            accum[m][n] += As_cache[m] * Bs_cache[n];  \n        &#125;  \n    &#125;  \n&#125;\n</code></pre>\n<div class=\"note info\">\n<p>注意本文的所有  <code>for</code>  循环代码中，为了简洁，去掉了每个  <code>for</code>  循环上的  <code>#pragma unroll</code>  循环展开指令。实际中可以添加该指令进一步提升指令吞吐。</p>\n</div>\n<p>后续写回结果，也可以使用  <code>float4</code>  来减少访存次数：</p>\n<pre><code class=\"language-c\">float tmp[4] = &#123;0.&#125;;  \nfor (int m = 0; m &lt; TM; ++m) &#123;  \n    for (int n = 0; n &lt; TN; n += 4) &#123;  \n        FETCH_FLOAT4(tmp) = FETCH_FLOAT4(C[OFFSET(ty + m, tx + n, N)]);  \n        tmp[0] = alpha * accum[m][n] + beta * tmp[0];  \n        tmp[1] = alpha * accum[m][n + 1] + beta * tmp[1];  \n        tmp[2] = alpha * accum[m][n + 2] + beta * tmp[2];  \n        tmp[3] = alpha * accum[m][n + 3] + beta * tmp[3];  \n        FETCH_FLOAT4(C[OFFSET(ty + m, tx + n, N)]) = FETCH_FLOAT4(tmp);  \n    &#125;  \n&#125;\n</code></pre>\n<p>性能对比如下：</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-float4.png\" alt=\"float4 kernel\" /></p>\n<p>可以看到，使用  <code>float4</code>  访存之后性能得到了很大的提升。每个线程的计算量并没有改变，但是现在每次可以读取 4 个浮点数，全局内存访问次数进一步降低了四分之一。而且指令的执行效率也提升。相比于访存 4 次获取 4 个浮点数，通过  <code>float4</code>  向量内存指令所需的访存指令数更少，减少了对内存访问的竞争；另一方面，使用矢量加载每个字节需要的索引计算更少。这些是隐形的对性能的提升。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/float4-kernel-warp-state.png\" alt=\"float4 kernel warp state\" /></p>\n<p>从 profiling 结果可以看到，通过使用  <code>float4</code>  访存基本上消除了  <code>MIO</code>  的延迟。图中的其他指标的延迟也在 1~1.5 cycles per instruction 之间。</p>\n<h3 id=\"数据预取\"><a class=\"anchor\" href=\"#数据预取\">#</a> 数据预取</h3>\n<p>在上文的代码中，我们在循环中使用了两次  <code>__syncthreads()</code>  来做线程同步，以防止不同线程之间的数据不一致。其中第一个  <code>__syncthreads()</code>  是为了保证写后读（Read-After-Write）的顺序性，这个是无法避免的。</p>\n<p>关键在于后一个同步，它是为了防止部分线程还未读取  <code>As</code>  或者  <code>Bs</code>  中的内容，保证读后写（Write-After-Read）的顺序性。它本质上是因为我们在不同迭代中使用了同一块空间来保存我们所需的数据，这两次迭代中的数据之间并不存在真正的依赖关系。如果我们将其写入到其他地址上，那么就不需要使用同步了。</p>\n<p>这种方式称为数据预取，又可以称为双缓存（Double Buffering）。我们可以申请两倍所需的空间，用于在迭代中交替使用，从而省去后一次线程同步的操作。</p>\n<pre><code class=\"language-c\">__shared__ float As[2][BK][BM];    // transpose shared A for avoid bank conflict, for double buffering  \n__shared__ float Bs[2][BK][BN];    // for double buffering\n\nfloat As_cache[2][TM] = &#123;0.&#125;;  // double buffering  \nfloat Bs_cache[2][TN] = &#123;0.&#125;;  // double buffering\n</code></pre>\n<p>在迭代中，我们可以使用一个变量来控制写入的地址：</p>\n<pre><code class=\"language-c\">int write_idx = 0;\n\nfor (int k = 0; k &lt; K; k += BK) &#123;  \n    for (int i = 0; i &lt; BM; i += a_tile_stride) &#123;  \n        int cache_idx = i / a_tile_stride * 4;  \n        FETCH_FLOAT4(load_a_cache[cache_idx]) =  \n                FETCH_FLOAT4(A[OFFSET(a_tile_row + i, a_tile_col, K)]);  \n        // Use load_a_cache for load 4 float at a time  \n        // As is saved as transpose matrix  \n        As[write_idx][a_tile_col][a_tile_row + i] = load_a_cache[cache_idx];  \n        As[write_idx][a_tile_col + 1][a_tile_row + i] = load_a_cache[cache_idx + 1];  \n        As[write_idx][a_tile_col + 2][a_tile_row + i] = load_a_cache[cache_idx + 2];  \n        As[write_idx][a_tile_col + 3][a_tile_row + i] = load_a_cache[cache_idx + 3];  \n    &#125;\n    ...\n    \n    for (int i = 0; i &lt; BK; i += b_tile_stride) &#123;  \n    FETCH_FLOAT4(Bs[write_idx][b_tile_row + i][b_tile_col]) =  \n            FETCH_FLOAT4(B[OFFSET(b_tile_row + i, b_tile_col, N)]);  \n    &#125;  \n    __syncthreads();\n    \n    ...\n    \n    for (int i = 0; i &lt; BK; ++i) &#123;  \n        for (int m = 0; m &lt; TM; m += 4) &#123;  \n            FETCH_FLOAT4(As_cache[write_idx][m]) = FETCH_FLOAT4(As[write_idx][i][ty + m]);  \n        &#125;  \n        for (int n = 0; n &lt; TN; n += 4) &#123;  \n            FETCH_FLOAT4(Bs_cache[write_idx][n]) = FETCH_FLOAT4(Bs[write_idx][i][tx + n]);  \n        &#125;  \n        for (int m = 0; m &lt; TM; ++m) &#123;  \n            for (int n = 0; n &lt; TN; ++n) &#123;  \n                accum[m][n] += As_cache[write_idx][m] * Bs_cache[write_idx][n];  \n            &#125;  \n        &#125;  \n    &#125;  \n    \n    ...\n    \n    write_idx ^= 1;\n&#125;\n</code></pre>\n<p>性能对比如下：</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-double-buffer.png\" alt=\"double buffer kernel\" /></p>\n<p>使用双缓冲之后，因为避免了多一次的线程同步，性能得到了进一步提升。</p>\n<h3 id=\"避免-shared-memory-bank-conflict\"><a class=\"anchor\" href=\"#避免-shared-memory-bank-conflict\">#</a> 避免 Shared Memory Bank Conflict</h3>\n<p>经过以上的优化，我们的性能已经非常接近 cuBLAS 的基线了。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/shared-memory-bank-conflict.png\" alt=\"shared memory bank conflict\" /></p>\n<p>但是通过 profiling 可以看到，对共享内存的访问上有 40% 的 Uncoalsced Memory Access。这说明共享内存的访问上存在许多 bank conflict。我们可以使用这篇<a href=\"https://zhuanlan.zhihu.com/p/518857175\">矩阵优化笔记</a> 中的思路来解决这一问题。</p>\n<p>我们在通过 Tile 计算的过程中，计算的都是矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 中的连续区域的值，我们可以通过 interleaved 的方式，进一步对其分块<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>：</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/tile-to-avoid-shared-memory-bank-conflict.png\" alt=\"避免 shared memory bank conflict\" /></p>\n<p>对应到代码中，我们从  <code>As</code>  和  <code>Bs</code>  中读取数据时，不再是连续的一整块数据，而是以 4 为单位间隔读取：</p>\n<pre><code class=\"language-c\">for (int k = 0; k &lt; BK; ++k) &#123;  \n    for (int m = 0, mm = 0; m &lt; BM &amp;&amp; mm &lt; TM; m += block_row_thread * 4, mm += 4) &#123;  \n        int A_row = m + threadIdx.y * 4;  \n        FETCH_FLOAT4(As_cache[write_idx][mm]) = FETCH_FLOAT4(As[write_idx][k][A_row]);  \n    &#125;  \n    for (int n = 0, nn = 0; n &lt; BN &amp;&amp; nn &lt; TN; n += block_col_thread * 4, nn += 4) &#123;  \n        int B_col = n + threadIdx.x * 4;  \n        FETCH_FLOAT4(Bs_cache[write_idx][nn]) = FETCH_FLOAT4(Bs[write_idx][k][B_col]);  \n    &#125;\n    ...\n&#125;\n</code></pre>\n<p>而在写回结果时也要注意对矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 的下标计算：</p>\n<pre><code class=\"language-c\">for (int m = 0; m &lt; TM; m += 4) &#123;  \n    int C_row = (m / 4) * (block_row_thread * 4) + threadIdx.y * 4;  \n    for (int n = 0; n &lt; TN; n += 4) &#123;  \n        int C_col = (n / 4) * (block_col_thread * 4) + threadIdx.x * 4;  \n        for (int i = 0; i &lt; 4; ++i) &#123;  \n            FETCH_FLOAT4(load_a_cache) = FETCH_FLOAT4(C[OFFSET(C_row + i, C_col, N)]);  \n            load_a_cache[0] = alpha * accum[m + i][n] + beta * load_a_cache[0];  \n            load_a_cache[1] = alpha * accum[m + i][n + 1] + beta * load_a_cache[1];  \n            load_a_cache[2] = alpha * accum[m + i][n + 2] + beta * load_a_cache[2];  \n            load_a_cache[3] = alpha * accum[m + i][n + 3] + beta * load_a_cache[3];  \n            FETCH_FLOAT4(C[OFFSET(C_row + i, C_col, N)]) = FETCH_FLOAT4(load_a_cache);  \n        &#125;  \n    &#125;  \n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/split-tile-1d-kernel.png\" alt=\"access pattern to avoid shared memory bank conflict\" /></p>\n<p><code>m</code>  和  <code>n</code>  除以 4 是因为读取时以 4 个浮点数为一组读取，这 4 个浮点数对应的行是相邻的，每 4 行之后，就需要跳跃到下一个对应的位置，乘以  <code>(block_row_thread * 4)</code>  和  <code>(block_col_thread * 4)</code>  即是为此。</p>\n<p>在行和列上分别有  <code>block_row_thread</code>  和  <code>block_col_thread</code>  个线程，那么当前线程下一次操作的数据的行和列的起始位置就是  <code>(m / 4) * (block_row_thread * 4)</code>  和  <code>(n / 4) * (block_col_thread * 4)</code> 。</p>\n<p>最后，再添加当前线程自己在行和列上的偏移  <code>threadIdx.y * 4</code>  和  <code>threadIdx.x * 4</code> 。</p>\n<p>对于  <code>n</code>  可以使用  <code>float4</code>  的方式读取和写入，而对于  <code>m</code> ，我们需要再使用一层循环写入相邻的行中。</p>\n<p><img loading=\"lazy\" data-src=\"/images/cuda/SGEMM-optimization/kernel-performance/kernel-share-bank.png\" alt=\"kernel avoid shared memory bank conflict\" /></p>\n<p>可以看到，在大矩阵上，现在的性能基本和 cuBLAS 持平了。我们也基本实现了我们的性能优化目标。</p>\n<h3 id=\"寄存器-bank-冲突\"><a class=\"anchor\" href=\"#寄存器-bank-冲突\">#</a> 寄存器 bank 冲突</h3>\n<p>在处理共享内存 bank 冲突的基础之上，其实还能够进一步考虑处理寄存器的 bank 冲突<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup><sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>。不过这部分内容过于复杂，需要使用到  <code>SASS</code>  的 CUDA 汇编代码。这里就不去具体实现了，仅在这里记录一下。</p>\n<h2 id=\"性能对比总结\"><a class=\"anchor\" href=\"#性能对比总结\">#</a> 性能对比总结</h2>\n<p>这里以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4096</mn><mo>×</mo><mn>4096</mn></mrow><annotation encoding=\"application/x-tex\">4096\\times 4096</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4096</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4096</span></span></span></span> 大小矩阵的性能总结各个优化和 cuBLAS 库的性能比较。</p>\n<table>\n<thead>\n<tr>\n<th>Kernel</th>\n<th>Ratio to cuBLAS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cublas</td>\n<td>1</td>\n</tr>\n<tr>\n<td>naive</td>\n<td>0.106</td>\n</tr>\n<tr>\n<td>shared memory</td>\n<td>0.091</td>\n</tr>\n<tr>\n<td>tile 1d</td>\n<td>0.158</td>\n</tr>\n<tr>\n<td>tile 2d</td>\n<td>0.352</td>\n</tr>\n<tr>\n<td>float4</td>\n<td>0.857</td>\n</tr>\n<tr>\n<td>double buffering</td>\n<td>0.912</td>\n</tr>\n<tr>\n<td>avoid shared memory bank conflict</td>\n<td>0.995</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这次国庆假期前前后后断断续续花费了 5 天完成了这篇优化笔记。前两天几乎全部花在代码编写上，后面三天断断续续完成了文章的内容。为了完成这篇内容，这期间参考了许多的笔记和资料<sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup><sup class=\"footnote-ref\"><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup><sup class=\"footnote-ref\"><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup>，最后总算也得到了一个很好的优化结果。之前一直都是单纯的资料阅读，这次的实践确实收获颇丰，自己动手编写代码和直接调用别人的接口感觉确实有很大不同。CUDA 编程也需要了解更多的硬件相关的知识，这次实践中也了解了不少。“纸上得来终觉浅，绝知此事要躬行”。后续可能进一步考虑学习其他深度学习的重要算子的优化。</p>\n<p>本次的代码放在我的<a href=\"https://github.com/YangLinzhuo/cuda-sgemm-optimization/tree/main\">仓库</a>上了，可供参考。</p>\n<p>以上。</p>\n<h2 id=\"change-log\"><a class=\"anchor\" href=\"#change-log\">#</a> Change Log</h2>\n<ul>\n<li>2023-10-14：补充 Nsight Compute profiling 结果，修正部分文本错误和措辞</li>\n<li>2023-10-15：重绘一些插图</li>\n</ul>\n<h2 id=\"附录\"><a class=\"anchor\" href=\"#附录\">#</a> 附录</h2>\n<h3 id=\"clion-cuda-编程配置\"><a class=\"anchor\" href=\"#clion-cuda-编程配置\">#</a> CLion CUDA 编程配置</h3>\n<p>使用 CLion 创建 CUDA 工程， <code>CMakeLists.txt</code>  内容如下：</p>\n<pre><code class=\"language-cmake\">cmake_minimum_required(VERSION 3.22)\nproject(sgemm LANGUAGES CXX CUDA)\n\nset(CMAKE_CUDA_STANDARD 20)\nset(CMAKE_CUDA_FLAGS &quot;-O3&quot;)\n# For debug\n# set(CMAKE_CUDA_FLAGS &quot;-g -G&quot;)\n# For Nsight Compute Profiling\n# set (CMAKE_CUDA_FLAGS &quot;$&#123;CMAKE_CUDA_FLAGS&#125; -lineinfo&quot;)\n\nfind_package(CUDAToolkit REQUIRED)\n\nadd_executable($&#123;PROJECT_NAME&#125; main.cu\n        src/utils.cu\n        src/kernels.cu)\n\n# 可执行文件输出路径\n# https://gist.github.com/gavinb/c993f71cf33d2354515c4452a3f8ef30\nset(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;)\n\nset_target_properties($&#123;PROJECT_NAME&#125; PROPERTIES\n        CUDA_SEPARABLE_COMPILATION ON)\n# 查询 compute capability https://developer.nvidia.com/cuda-gpus\nset_target_properties($&#123;PROJECT_NAME&#125; PROPERTIES CUDA_ARCHITECTURES &quot;86&quot;)\n\n# 配置头文件搜索路径\n# 配置 CUDA 相关库头文件\n# 参考\n# https://stackoverflow.com/questions/51756562/obtaining-the-cuda-include-dir-in-c-targets-with-native-cuda-support-cmake\ntarget_include_directories($&#123;PROJECT_NAME&#125; PRIVATE $&#123;CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES&#125;)\ntarget_include_directories($&#123;PROJECT_NAME&#125; PUBLIC $&#123;PROJECT_SOURCE_DIR&#125;/src)\n\n# link cudart cublas\ntarget_link_libraries($&#123;PROJECT_NAME&#125; PRIVATE CUDA::cublas)\n</code></pre>\n<p>此外，需要在  <code>Settings -&gt; Build,Execution,Deployment -&gt; CMake</code>  中的  <code>CMake options</code>  中添加以下参数：</p>\n<pre><code class=\"language-txt\">-DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc\n</code></pre>\n<h3 id=\"cublas-库接口调用\"><a class=\"anchor\" href=\"#cublas-库接口调用\">#</a> cuBLAS 库接口调用</h3>\n<p>使用  <code>cuBLAS</code>  的矩阵乘法接口  <code>cublasSgemm</code>  函数时，需要注意其参数传递<sup class=\"footnote-ref\"><a href=\"#fn8\" id=\"fnref8\">[8]</a></sup>。</p>\n<p>具体的封装参考如下：</p>\n<pre><code class=\"language-c\">void test_cublas(cublasHandle_t handle, int M, int N, int K,\n                 float alpha, float *A, float *B, float beta, float *C) &#123;\n    //cublas列主序计算：https://www.cnblogs.com/cuancuancuanhao/p/7763256.html\n    cublasSgemm(handle, CUBLAS_OP_N, CUBLAS_OP_N, N, M, K, &amp;alpha, B, N, A, K, &amp;beta, C, N);\n&#125;\n</code></pre>\n<h3 id=\"cuda-程序性能-profiling\"><a class=\"anchor\" href=\"#cuda-程序性能-profiling\">#</a> CUDA 程序性能 Profiling</h3>\n<p>CUDA 性能 profiling 可以去官网<sup class=\"footnote-ref\"><a href=\"#fn9\" id=\"fnref9\">[9]</a></sup>下载 Nsight Compute 和 Nsight System 工具。其中 System 用于粗粒度的性能分析，Compute 用于对核函数的细粒度性能分析。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>实际上，对于非 4 的倍数的元素个数，也是可以使用  <code>float4</code>  来访存的，但是在边界条件判断上需要更细致的处理，对性能也会有一定的影响。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>图片来自于这篇知乎的<a href=\"https://zhuanlan.zhihu.com/p/518857175\">矩阵优化笔记</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"http://zh0ngtian.tech/posts/96744e8c.html\">CUDA 知识点：bank 冲突 | CUDA - zhongtian's blog (zh0ngtian.tech)</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"https://zhuanlan.zhihu.com/p/481600052\">深入浅出 GPU 优化系列：GEMM 优化（三） - 知乎 (zhihu.com)</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p><a href=\"https://zhuanlan.zhihu.com/p/518857175\">CUDA SGEMM 矩阵乘法优化笔记 —— 从入门到 cublas - 知乎 (zhihu.com)</a> <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn6\" class=\"footnote-item\"><p><a href=\"https://github.com/wangzyon/NVIDIA_SGEMM_PRACTICE\">wangzyon/NVIDIA_SGEMM_PRACTICE: Step-by-step optimization of CUDA SGEMM (github.com)</a> <a href=\"#fnref6\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn7\" class=\"footnote-item\"><p><a href=\"https://siboehm.com/articles/22/CUDA-MMM\">How to Optimize a CUDA Matmul Kernel for cuBLAS-like Performance: a Worklog (siboehm.com)</a> <a href=\"#fnref7\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn8\" class=\"footnote-item\"><p><a href=\"https://www.cnblogs.com/cuancuancuanhao/p/7763256.html\">有关 CUBLAS 中的矩阵乘法函数 - 爨爨爨好 - 博客园 (cnblogs.com)</a> <a href=\"#fnref8\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn9\" class=\"footnote-item\"><p><a href=\"https://developer.nvidia.com/gameworksdownload#?dn=nsight-systems-2023-3\">Gameworks Download Center | NVIDIA Developer</a> <a href=\"#fnref9\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Algorithm",
                "CUDA"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Python/python-type-annotations-and-custom-types/",
            "url": "https://linn-ylz.com/Computer-Science/Python/python-type-annotations-and-custom-types/",
            "title": "Python 类型注释及自定义类型",
            "date_published": "2023-06-22T02:39:47.000Z",
            "content_html": "<p><code>Python</code>  以其动态特性而受到许多开发者的欢迎。但是当工程项目变得越来越复杂的时候，这一特性又往往会使得开发者头疼不已。想一想，当看着一段代码，却无法确定其中变量的特定类型，无法下手编写代码。即便强行编写完成也只能在运行时检查是否出错，这无疑会对开发效率产生很大影响。</p>\n<h2 id=\"类型系统\"><a class=\"anchor\" href=\"#类型系统\">#</a> 类型系统</h2>\n<p>按照一般的分类形式， <code>Python</code>  属于动态的强类型系统的编程语言。此外， <code>Python</code>  还支持 Duck Typing 这一特性。</p>\n<p>所谓的 Duck Typing，即：</p>\n<blockquote>\n<p>If it walks like a duck and it quacks like a duck, then it must be a duck.</p>\n</blockquote>\n<p>翻译成计算机语言，就是，加入某个变量支持 A 类型的所有操作，那么我们就可以将其视为 A 类型的变量。我们可以看这样一段代码：</p>\n<pre><code class=\"language-python\">from typing import Iterable  \ndef print_items(items: Iterable):  \n    for item in items:  \n        print(item)  \n\nprint_items([1,2,3])  \nprint_items(&#123;4, 5, 6&#125;)  \nprint_items(&#123;&quot;A&quot;: 1, &quot;B&quot;: 2, &quot;C&quot;: 3&#125;)\n</code></pre>\n<p>上述的  <code>print_items</code>  函数，只要输入的  <code>items</code>  支持  <code>__iter__</code>  操作，就能够成功调用该函数。即只要支持了  <code>__iter__</code>  操作，我们就可以将  <code>items</code>  视为  <code>Iterable</code>  类型的变量。这里按照语法  <code>&lt;var&gt;: &lt;type&gt;</code>  标注的  <code>Iterable</code>  类型即  <code>Python</code>  中的一种类型注释，用于帮助开发者更方便地理解代码，并且可以通过静态类型检查工具来检查潜在的类型错误。具体细节将在本文后续内容中介绍。</p>\n<p>虽然 Duck Typing 的特性非常便利，但是它是一把双刃剑：</p>\n<ul>\n<li>Duck Typing 可以增加代码的健壮性，可以通过构建抽象类接口来支持多种类型变量的调用，不需要针对某个类型编写特定代码。</li>\n<li>但是如果滥用 Duck Typing，某些时候可能会使开发者迷惑，因为支持的某些操作可能并不符合直觉。</li>\n</ul>\n<h2 id=\"类型注释\"><a class=\"anchor\" href=\"#类型注释\">#</a> 类型注释</h2>\n<p><code>Python</code>  的动态类型在编写小规模代码时非常方便，但是当代码规模变大后，就很难知晓某段复杂代码中变量的类型，只有在运行时才能够知道其类型。对于这点， <code>Python</code>  之父 Guido van Rossum 曾经说过：</p>\n<blockquote>\n<p>I’ve learned a painful lesson that for small programs dynamic typing is great. For large programs you have to have a more disciplined approach and it helps if the language actually gives you that discipline, rather than telling you &quot;Well, you can do whatever you want.&quot;</p>\n</blockquote>\n<p>为了帮助解决这一困扰许多开发者的问题， <code>Python</code>  从 3.7 开始提供了较为完备的类型支持系统。</p>\n<p><code>Python</code>  的类型注释（Type Annotations），是一种类型提示（Type Hints），用于提示开发者某种变量的具体类型。其语法如下：</p>\n<pre><code class=\"language-python\">def find_workers_available_for_time(open_time: datetime.datetime) -&gt; list[str]:\n</code></pre>\n<p>对于通常的变量定义，也可以添加类型注释：</p>\n<pre><code class=\"language-python\">number: int = 0  \ntext: str = &quot;useless&quot;  \nvalues: list[float] = [1.2, 3.4, 6.0]  \nworker: Worker = Worker()\n</code></pre>\n<p>在  <code>Python 3.8</code>  之前，上述代码可能会报错，需要在代码开头添加  <code>from __future__ import anntations</code>  语句。如果是更老版本的  <code>Python</code> ，可以通过以下方式添加类型注释：</p>\n<pre><code class=\"language-python\">ratio = get_ratio(5,3) # type: float  \ndef get_workers(open): # type: (datetime.datetime) -&gt; List[str]\n</code></pre>\n<p>但是这种方式过于繁琐，可读性也不强，推荐使用较新版本的  <code>Python</code> 。</p>\n<p>许多人可能担心这些额外的代码会影响运行性能，但其实不必在意，因为这些代码并不会实际运行。</p>\n<p>除了提示开发者变量的代码类型之外，类型注释还能够帮助 IDE 提供自动补全功能。还可以此借助  <code>mypy</code>  等 Typechecker 来帮助检查代码的正确性。</p>\n<p>虽然类型注释有很多好处，但是我们也不需要处处使用。对于简单的代码，过多的类型注释反而会影响对实际代码的阅读。</p>\n<h2 id=\"复杂类型\"><a class=\"anchor\" href=\"#复杂类型\">#</a> 复杂类型</h2>\n<p>在上一节中的类型注释，都是由  <code>Python</code>  中的基础类型构成的。本节介绍一些其他类型以构建更复杂的类型注释。</p>\n<h3 id=\"optional\"><a class=\"anchor\" href=\"#optional\">#</a>  <code>Optional</code></h3>\n<p><code>Python</code>  中的变量可以动态绑定，都可以赋值为  <code>None</code> 。为了能够在类型中表示这一点，可以使用  <code>Optional</code>  这一类型。</p>\n<pre><code class=\"language-python\">from typing import Optional  \nmaybe_a_string: Optional[str] = &quot;abcdef&quot; # This has a value  \nmaybe_a_string: Optional[str] = None # This is the absence of a value\n</code></pre>\n<p><code>Optional</code>  能够提示这一变量有可能是  <code>None</code>  类型。能够帮助区分空值和  <code>None</code> 。</p>\n<h3 id=\"union\"><a class=\"anchor\" href=\"#union\">#</a>  <code>Union</code></h3>\n<p><code>Union</code>  用于表示一系列独立类型的并集。例如， <code>Union[int, str]</code>  表示某个变量可能是  <code>int</code>  或  <code>str</code>  中的一种。此外， <code>Union[int, None]</code>  和  <code>Optional[int]</code>  在表示上是等价的。</p>\n<h3 id=\"literal\"><a class=\"anchor\" href=\"#literal\">#</a>  <code>Literal</code></h3>\n<p><code>Literal</code>  类型可以限制某些类型的取值范围。</p>\n<pre><code class=\"language-python\">from typing import Literal  \n@dataclass  \nclass Error:  \n    error_code: Literal[1,2,3,4,5]  \n    disposed_of: bool  \n\n@dataclass  \nclass Snack:  \n    name: Literal[&quot;Pretzel&quot;, &quot;Hot Dog&quot;, &quot;Veggie Burger&quot;]  \n    condiments: set[Literal[&quot;Mustard&quot;, &quot;Ketchup&quot;]]\n</code></pre>\n<div class=\"note info\">\n<p><code>Literal</code>  在 Python 3.8 引入。They are a little more lightweight than Python enumerations. 比枚举略轻量。</p>\n</div>\n<h3 id=\"annotated\"><a class=\"anchor\" href=\"#annotated\">#</a>  <code>Annotated</code></h3>\n<p><code>Literal</code>  仅能够限定某些基本的类型，提供基本限制。无法提供像 “特定长度的字符串”，“匹配特定正则表达式的字符串” 等类型限制。</p>\n<p>在这些情形下，可以使用  <code>Annotated</code>  类型实现。</p>\n<pre><code class=\"language-python\">x: Annotated[int, ValueRange(3,5)]  \ny: Annotated[str, MatchesRegex('[0-9]&#123;4&#125;')]\n</code></pre>\n<p>不过，Typechecker 无法帮助我们检查这一类型的错误，因为类型过于复杂，无法通过静态分析得到结果。因此，我们仍然需要自行在代码中对输入做检查。这样能够使得变量类型取值范围更加明晰，使代码更清晰。</p>\n<h3 id=\"newtype\"><a class=\"anchor\" href=\"#newtype\">#</a>  <code>NewType</code></h3>\n<p><code>NewType</code>  能够帮助提供更复杂的类型表达。 <code>NewType</code>  会基于已有类型创建一个新的类型，并拥有和已有类型相同的 fields 和 methods。尽管如此，这个新创建的类型和原类型是无法互换的。</p>\n<p>可以看以下的例子：</p>\n<pre><code class=\"language-python\">from typing import NewType  \n\nclass HotDog:  \n    ''' Used to represent an unservable hot dog'''  \n    # ... snip hot dog class implementation ...  \n\nReadyToServeHotDog = NewType(&quot;ReadyToServeHotDog&quot;, HotDog)  \n\ndef dispense_to_customer(hot_dog: ReadyToServeHotDog):  \n    # ...\n</code></pre>\n<p>代码中  <code>ReadyToServeHotDog</code>  和  <code>HotDog</code>  是不等价的。在要求了  <code>ReadyToServeHotDog</code>  的时候，传递  <code>HotDog</code>  是不可行的，但是反过来是可以的。</p>\n<p>与此同时，我们需要提供一个类型转换方式，否则开发者不知道该如何得到这一新类型的对象。</p>\n<pre><code class=\"language-python\">def prepare_for_serving(hot_dog: HotDog) -&gt; ReadyToServeHotDog:  \n    assert not hot_dog.is_plated(), &quot;Hot dog should not already be plated&quot;  \n    hot_dog.put_on_plate()  \n    hot_dog.add_napkins()  \n    return ReadyToServeHotDog(hot_dog)\n\ndef make_snack():  \n    serve_to_customer(ReadyToServeHotDog(HotDog()))\n</code></pre>\n<p>这样一来，所有的  <code>ReadyToServeHotDog</code>  在创建时都会检查是否满足了特定的条件，保证了我们调用函数的正确性。这种函数称为 blessed function。我们需要告诉开发者，在任何时候，只能使用这些 blessed function 来创建我们构造的新类型。不过目前只有使用注释这种方法，暂时没有其他有效手段能够显式提醒开发者。</p>\n<p>实际上，我们可以通过创造新的  <code>class</code>  来实现类似的效果，也能够提供更有效地防止非法值类型的传入。但是相对而言， <code>NewType</code>  的实现更加轻量。</p>\n<p>需要注意， <code>NewType</code>  和类型别名不是一回事。类型别名和原类型是完全等价的，在任意时刻，语义上可以等价互换。但是  <code>NewType</code>  不是。</p>\n<p>例如  <code>IdOrName = Union[str, int]</code> ， <code>IdOrName</code>  和  <code>Union[str, int]</code>  类型是等价的。类型别名在表示某些复杂嵌套类型的时候比较直观，比如  <code>IDOrNameLookup</code>  显然比  <code>Union[dict[int, User], list[dict[str, User]]]</code>  更直观。</p>\n<h3 id=\"final\"><a class=\"anchor\" href=\"#final\">#</a>  <code>Final</code></h3>\n<p><code>Final</code>  类型在 Python 3.8 中引入，该类型的值在赋值之后就无法再绑定到其他内容上。</p>\n<p>例如，我们定义的品牌的名称，不会轻易修改：</p>\n<pre><code class=\"language-python\">VENDOR_NAME: Final[str] = &quot;Viafore's Auto-Dog&quot;\n</code></pre>\n<p>如果开发者后续错误地尝试修改其内容，Typechecker 会报错：</p>\n<pre><code class=\"language-python\">def display_vendor_information():  \n    vendor_info = &quot;Auto-Dog v1.0&quot;  \n    # whoops, copy-paste error, this code should be vendor_info += VENDOR_NAME  \n    VENDOR_NAME += VENDOR_NAME  \n    print(vendor_info)\n</code></pre>\n<p>但是需要注意， <code>Final</code>  和  <code>C++</code>  中的  <code>const</code>  类型是不同的，因为 Python 并不限制通过函数修改对象的内容，它仅仅限制了将某个变量绑定到其他对象上。</p>\n<h2 id=\"容器类型\"><a class=\"anchor\" href=\"#容器类型\">#</a> 容器类型</h2>\n<p>除了对一般的  <code>int</code>  等基础类型之外， <code>Python</code>  中还常用  <code>list</code> 、 <code>dict</code> 、 <code>set</code>  等容器类型。相比于单个值类型的变量，其类型注释要更加复杂。</p>\n<p>看以下例子：</p>\n<pre><code class=\"language-python\">def create_author_count_mapping(cookbooks: list) -&gt; dict:  \n    counter = defaultdict(lambda: 0)  \n    for book in cookbooks:  \n        counter[book.author] += 1  \n    return counter\n</code></pre>\n<p>尽管我们知道输入是一个  <code>list</code> ，输出是一个  <code>dict</code> ，但是我们仍然不清楚其中对象的具体类型。</p>\n<p>我们可以为容器中的对象添加类型说明：</p>\n<pre><code class=\"language-python\">AuthorToCountMapping = dict[str, int] \n\ndef create_author_count_mapping(cookbooks: list[Cookbook]) -&gt; AuthorToCountMapping:  \n    counter = defaultdict(lambda: 0)  \n    for book in cookbooks:  \n        counter[book.author] += 1  \n    return counter\n</code></pre>\n<p>这里，使用类型别名表示返回值的类型，在此处的上下文语境中能更加清楚地表明代码的意图。</p>\n<h3 id=\"同构数据-vs-异构数据\"><a class=\"anchor\" href=\"#同构数据-vs-异构数据\">#</a> 同构数据 vs. 异构数据</h3>\n<p>在表示容器中的对象类型时，我们经常会遇到一个问题：如果容器中的对象类型并不总是一致的，我们该如何表示其类型？</p>\n<p>我们可以将容器分为 homogeneous collections（同构容器） 和 heterogeneous collections（异构容器） 两种类型，按其中元素类型是否一致来区分。</p>\n<p>在一般情况下，我们应当尽量使用同构容器，因为异构容器经常需要我们处理 special case，这很容易出错。同构容器不一定说明其中的元素是同一种原生类型等情形，只要我们能够对其使用完全相同的操作，那么就可以认定这些元素是同构的。</p>\n<p>对于异构容器，我们可以使用  <code>Union</code>  表示其中的元素类型：</p>\n<pre><code class=\"language-python\">Ingredient = tuple[str, int, str] # (name, quantity, units)  \nRecipe = list[Union[int, Ingredient]] # the list can be servings or ingredients  \ndef adjust_recipe(recipe: Recipe, servings):  \n# ...\n</code></pre>\n<p>如果异构容器中的类型过于复杂，我们很可能需要添加很多的类型检验代码。这时，使用一个自定义的  <code>class</code>  类型可能更加合适。</p>\n<p>如果容器中的元素类型过多，我们还可以用  <code>Any</code>  表示任意一种类型。这样，任意一种类型都是合法的。只是这样就无法再提供任何有效的参考信息。</p>\n<p>不过，对于  <code>tuple</code> ，其中的元素类型经常是异构的。</p>\n<pre><code class=\"language-python\">Cookbook = tuple[str, int] # name, page count\n</code></pre>\n<p>当然，这样的代码很容易变得难懂。因为我们需要比照每个索引对应的元素内容的含义。我们可以用  <code>dict</code>  来替换：</p>\n<pre><code class=\"language-python\">food_lab = &#123;  \n    &quot;name&quot;: &quot;The Food Lab&quot;,  \n    &quot;page_count&quot;: 958  \n&#125;\n</code></pre>\n<p>但是如此一来， <code>dict</code>  中的键值会映射到不同的类型上。我们需要用  <code>dict[str, Union[int, str]]</code>  来表示该  <code>dict</code>  的类型。</p>\n<p>对于这种复杂类型的字典，推荐用  <code>TypedDict</code> 。</p>\n<h3 id=\"typeddict\"><a class=\"anchor\" href=\"#typeddict\">#</a>  <code>TypedDict</code></h3>\n<p><code>TypedDict</code>  在 Python 3.8 中引入。用于必须在字典中存储异构类型数据的情形。</p>\n<p>对于  <code>Json</code>   <code>YAML</code>  等文件解析得到的  <code>dict</code> ，其中的数据通常都是异构的。如果我们控制了  <code>dict</code>  的创建，那么我们可以使用  <code>dataclass</code>  或者  <code>class</code>  来管理这些数据。对于解析文件得到的内容，我们仍需要通过查看文档等方法来确认。</p>\n<p>我们可以用  <code>TypedDict</code>  来解决这一问题。</p>\n<pre><code class=\"language-python\">from typing import TypedDict  \nclass Range(TypedDict):  \n    min: float  \n    max: float\n\nclass NutritionInformation(TypedDict):  \n    value: int  \n    unit: str  \n    confidenceRange95Percent: Range  \n    standardDeviation: float\n\nclass RecipeNutritionInformation(TypedDict):  \n    recipes_used: int  \n    calories: NutritionInformation  \n    fat: NutritionInformation  \n    protein: NutritionInformation  \n    carbs: NutritionInformation\n\nnutrition_information:RecipeNutritionInformation = \\  \n    get_nutrition_from_spoonacular(recipe_name)\n</code></pre>\n<p>上述代码很清晰的表示了字典中的键值对类型。当字典类型发生了变化时，我们可以通过  <code>mypy</code>  帮助检查。如果我们忘记更新该  <code>TypedDict</code> ， <code>mypy</code>  能够帮助我们找出错误。</p>\n<h3 id=\"构建新的容器类型\"><a class=\"anchor\" href=\"#构建新的容器类型\">#</a> 构建新的容器类型</h3>\n<h4 id=\"generics\"><a class=\"anchor\" href=\"#generics\">#</a>  <code>Generics</code></h4>\n<p>如果确实现有类型无法表达我们想要的内容，我们可以通过  <code>Generics</code>  帮助构建新的容器类型。</p>\n<p>Generic 类型通常表示我们不关心其中的具体类型，但是它能够帮助我们限制用户使用不正确的类型。</p>\n<pre><code class=\"language-python\">def reverse(coll: list) -&gt; list:  \n    return coll[::-1]\n</code></pre>\n<p>对于  <code>reverse</code>  函数，我们不关系其中的具体类型，但是我们知道返回的列表和传入的列表的值类型是相同的。我们可以这样表示：</p>\n<pre><code class=\"language-python\">from typing import TypeVar  \nT = TypeVar('T')  \ndef reverse(coll: list[T]) -&gt; list[T]:  \n    return coll[::-1]\n</code></pre>\n<p>这样，一个  <code>int</code>  类型的  <code>list</code>  就绝不会产生一个  <code>str</code>  类型的  <code>list</code>  的了。</p>\n<p>基于此方式，我们可以表达更复杂的类型：</p>\n<pre><code class=\"language-python\">from collections import defaultdict  \nfrom typing import Generic, TypeVar\n\nNode = TypeVar(&quot;Node&quot;)  \nEdge = TypeVar(&quot;Edge&quot;)\n\n# directed graph  \nclass Graph(Generic[Node, Edge]):  \n    def __init__(self):  \n        self.edges: dict[Node, list[Edge]] = defaultdict(list)\n        \n    def add_relation(self, node: Node, to: Edge):  \n        self.edges[node].append(to)\n        \n    def get_relations(self, node: Node) -&gt; list[Edge]:  \n        return self.edges[node]\n</code></pre>\n<p>这样，我们可以使用  <code>Graph</code>  表示更丰富的类型：</p>\n<pre><code class=\"language-python\">cookbooks: Graph[Cookbook, Cookbook] = Graph()  \nrecipes: Graph[Recipe, Recipe] = Graph()  \ncookbook_recipes: Graph[Cookbook, Recipe] = Graph()  \nrecipes.add_relation(Recipe('Pasta Bolognese'),  \n                    Recipe('Pasta with Sausage and Basil'))  \ncookbook_recipes.add_relation(Cookbook('The Food Lab'),  \n                            Recipe('Pasta Bolognese'))\n</code></pre>\n<p><code>Generic</code>  能够让我们复用更多的代码，减少错误的出现。</p>\n<p><code>Generic</code>  的其他用途：</p>\n<pre><code class=\"language-python\">def get_nutrition_info(recipe: str) -&gt; Union[NutritionInfo, APIError]:  \n# ...  \ndef get_ingredients(recipe: str) -&gt; Union[list[Ingredient], APIError]:  \n#...  \ndef get_restaurants_serving(recipe: str) -&gt; Union[list[Restaurant], APIError]:  \n# ...\n</code></pre>\n<p>显然，上述方式需要我们在每个返回值中都添加一个  <code>APIError</code>  类型，非常繁琐。我们可以这样改写：</p>\n<pre><code class=\"language-python\">T = TypeVar(&quot;T&quot;)  \nAPIResponse = Union[T, APIError]  \ndef get_nutrition_info(recipe: str) -&gt; APIResponse[NutritionInfo]:  \n    # ...  \ndef get_ingredients(recipe: str) -&gt; APIResponse[list[Ingredient]]:  \n    #...  \ndef get_restaurants_serving(recipe: str) -&gt; APIResponse[list[Restaurant]]:  \n    # ...\n</code></pre>\n<h3 id=\"修改现有类型\"><a class=\"anchor\" href=\"#修改现有类型\">#</a> 修改现有类型</h3>\n<p>有些时候，我们可以在现有类型的基础上修改，以实现我们想要的效果。假定我们想要让字典支持别名，即不同的  <code>key</code>  能够指向相同的  <code>value</code> 。如果复制多个  <code>value</code>  的话，在修改时容易漏掉其他对应  <code>key</code>  的修改。这时，我们可以通过创建  <code>dict</code>  的子类来实现以上效果。</p>\n<p>以上需求，我们可以创建一个  <code>dict</code>  的子类来实现：</p>\n<pre><code class=\"language-python\">class NutritionalInformation(dict):  \n    def __getitem__(self, key):  \n    try:  \n        return super().__getitem__(key)  \n    except KeyError:  \n        pass  \n    for alias in get_aliases(key):  \n        try:  \n            return super().__getitem__(alias)  \n        except KeyError:  \n            pass  \n    raise KeyError(f&quot;Could not find &#123;key&#125; or any of its aliases&quot;)\n</code></pre>\n<p>但是，以上的代码实现存在问题。当我们继承一个  <code>dict</code>  的时候，我们无法保证内部函数会调用我们覆盖的函数实现。内置类型的许多函数使用内联代码调用来保证性能。如果只是添加额外的方法，那么继承内置类型是可行的。但是在将来，也有可能发生类似的错误，因此最好避免继承内置类型。</p>\n<p>为了解决这一问题，我们可以使用  <code>UserDict</code> ：</p>\n<pre><code class=\"language-python\">from collections import UserDict  \nclass NutritionalInformation(UserDict):  \n    def __getitem__(self, key):  \n        try:  \n            return self.data[key]  \n        except KeyError:  \n            pass  \n        for alias in get_aliases(key):  \n            try:  \n                return self.data[alias]  \n            except KeyError:  \n                pass  \n        raise KeyError(f&quot;Could not find &#123;key&#125; or any of its aliases&quot;)\n</code></pre>\n<p>我们可以使用  <code>self.data</code>  来获取底层的原生  <code>dict</code>  数据。除此之外，还有  <code>UserList</code>  和  <code>UserString</code>  可以帮助我们对  <code>list</code>  和  <code>str</code>  实现类似的代码。不过需要注意，这些  <code>User*</code>  类型可能会带来一定的性能损耗，需要根据实际情况考虑。</p>\n<h3 id=\"抽象类型\"><a class=\"anchor\" href=\"#抽象类型\">#</a> 抽象类型</h3>\n<p>通过定义抽象类，我们可以自定义容器类型。 <code>collection.abc</code>  中提供了许多的抽象基类，我们可以根据需求使用。</p>\n<p>上一节中，我们提到了  <code>UserDict</code>   <code>UserList</code>   <code>UserString</code> ，但是并没有  <code>UserSet</code> 。本节我们基于  <code>abc</code>  来实现。</p>\n<p><code>collections.abc.Set</code>  提供了  <code>set</code>  的抽象基类定义。其中包含以下函数：</p>\n<ul>\n<li><code>__contains__</code> ：检查是否包含某个元素</li>\n<li><code>__iter__</code> ：用于迭代元素</li>\n<li><code>__len__</code> ：返回容器中的元素个数</li>\n</ul>\n<p>只要我们实现了以上三个函数，我们就可以实现一个类似的  <code>set</code> 。</p>\n<pre><code class=\"language-python\">import collections  \nclass AliasedIngredients(collections.abc.Set):  \n    def __init__(self, ingredients: set[str]):  \n        self.ingredients = ingredients  \n        \n    def __contains__(self, value: str):  \n        return value in self.ingredients or any(alias in self.ingredients for alias in get_aliases(value))  \n        \n    def __iter__(self):  \n        return iter(self.ingredients)  \n        \n    def __len__(self):  \n        return len(self.ingredients)\n\n&gt;&gt;&gt; ingredients = AliasedIngredients(&#123;'arugula', 'eggplant', 'pepper'&#125;)  \n&gt;&gt;&gt; for ingredient in ingredients:  \n&gt;&gt;&gt; print(ingredient)  \n'arugula'  \n'eggplant'  \n'pepper'\n\n&gt;&gt;&gt; print(len(ingredients))  \n3  \n&gt;&gt;&gt; print('arugula' in ingredients)  \nTrue  \n&gt;&gt;&gt; print('rocket' in ingredients)  \nTrue  \n&gt;&gt;&gt; list(ingredients | AliasedIngredients(&#123;'garlic'&#125;))  \n['pepper', 'arugula', 'eggplant', 'garlic']\n</code></pre>\n<p>除此之外，我们还可以用  <code>abc</code>  来提供类型注释：</p>\n<pre><code class=\"language-python\">def print_items(items: collections.abc.Iterable):  \n    for item in items:  \n        print(item)\n</code></pre>\n<p>只要对象支持  <code>__iter__</code>  方法，那么就符合这个函数的参数要求。我们可以通过 ABC 来定义更复杂的参数类型。也是 Duck Type 的关键实现。</p>\n<p>Python 3.9 提供了 25 中不同的抽象基类。可以查看<a href=\"https://docs.python.org/3/library/collections.abc.html#module-collections.abc\">文档</a>了解<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://docs.python.org/3/library/collections.abc.html#module-collections.abc\">collections.abc — Abstract Base Classes for Containers — Python 3.11.4 documentation</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Python",
                "Type-Annotation"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Configs/powershell-configs/",
            "url": "https://linn-ylz.com/Computer-Science/Configs/powershell-configs/",
            "title": "Powershell 配置",
            "date_published": "2023-04-01T07:44:34.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>虽然目前  <code>Windows</code>  对  <code>WSL</code>  已经支持很多常规的操作，但是有时候仍然不得不在  <code>Windows</code>  环境下执行某些命令。尤其  <code>WSL</code>  的文件  <code>IO</code>  速率相比于原生  <code>Windows</code>  系统存在一定差距，尤其是  <code>Git</code>  仓库稍微大一点便能明显感受到延迟。此外， <code>WSL</code>  的网络代理有时候也会出现故障， <code>Git</code>  操作很不方便。因此，基于  <code>Powershell</code>  配置一些支持常用操作，能够更方便自己的开发。</p>\n<h2 id=\"升级\"><a class=\"anchor\" href=\"#升级\">#</a> 升级</h2>\n<p>由于需要使用到一些模块，因此需要首先升级系统的  <code>Powershell</code>  ， <code>Windows</code>  官方提供了多种可选方式升级或安装最新的  <code>Powershell</code> ，参见<a href=\"https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.3\">在 Windows 上安装 PowerShell - PowerShell | Microsoft Learn</a>。<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<p>如果网络状况良好，那么推荐直接使用  <code>winget</code>  命令安装。否则也可以下载  <code>msi</code>  安装包安装。</p>\n<h2 id=\"autosuggestion-工具\"><a class=\"anchor\" href=\"#autosuggestion-工具\">#</a> Autosuggestion 工具</h2>\n<p><code>WSL</code>  下可以通过  <code>oh-my-zsh</code>  配置  <code>auto-suggestion</code>  工具，可以在输入命令时显示以往使用的命令。 <code>Powershell</code>  也可以配置类似的工具。<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<p>使用该工具需要安装相关依赖：</p>\n<pre><code class=\"language-powershell\">Install-Module PSReadLine -RequiredVersion 2.1.0\n</code></pre>\n<p>安装完成后，可以使用以下命令启用 Autosuggestion 功能：</p>\n<pre><code class=\"language-powershell\">Import-Module PSReadLine\nSet-PSReadLineOption -PredictionSource History\n</code></pre>\n<p>以上命令只在当前窗口有效。如果需要默认启动，需要编辑配置文件。</p>\n<h3 id=\"编辑-powershell-配置文件\"><a class=\"anchor\" href=\"#编辑-powershell-配置文件\">#</a> 编辑  <code>Powershell</code>  配置文件</h3>\n<p>首先需要检查是否已有配置文件：</p>\n<pre><code class=\"language-powershell\">Test-path $profile\n</code></pre>\n<p>如果结果为  <code>True</code> ，说明已经包含该文件。为  <code>False</code> ，则需要自行生成：</p>\n<pre><code class=\"language-powershell\">New-item –type file –force $profile\n</code></pre>\n<p>执行命令设置执行权限（该命令需要管理员权限）：</p>\n<pre><code class=\"language-powershell\">Set-ExecutionPolicy RemoteSigned\n</code></pre>\n<p>之后编辑该文件：</p>\n<pre><code class=\"language-powershell\">notepad $profile\n</code></pre>\n<p>将语句添加到该配置文件中：</p>\n<pre><code class=\"language-powershell\">Import-Module PSReadLine\nSet-PSReadLineOption -PredictionSource History\n</code></pre>\n<p>此外，该工具也支持其他功能：</p>\n<pre><code class=\"language-powershell\"># Shows navigable menu of all options when hitting Tab\nSet-PSReadlineKeyHandler -Key Tab -Function MenuComplete\n\n# Autocompletion for arrow keys\nSet-PSReadlineKeyHandler -Key UpArrow -Function HistorySearchBackward\nSet-PSReadlineKeyHandler -Key DownArrow -Function HistorySearchForward\n</code></pre>\n<h2 id=\"ls-命令显示高亮\"><a class=\"anchor\" href=\"#ls-命令显示高亮\">#</a>  <code>ls</code>  命令显示高亮</h2>\n<p><a href=\"https://stackoverflow.com/a/30788506\">https://stackoverflow.com/a/30788506</a></p>\n<p>通过以下命令安装  <code>Color</code>  模块，支持  <code>ls</code>  命令显示高亮<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>：</p>\n<pre><code class=\"language-powershell\">Install-Module Color\n</code></pre>\n<p>之后，在配置文件中添加导入模块语句：</p>\n<pre><code class=\"language-powershell\">Import-Module Color \n</code></pre>\n<h2 id=\"美化\"><a class=\"anchor\" href=\"#美化\">#</a> 美化</h2>\n<p>类似于  <code>oh-my-zsh</code> ， <code>Powershell</code>  可以使用  <code>oh-my-posh</code>  来美化。</p>\n<p>使用以下命令安装  <code>oh-my-posh</code> ：</p>\n<pre><code class=\"language-powershell\">winget install JanDeDobbeleer.OhMyPosh -s winget\n</code></pre>\n<h3 id=\"启用主题\"><a class=\"anchor\" href=\"#启用主题\">#</a> 启用主题</h3>\n<p>使用以下命令可以激活自己想要的主题：</p>\n<pre><code class=\"language-powershell\">oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/ys.omp.json&quot; | Invoke-Expression;\n</code></pre>\n<p>其中  <code>ys</code>  是想要启用的主题的名称，终端主题可以在官方网站主题页面查看。<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup></p>\n<p>以上命令也可以加入到  <code>Powershell</code>  的配置文件中。</p>\n<h3 id=\"安装字体\"><a class=\"anchor\" href=\"#安装字体\">#</a> 安装字体</h3>\n<p>许多主题可能用到了特殊字符，如果终端中出现了方块显示的符号，可以下载官方推荐的 Nerd 字体。<sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup></p>\n<p>字体下载网站：<a href=\"https://www.nerdfonts.com/font-downloads\">Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher</a></p>\n<h3 id=\"posh-git-模块\"><a class=\"anchor\" href=\"#posh-git-模块\">#</a>  <code>posh-git</code>  模块</h3>\n<p>安装  <code>posh-git</code>  模块可以为  <code>oh-my-posh</code>  提供  <code>git</code>  状态显示和命令补全等功能。使用以下命令安装：</p>\n<pre><code class=\"language-powershell\">Install-Module posh-git\n</code></pre>\n<p>并在配置文件中添加导入语句。</p>\n<p>注意，在某些较大的  <code>Git</code>  仓库中，该模块可能会影响实际的性能，因此可以视情况决定是否启用。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.3\">在 Windows 上安装 PowerShell - PowerShell | Microsoft Learn</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://dev.to/animo/fish-like-autosuggestion-in-powershell-21ec\">Fish-like Autosuggestion in Powershell - DEV Community 👩‍💻👨‍💻</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"https://stackoverflow.com/questions/9406434/powershell-properly-coloring-get-childitem-output-once-and-for-all/30788506#30788506\">colors - Powershell: Properly coloring Get-Childitem output once and for all - Stack Overflow</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"https://ohmyposh.dev/docs/themes\">Themes | Oh My Posh</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p><a href=\"https://www.nerdfonts.com/font-downloads\">Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher</a> <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Configs",
                "Powershell"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Python/dataclass-and-YAML-transform/",
            "url": "https://linn-ylz.com/Computer-Science/Python/dataclass-and-YAML-transform/",
            "title": "dataclass 与 YAML 的相互转换",
            "date_published": "2022-11-10T15:17:33.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>在许多工程项目中，经常需要配置一些选项供用户或者员工自己使用。以人工智能领域为例， <code>Paddlepaddle</code> 、 <code>mmdetection</code>  等深度学习框架都需要根据需求在配置文件中配置数据、网络等相关参数。 <code>Paddlepaddle</code>  使用  <code>YAML</code>  格式存储配置信息， <code>mmdetection</code>  则直接使用  <code>Python</code>  文件来设定配置。此外， <code>JSON</code>  格式也是常用的数据存储格式。无论何种格式，当配置信息不断增加膨胀之后，如何组织配置的结构就成为了一件迫切需要考虑的事情。</p>\n<p>这三种配置格式孰优孰劣，我无法评价。由于我目前接手的工作中使用的是  <code>YAML</code>  格式的配置文件，因此本文主要介绍最近一段时间经过调研搜索后，我决定采用的一种配置文件组织方案。</p>\n<p>在实际阐述方案之前，有必要阐述一下  <code>YAML</code>  和  <code>dataclass</code>  这两个概念。如果读者对这二者比较熟悉，可以直接跳过相关部分。</p>\n<h2 id=\"yaml-中的-tag\"><a class=\"anchor\" href=\"#yaml-中的-tag\">#</a>  <code>YAML</code>  中的  <code>tag</code></h2>\n<p><code>YAML</code>  诞生于 2004 年，根据官网说法<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>，其有 7 条设计目标，其中，易读、不同编程语言间良好的兼容性、可扩展等特性使得其被广泛用于存储格式化的信息。</p>\n<p>关于其具体的语法，可以参考<a href=\"https://yaml.org/spec/1.2.2/\">官方网站</a>或者其他<a href=\"https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html\">教程</a>，这里不做过多介绍，本文主要介绍其  <code>tag</code>  标签功能。</p>\n<p><code>tag</code>  可以标注  <code>YAML</code>  中数据的类型或者其归属的对象类别，其可以是  <code>str</code> 、 <code>int</code> 、 <code>float</code>  等基本类型，也可以是用户自己定义的任何有意义的类别名称。这些标签可以帮助我们在阅读或者解析的时候，更方便地判断数据的归属。</p>\n<p>我们不妨来看一个例子：</p>\n<pre><code class=\"language-yaml\">name: 'linn'\nage: 18\ngender: 'male'\n</code></pre>\n<p>在上述  <code>YAML</code>  文件中，我们定义了三个属性，可以很清晰地看到，这三个属性描述的都是个人信息，它们在许多场景下通常会结伴出现。对于这种数据，有一个专门的称呼叫做数据泥团（Data Clumps）<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>。有时候，我们会发现某些函数包含大量的参数，而这些参数往往一起出现，很显然，在通常的编程语言中，用结构体或者类来组织这种数据，比直接使用原生类型是更好的选择。而在  <code>YAML</code>  中，我们也可以用  <code>tag</code>  来表征这一特点：</p>\n<pre><code class=\"language-yaml\">!Person\nname: 'linn'\nage: 18\ngender: 'male'\n</code></pre>\n<p>在  <code>YAML</code>  中，使用  <code>!</code>  来表示这一标识是一个  <code>tag</code>  的名称。相比于仅仅列出属性，增加一个  <code>tag</code>  可以使得数据的语义更加明晰。当我们的配置文件中的数据项膨胀到数十个的时候，增加一个  <code>tag</code>  能够帮助你更好的理解配置选项的意义。</p>\n<h2 id=\"解析-yaml-的-tag\"><a class=\"anchor\" href=\"#解析-yaml-的-tag\">#</a> 解析  <code>YAML</code>  的  <code>tag</code></h2>\n<p>当然，光在  <code>YAML</code>  中定义一个  <code>tag</code> ，并没有全部发挥出  <code>tag</code>  的作用。 <code>tag</code>  黑能配合编程语言，帮助解析  <code>YAML</code>  文件中的内容。</p>\n<p>想象一下，当没有  <code>tag</code>  的时候，我们通常是如何解析  <code>YAML</code>  的？一般情况的代码大致如下（为了方便，直接在文件中用字符串表示  <code>YAML</code>  内容）：</p>\n<pre><code class=\"language-python\">import yaml\nclass Person:\n    def __init__(self, name, age, gender):\n        self.name = name\n        self.age = age\n        self.gender = gender\n\nyaml_str = &quot;&quot;&quot;\nname: 'linn'\nage: 18\ngender: 'male'\n&quot;&quot;&quot;\ncontent = yaml.load(yaml_str, Loader=yaml.SafeLoader)\n\n&quot;&quot;&quot;\ncontent\n&#123;'name': 'linn', 'age': 18, 'gender': 'male'&#125;\n&quot;&quot;&quot;\n\nperson = Person(**content)\n</code></pre>\n<p>以上代码可以分为两个部分：</p>\n<ol>\n<li>读取  <code>YAML</code>  文件的内容，赋值给某个对象。一般而言，读入的内容会存储在字典或者列表中；</li>\n<li>创建某个类的对象，利用读取的  <code>YAML</code>  内容为其初始化。<br />\n对于结构简单的  <code>YAML</code>  文件，上述方法还可接受，但是如果  <code>YAML</code>  文件变得复杂，那么按照上述方法来解析的代码便会变得繁琐。</li>\n</ol>\n<p>我们可以看下面这个例子<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>：</p>\n<pre><code class=\"language-python\">name: MyBusiness\nlocations:\n  - &quot;Hawaii&quot;\n  - &quot;India&quot;\n  - &quot;Japan&quot;\nemployees:\n  - !Employee\n    name: Matthew Burruss\n    id: 1\n  - !Employee\n    name: John Doe\n    id: 2\n</code></pre>\n<p>显然，如果  <code>employees</code>  中的内容较多，我们甚至还需要写一个循环来初始化这些对象。而通过结合  <code>YAML</code>  的  <code>tag</code> ，我们可以自定义  <code>constructor</code>  来解析其内容：</p>\n<pre><code class=\"language-python\">import yaml\n\nclass Employee:\n  &quot;&quot;&quot;Employee class.&quot;&quot;&quot;\n  def __init__(self, name, id):\n    self._name, self._id = name, id\n\ndef employee_constructor(loader: yaml.SafeLoader, node: yaml.nodes.MappingNode) -&gt; Employee:\n  &quot;&quot;&quot;Construct an employee.&quot;&quot;&quot;\n  return Employee(**loader.construct_mapping(node))\n\ndef get_loader():\n  &quot;&quot;&quot;Add constructors to PyYAML loader.&quot;&quot;&quot;\n  loader = yaml.SafeLoader\n  loader.add_constructor(&quot;!Employee&quot;, employee_constructor)\n  return loader\n\nyaml.load(open(&quot;config.yml&quot;, &quot;rb&quot;), Loader=get_loader())\n&quot;&quot;&quot;\n&#123;\n  'name': 'MyBusiness',\n  'locations': ['Hawaii', 'India', 'Japan'],\n  'employees': [\n    &lt;__main__.Employee object at 0x7f0ea2694d10&gt;,\n    &lt;__main__.Employee object at 0x7f0ea2694d90&gt;\n  ]\n&#125;\n&quot;&quot;&quot;\n</code></pre>\n<p>这样一来，我们可以直接生成对应的类的对象，省去了自己创建的过程。</p>\n<h2 id=\"dataclass\"><a class=\"anchor\" href=\"#dataclass\">#</a>  <code>dataclass</code></h2>\n<p>你是否经常面临下面的情形：</p>\n<pre><code class=\"language-python\">class Person:\n    def __init__(self, name, age, gender, ...):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        ...\n</code></pre>\n<p>当我们在  <code>__init__</code>  函数的参数列表中敲击了一系列参数之后，又需要在  <code>__init__</code>  函数体中，将它们一一赋值给类成员变量。一旦这些变量数量增多，这项工作就成了一项非常繁琐无趣的事情。</p>\n<p>很多时候，我们定义类只是想将一些相关的数据组织起来，但却不得不动手编写许多重复的代码。于是乎，这里就轮到  <code>dataclass</code>  出场了。类比而言， <code>dataclass</code>  可以看成是  <code>C/C++</code>  中的结构体，能够方便我们将一系列的数据组合在一起，同时给每个成员指定默认值，不用再手动为成员变量赋值。</p>\n<p>可以看下面这个例子<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\n@dataclass\nclass Lang: \n\t&quot;&quot;&quot;a dataclass that describes a programming language&quot;&quot;&quot;\n\tname: str = 'python'\n\tstrong_type: bool = True\n\tstatic_type: bool = False\n\tage: int = 28 \n</code></pre>\n<p>这里定义了一个编程语言的类  <code>Lang</code> ，我们从  <code>dataclasses</code>  模块中引入了装饰器  <code>dataclass</code> 。之后，我们在类中定义了一系列成员变量。</p>\n<p>使用上述方式定义之后，该类会自动生成一个初始化构造函数：</p>\n<pre><code class=\"language-python\">def __init__(self, name: str='python',\n            strong_type: bool=True,\n            static_type: bool=False,\n            age: int=28):\n    self.name = name\n    self.strong_type = strong_type\n    self.static_type = static_type\n    self.age = age\n</code></pre>\n<p>除此之外， <code>__repr__</code>  和  <code>__eq__</code>  函数也会自动生成，便于打印和比较。通过以上方式，再也不用每次都自己定义一个构造函数，并且为每个变量都赋值一遍，省却了繁琐的操作。</p>\n<p>执行效果如下：</p>\n<pre><code class=\"language-python\">&gt;&gt;&gt; Lang()\nLang(name='python', strong_type=True, static_type=False, age=28)\n&gt;&gt;&gt; Lang('js', False, False, 23)\nLang(name='js', strong_type=False, static_type=False, age=23)\n&gt;&gt;&gt; Lang('js', False, False, 23) == Lang()\nFalse\n&gt;&gt;&gt; Lang('python', True, False, 28) == Lang()\nTrue\n</code></pre>\n<p>除此之外， <code>dataclass</code>  可以通过  <code>asdict</code>  或者  <code>astuple</code>  生成类成员的字典或者元组。</p>\n<p>需要注意的是，对于  <code>mutable</code>  类型的变量，如  <code>list</code> 、 <code>map</code>  等，推荐使用  <code>field</code>  来初始化：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass, field\n@dataclass\nclass C:\n    mylist: List[int] = field(default_factory=list)\n</code></pre>\n<p>其他功能的详细介绍，可以参考<a href=\"https://www.cnblogs.com/apocelipes/p/10284346.html\">这篇博客</a>或者<a href=\"https://peps.python.org/pep-0557/\">官方网站</a>的说明。</p>\n<h2 id=\"结合-dataclass-和-yaml\"><a class=\"anchor\" href=\"#结合-dataclass-和-yaml\">#</a> 结合  <code>dataclass</code>  和  <code>YAML</code></h2>\n<p>在介绍以上两部分内容之后，我们可以结合  <code>dataclass</code>  和  <code>YAML</code>  来方便地构建配置类，并从  <code>YAML</code>  文件导入，或者导出到  <code>YAML</code>  文件。</p>\n<p>参考了相关资料后<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3:1\">[3:1]</a></sup><sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup>，我编写了下面的参数类模板。</p>\n<pre><code class=\"language-python\">import sys\nimport yaml\nfrom yaml import SafeLoader, SafeDumper\nfrom yaml.nodes import MappingNode\nfrom dataclasses import dataclass, asdict, field, is_dataclass\nfrom typing import Type\nfrom typing_extensions import Self\n\n\n@dataclass\nclass BaseConfig(object):\n    @classmethod\n    def constructor(cls, loader: SafeLoader, node: MappingNode) -&gt; Self:\n        &quot;&quot;&quot;Construct an instance.&quot;&quot;&quot;\n        return cls(**loader.construct_mapping(node))\n\n    @classmethod\n    def loader(cls, safe_loader: SafeLoader) -&gt; Type[SafeLoader]:\n        &quot;&quot;&quot;Add constructors to PyYAML loader.&quot;&quot;&quot;\n        safe_loader = yaml.SafeLoader\n        safe_loader.add_constructor(f&quot;!&#123;cls.__name__&#125;&quot;, cls.constructor)\n        for (name, data_fields) in cls.__dataclass_fields__.items():\n            cls_type = data_fields.type\n            if is_dataclass(cls_type):\n                safe_loader.add_constructor(f&quot;!&#123;cls_type.__name__&#125;&quot;, cls_type.constructor)\n                safe_loader = cls_type.loader(SafeLoader)\n        return safe_loader\n\n    @classmethod\n    def representer(cls, dumper: SafeDumper, config) -&gt; MappingNode:\n        &quot;&quot;&quot;Represent an instance as a YAML mapping node.&quot;&quot;&quot;\n        return dumper.represent_mapping(f&quot;!&#123;cls.__name__&#125;&quot;, config.__dict__)\n\n    @classmethod\n    def dumper(cls, safe_dumper: SafeDumper) -&gt; Type[SafeDumper]:\n        &quot;&quot;&quot;Add representers to a YAML seriailizer.&quot;&quot;&quot;\n        # safe_dumper = yaml.SafeDumper\n        safe_dumper.add_representer(cls, cls.representer)\n        for (name, data_fields) in cls.__dataclass_fields__.items():\n            cls_type = data_fields.type\n            if is_dataclass(cls_type):\n                safe_dumper.add_representer(cls_type, cls_type.representer)\n                safe_dumper = cls_type.dumper(safe_dumper)\n        return safe_dumper\n\n\n@dataclass\nclass DatasetConfig(BaseConfig):\n    data_root_path: str = &quot;./data/coco&quot;\n    train_path: str = &quot;./data/coco/train&quot;\n    train_ann_path: str = &quot;./data/coco/annotations/instances_train2017.json&quot;\n\n\n@dataclass\nclass COCODatasetConfig(BaseConfig):\n    name: str = &quot;COCO&quot;\n    num_classes: int = 80\n    dataset: DatasetConfig = field(default_factory=DatasetConfig)\n\n\n@dataclass\nclass COCODataConfig(BaseConfig):\n    train_data: COCODatasetConfig = field(default_factory=COCODatasetConfig)\n    val_data: COCODatasetConfig = field(default_factory=COCODatasetConfig)\n\n    # If you want dump without tag, change the tag name of the class\n    # to 'tag:yaml.org,2002:map', this is the default map type of YAML\n    # @classmethod\n    # def representer(cls, dumper: SafeDumper, config) -&gt; MappingNode:\n    #     &quot;&quot;&quot;Represent an instance as a YAML mapping node.&quot;&quot;&quot;\n    #     return dumper.represent_mapping(&quot;tag:yaml.org,2002:map&quot;, config.__dict__)\n\nif __name__ == &quot;__main__&quot;:\n    # config = COCODatasetConfig()\n    # config = yaml.load(open(&quot;output.yaml&quot;, &quot;rb&quot;), Loader=COCODataConfig.loader(SafeLoader))\n    config = COCODataConfig()\n    print(config)\n    print(asdict(config))\n    # config = DatasetConfig()\n    # with open(&quot;output.yaml&quot;, &quot;w&quot;) as stream:\n        # stream.write(yaml.dump(config, Dumper=COCODatasetConfig.dumper()))\n        # stream.write(yaml.dump(config, Dumper=COCODataConfig.dumper(SafeDumper)))\n    # yaml.dump(config, sys.stdout, Dumper=COCODatasetConfig.dumper(), sort_keys=False)\n    yaml.dump(config, sys.stdout, Dumper=COCODataConfig.dumper(SafeDumper), sort_keys=False)\n\n\n</code></pre>\n<p>上述模板可以支持多个  <code>dataclass</code>  类别的嵌套，并且会保留每个类别的  <code>tag</code>  标签，便于将来再读取配置的内容。</p>\n<p>如果不想输出某个  <code>dataclass</code>  类的  <code>tag</code> ，则重载其  <code>representer</code>  和  <code>loader</code>  函数，修改其中设定的  <code>tag</code>  名称为  <code>tag:yaml.org,2002:map</code> <sup class=\"footnote-ref\"><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup>。其他类型可以参看官方文档<sup class=\"footnote-ref\"><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup>。</p>\n<p>如果某些变量依赖于其他变量的赋值，可以使用  <code>__post_init__</code>  方法：</p>\n<pre><code class=\"language-python\">@dataclass\nclass C:\n    a: int\n    b: int\n    c: int = field(init=False)\n \n    def __post_init__(self):\n        self.c = self.a + self.b\n</code></pre>\n<p>此外，如果需要额外的参数用于初始化，但是之后的程序中不需要用到它的话，可以指定一个  <code>field</code>  的类型注解为  <code>dataclasses.InitVar</code> ，那么这个  <code>field</code>  将只能在初始化过程中（ <code>__init__</code>  和  <code>__post_init__</code> ）使用，当初始化完成后访问该  <code>field</code>  会返回一个 <code>dataclasses.Field</code>  对象而不是  <code>field</code>  原本的值，也就是该  <code>field</code>  不再是一个可访问的数据对象。比如一个由数据库对象，它<strong>只需要在初始化的过程中被访问</strong>：</p>\n<pre><code class=\"language-python\">@dataclass\nclass C:\n    i: int\n    j: int = None\n    database: InitVar[DatabaseType] = None\n \n    def __post_init__(self, database):\n        if self.j is None and database is not None:\n            self.j = database.lookup('j')\n \nc = C(10, database=my_database)\n</code></pre>\n<p><code>database</code>  只在初始化过程中用于初始化  <code>i, j</code>  ，后续无法再访问，可以认为是传递了一个额外的参数用于初始化操作。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>通过以上内容，我们得到了一个用于  <code>YAML</code>  格式的通用模板类，用于导入或者导出相关的配置内容，帮助我们更好地管理配置文件中参数的结构，提高工作效率。&lt;span class=&quot;spoiler&quot;&gt; 减少加班 &lt;/span&gt;</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://yaml.org/spec/1.2.2/\">YAML Ain’t Markup Language (YAML™) revision 1.2.2</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://refactoring.guru/smells/data-clumps\">Data Clumps (refactoring.guru)</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>来自博客 <a href=\"https://matthewpburruss.com/post/yaml/\">A Powerful Python Trick: Custom YAML tags &amp; PyYAML | Matthew Burruss (matthewpburruss.com)</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a> <a href=\"#fnref3:1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>来自博客 <a href=\"https://www.cnblogs.com/apocelipes/p/10284346.html\">Python3.7 dataclass 使用指南 - apocelipes - 博客园 (cnblogs.com)</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p><a href=\"https://qiita.com/kzmssk/items/483f25f47e0ed10aa948\">dataclass を使った YAML 形式で保存／ロード可能な設定クラス - Qiita</a> <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn6\" class=\"footnote-item\"><p><a href=\"https://caosiyang.github.io/posts/2020/08/30/pyyaml/\">PyYAML 笔记 - 一个单板滑雪爱好者的编程笔记 (caosiyang.github.io)</a> <a href=\"#fnref6\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn7\" class=\"footnote-item\"><p><a href=\"https://yaml.org/type/index.html\">Language-Independent Types for YAML™ Version 1.1</a> <a href=\"#fnref7\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Algorithm",
                "Python",
                "YAML",
                "dataclass"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Algorithm/about-binary-search/",
            "url": "https://linn-ylz.com/Computer-Science/Algorithm/about-binary-search/",
            "title": "二分搜索探究",
            "date_published": "2022-09-16T12:28:29.000Z",
            "content_html": "<h1 id=\"二分搜索简介\"><a class=\"anchor\" href=\"#二分搜索简介\">#</a> 二分搜索简介</h1>\n<p>二分法是计算机领域的经典算法，它主要用于在有序数据中搜索目标数据。由于其具有优秀的时间复杂度和相对简单的实现，因此成为了考察计算机专业学子的经典问题。</p>\n<p>虽然二分法相比于其他算法的实现而言非常简单，但是在具体的实现过程中却又经常碰到这些让人头疼的问题：如何确定初始的下标边界范围？如何确定循环的终止条件？搜索过程中如何更新下标？</p>\n<p>不用怀疑自己，即使是编程的大佬们也会对这个问题犯难。按照高德纳的说法<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>，尽管最早的二分算法论文在 1946 年即已发表，但是第一个没有错误的二分搜索程序却直到 1962 年才出现。《编程珠玑》第 4 章中作者也提到<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>，他给专业程序员布置过这个题目，在给定充足时间的条件下，至少 90% 的程序员所写的代码出现了错误。可见，这个问题并没有想象得那么简单。</p>\n<h1 id=\"二分法的写法探究\"><a class=\"anchor\" href=\"#二分法的写法探究\">#</a> 二分法的写法探究</h1>\n<h2 id=\"编程珠玑\"><a class=\"anchor\" href=\"#编程珠玑\">#</a> 编程珠玑</h2>\n<p>既然抱着学习的心态，我们不妨先看看大佬们是如何编写二分搜索的代码的。《编程珠玑》第 5 章中，作者给出了  <code>C</code>  语言版本的代码，我以  <code>C++</code>  将其改写如下：</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt;\nint binary_search(vector&lt;T&gt; &amp;arr, T val)\n&#123;\n    int lower = 0, upper = arr.size() - 1, mid;\n    while (lower &lt;= upper) &#123;\n        mid = (lower + upper) / 2;  // overflow\n        if (arr[mid] &lt; val) &#123;\n            lower = mid + 1;\n        &#125; else if (arr[mid] == val) &#123;\n            return mid;\n        &#125; else &#123; /* arr[mid] &gt; val */\n            upper = mid - 1;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n</code></pre>\n<p>上述代码其实存在一个问题，即  <code>mid = (lower + upper) / 2;</code>  可能存在整数溢出的问题。这点在当时可能不是问题，因为当时的机器应该不支持 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^31</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mord\">1</span></span></span></span> 级别的元素数量。无论如何，这样的风险总是存在的。因此这句代码现在一般都写成  <code>mid = lower + (upper - lower) / 2;</code> 。</p>\n<p>以上的写法算是经典的选择闭区间的写法，其起始端点选择的是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi><mo separator=\"true\">,</mo><mi>u</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[lower, upper]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">pp</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mclose\">]</span></span></span></span> 的左闭右闭的形式，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 表示数组中的元素个数。那么常见语言的标准库中是否也是这么写的呢？</p>\n<h2 id=\"c-标准库\"><a class=\"anchor\" href=\"#c-标准库\">#</a>  <code>C++</code>  标准库</h2>\n<p><code>C++</code>  标准库中尽管有着同名的  <code>binary_search</code>  函数，但它返回的其实是一个布尔值，没有给出目标值的下标。实际上的二分搜索算法应该是  <code>lower_bound</code> 。另一个很相似的  <code>upper_bound</code>  则在写法上稍有差异。我们先重点关注  <code>lower_bound</code>  算法。下面的算法是我改写的简易版本，标准库中使用的是迭代器的通用写法，这里为了方便理解，改写成了对数组的通用写法。</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt;\nint lower_bound(vector&lt;T&gt; arr, T val)\n&#123;\n    int lower = 0;\n    int upper = arr.size();\n    while (lower &lt; upper) &#123;\n        // avoid overflow\n        int mid = lower + (upper - lower) / 2;\n        if (arr[mid] &lt; val) &#123;\n            lower = mid + 1;\n        &#125; else &#123;\n            upper = mid;\n        &#125;\n    &#125;\n    return lower;\n&#125;\n</code></pre>\n<p>可以看到，标准库中的起始端点选择是  <code>[0, N)</code> ，也就是我们常说的左闭右开的写法。</p>\n<p>可以看到，和上一小节的写法比较而言，这种写法起始端点的选择变成了  <code>[lower, upper)</code> ，循环终止条件由  <code>lower &lt;= upper</code>  变成了  <code>lower &lt; upper</code> ，区间端点值的修改上也不同。那么这种差异的原因何在呢？</p>\n<p>其实端倪在于这个函数的名称  <code>lower_bound</code> 。按照说明，该函数返回的位置是<span class=\"red\">第一个</span>能够插入  <code>val</code>  且<span class=\"red\">不改变数组有序性</span>的位置。当数组中存在我们的目标值  <code>val</code>  的时候，那么它返回的便是数组中第一个  <code>val</code>  的下标位置。而如果数组中本身就不存在  <code>val</code> ，那么最终返回的就是  <code>N</code> ，即数组最后一个元素之后的位置。实际上的库函数所返回就是容器的  <code>end()</code>  函数返回的迭代器，这也是  <code>C++</code>  库函数的一贯做法。</p>\n<p>可以看到，这两种写法的不同之处的由来，在于他们一开始的设计思路的不同。很明显地， <code>lower_bound</code>  返回的总是第一个  <code>val</code>  值所在的位置，而  <code>binary_search</code>  则不能保证这一点，因此， <code>lower_bound</code>  函数显然更通用一点。</p>\n<h2 id=\"关键点分析\"><a class=\"anchor\" href=\"#关键点分析\">#</a> 关键点分析</h2>\n<p>在编写二分搜索算法的过程中，最关键的就是以下三个问题：</p>\n<ul>\n<li>如何确定初始的下标边界范围？</li>\n<li>如何确定循环的终止条件？</li>\n<li>搜索过程中如何更新下标？</li>\n</ul>\n<p>我们一个个来看这些问题。</p>\n<h3 id=\"下标初始值\"><a class=\"anchor\" href=\"#下标初始值\">#</a> 下标初始值</h3>\n<p>那么，以上是否说明左闭右开的写法就是最优的呢？且慢，这一点并不能保证。其实本质上，所谓的闭区间和开区间其实是相对数组的下标而言的。因为实际上的返回值下标，对于数组而言可能并不合法，因此产生了开区间和闭区间的说法。所以，开闭区间说法的针对对象其实是数组本身。</p>\n<p>我们不妨换一个角度，从返回值的下标范围来看。</p>\n<p>对于  <code>lower_bound</code>  函数，其可能的返回值是  <code>[0, arr.size()]</code> ，恰好和一开始的  <code>lower</code>  和  <code>upper</code>  两个值对应。</p>\n<p>对于  <code>binary_search</code>  函数，其可能的返回值是  <code>[-1, arr.size() - 1]</code> 。乍一看来，好像和  <code>lower</code>  以及  <code>upper</code>  的初始值并不对应。其实也可以改写成以下形式：</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt;\nint binary_search(vector&lt;T&gt; &amp;arr, T val)\n&#123;\n    int lower = -1, upper = arr.size() - 1;\n    while (lower &lt; upper) &#123;\n        int mid = upper - (upper - lower) / 2;  // overflow\n        if (arr[mid] &gt; val) &#123;\n            upper = mid - 1;\n        &#125; else &#123; /* arr[mid] &gt; val */\n            lower = mid;\n        &#125;\n    &#125;\n    return lower; // or return upper;\n&#125;\n</code></pre>\n<p>如此一来，可以发现，函数的返回值范围就能和  <code>lower</code>  和  <code>upper</code>  的初始值对应上了。之所以  <code>mid</code>  的计算改写成  <code>upper - (upper - lower) / 2</code> ，是因为这样才能使  <code>mid</code>  的值在数组长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 时合法。这种写法和上文的  <code>lower_bound</code>  其实是镜像对称的：将  <code>lower</code>  换成  <code>upper</code> ，并将  <code>+</code>  替换成  <code>-</code> 。</p>\n<p>最终我们可以看到，对于返回值而言，并没有什么开区间和闭区间的说法，初始的设定值即表示了最终的返回值范围。而对于数组，由于存在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span> 或者  <code>arr.size()</code>  的特殊下标，因此对于数组而言存在开区间和闭区间的说法。</p>\n<p>综上，如果我们从函数返回值的角度而言，<span class=\"red\">有的只是下标的取值范围</span>。而一旦我们确定了函数的返回值范围，那么自然而然地就能够知道  <code>lower</code>  和  <code>upper</code>  的初始值应该如何选取了。就像上面的例子，如果使用  <code>arr.size()</code>  表示不存在的情况，那么  <code>int lower = 0, upper = arr.size();</code> ；如果使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span> 表示不存在的情况，那么  <code>int lower = -1, upper = arr.size() - 1;</code> 。综上，我们就统一了  <code>lower</code>  和  <code>upper</code>  初始值的设定标准。</p>\n<h3 id=\"循环终止条件\"><a class=\"anchor\" href=\"#循环终止条件\">#</a> 循环终止条件</h3>\n<p>在初始值确定之后，如何确定循环的终止条件呢。对于二分搜索而言，循环终止条件只有  <code>lower &lt;= upper</code>  和  <code>lower &lt; upper</code>  这两种。其实这两种方法都有各自的适用情形。</p>\n<ul>\n<li>如果写成  <code>lower &lt;= upper</code>  ？下标值的初始值对于待查找数组而言必须都是合法的，即  <code>int lower = 0, upper = arr.size() - 1;</code>  这种形式；</li>\n<li>如果写成  <code>lower &lt; upper</code> ，那么最后可能还需要对  <code>lower</code>  或者  <code>upper</code>  值做出判断。</li>\n</ul>\n<p>其实我个人认为，写成  <code>lower &lt; upper</code>  更好。因为这样最终循环终止时，必然是  <code>left == right</code>  的情形，无论返回  <code>left</code>  或者  <code>right</code>  皆可。并且如果有后续处理的需要，那么也不用纠结选择  <code>left</code>  还是  <code>right</code> 。当然，前提是选择好合适的  <code>lower</code>  和  <code>upper</code>  的初始值。如果像上小节中选择  <code>lower = -1;</code> ，还需要注意变换  <code>mid</code>  的计算方式，和通常的情况差别较大。</p>\n<p>综上，推荐写成  <code>lower &lt; upper</code> 。并且  <code>lower = 0;</code> ， <code>upper</code>  则根据需要选择合适的值。比如如果需要表明目标值不存在的特殊情况，那么推荐  <code>upper = arr.size();</code> ；如果确定值一定存在，那么推荐  <code>upper = arr.size() - 1;</code> 。<br />\n这样一来，最后直接返回  <code>lower</code>  （或者  <code>upper</code> ）即可，后续的函数再根据返回值确定是否找到了对应的目标值的下标，代码也能够更简洁。</p>\n<h3 id=\"更新边界\"><a class=\"anchor\" href=\"#更新边界\">#</a> 更新边界</h3>\n<p>边界的更新，则是一个相对复杂的问题，需要根据具体的条件来确定。一个总的原则就是，根据  <code>mid</code>  指示的下标是否在后续的搜索范围之内进行判断，根据初始值的设定有所不同。</p>\n<p>如果选择  <code>upper = arr.size();</code> ，那么：</p>\n<pre><code class=\"language-cpp\">if (arr[mid] &lt; val) &#123;\n    lower = mid + 1;\n&#125; else if (arr[mid] &gt; val) &#123;\n    upper = mid;\n&#125; else &#123;\n    return mid;\n&#125;\n</code></pre>\n<p><code>lower</code>  更新为  <code>mid + 1</code>  很好理解，如果  <code>mid</code>  不符合条件，那么应该排除它。那  <code>upper</code>  为什么设置为  <code>mid</code>  呢？这时因为在  <code>upper</code>  的这种值初始设定下， <code>upper</code>  表示的下标要么对于数组不合法，要么不在后续的搜索范围之内。通过判断， <code>mid</code>  不在后续搜索的范围之内，那么  <code>upper</code>  就应该设置为  <code>mid</code> 。如果设置为  <code>mid - 1</code> ，表示的意义则是  <code>mid - 1</code>  不在搜索范围之内，显然和我们的意思相违背。</p>\n<p>类似地，如果选择  <code>upper = arr.size() - 1;</code> ，那么：</p>\n<pre><code class=\"language-cpp\">if (arr[mid] &lt; val) &#123;\n    lower = mid + 1;\n&#125; else if (arr[mid] &gt; val) &#123;\n    upper = mid - 1;\n&#125; else &#123;\n    return mid;\n&#125;\n</code></pre>\n<p><code>lower</code>  更新为  <code>mid + 1</code>  很好理解，如果  <code>mid</code>  不符合条件，那么应该排除它。此时  <code>upper</code>  的初始值下标对于数组也是合法的，那么就应该设置为  <code>mid - 1</code> ，表示的意义则是  <code>mid - 1</code>  在后续的搜索范围之内。</p>\n<p>此外，上述两端代码写成三个判断条件是为了方便比较它们的异同。在具体的题目中，可以简化成上文的类似  <code>lower_bound</code>  的形式，在最后统一返回最终的下标值。</p>\n<p>综上而言， <code>upper</code>  的更新需要根据其初始值的设定及具体情况来确定。</p>\n<h1 id=\"leetcode-例题\"><a class=\"anchor\" href=\"#leetcode-例题\">#</a>  <code>LeetCode</code>  例题</h1>\n<p><a href=\"https://leetcode.cn/problems/find-peak-element/\">LeetCode 162</a> 中一定存在有效解，所以这一题最好的选择就是  <code>upper = arr.size() - 1</code> 。</p>\n<p>选择  <code>upper = arr.size()</code> ，统一表示不存在的情形。如果和题目规定的异常返回值不一致，那么后续再判断修改即可。典型的题目有 <a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">LeetCode 33</a>、<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">LeetCode 34</a>、<a href=\"https://leetcode-cn.com/problems/search-insert-position/\">LeetCode 35</a></p>\n<p>其他参考资料，可以参考<a href=\"https://www.zhihu.com/question/36132386\">知乎回答</a><sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup> 和 <a href=\"https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md\"> <code>labuladong</code>  的解析</a><sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><em>The Art of Computer Programming Volume 3: Sorting and Searching</em> 第 6.2.1 节 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>编程珠玑 第 4 章，第 5 章 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"https://www.zhihu.com/question/36132386\">知乎：二分查找有几种写法？它们的区别是什么？</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md\">二分查找详解</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Algorithm",
                "Cpp",
                "Binary-Search"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Configs/wsl2-installation/",
            "url": "https://linn-ylz.com/Computer-Science/Configs/wsl2-installation/",
            "title": "安装 WSL2",
            "date_published": "2022-08-09T13:26:54.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>之前在自己的笔记本上安装过  <code>Windows</code>  的  <code>Linux</code>  子系统。最近新配置了一台台式机，又需要重新配置，在过程中也稍稍遇到了一些问题，在这里记录下来以备后续的使用。</p>\n<h1 id=\"安装-wsl2\"><a class=\"anchor\" href=\"#安装-wsl2\">#</a> 安装  <code>WSL2</code></h1>\n<p>这里的安装过程全程参照了这个链接的内容👉：<a href=\"https://dowww.spencerwoo.com/\">戳此链接</a>。</p>\n<p>这里以其教程作为主要参考，并补充安装过程中遇到的问题的解决方式。</p>\n<h2 id=\"开启-hyper-v-和-linux-子系统服务\"><a class=\"anchor\" href=\"#开启-hyper-v-和-linux-子系统服务\">#</a> 开启  <code>Hyper-V</code>  和  <code>Linux</code>  子系统服务</h2>\n<p>要安装子系统，首先需要开启相应的  <code>Windows</code>  系统的功能：</p>\n<ul>\n<li>Hyper-V 服务</li>\n<li>Linux 子系统服务</li>\n</ul>\n<p>在管理员权限的  <code>Powershell</code>  中执行以下两条命令进行开启：</p>\n<pre><code class=\"language-bash\">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n</code></pre>\n<p>如果以上指令无法成功，也可以在开始菜单搜索  <code>启用或关闭 Windows 功能</code> ，并在其中勾选  <code>Hyper-V</code>  和  <code>适用于 Windows 的 Linux 子系统</code>  服务。之后根据提示重启电脑。</p>\n<h2 id=\"移动-wsl2-位置\"><a class=\"anchor\" href=\"#移动-wsl2-位置\">#</a> 移动  <code>WSL2</code>  位置</h2>\n<p>电脑重启后，运行安装好的子系统，我安装的是  <code>Ubuntu</code>  子系统。</p>\n<p>子系统默认安装在  <code>C</code>  盘，这使得本就不宽裕的硬盘空间雪上加霜，因此这里对子系统的安装位置进行修改。这里参考的是一个问答中提供的答案<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n<p>第一步，使用指令导出子系统文件：</p>\n<pre><code class=\"language-bash\"># Export Ubuntu\nwsl --export Ubuntu D:\\backup\\ubuntu.tar\n</code></pre>\n<p>其中， <code>Ubuntu</code>  是子系统的名称，可以通过  <code>wsl --list</code>  指令进行查看。后续的路径则是子系统文件的导出位置，根据需要进行修改。</p>\n<p>第二步，注销原来的子系统：</p>\n<pre><code class=\"language-bash\"># Unregister the same distribution to remove it from the C: drive:\nwsl --unregister Ubuntu\n</code></pre>\n<p>这里仍然需要注意不要输错了子系统的名称。</p>\n<p>第三步，导入第一步中导出的子系统文件：</p>\n<pre><code class=\"language-bash\"># Import Ubuntu\nwsl --import Ubuntu D:\\wsl\\ D:\\backup\\ubuntu.tar\n</code></pre>\n<p>在导入之后，子系统默认是使用的  <code>root</code>  用户登录，如果需要修改，可以进入  <code>cd %userprofile%\\AppData\\Local\\Microsoft\\WindowsApps</code>  路径，运行命令：</p>\n<pre><code class=\"language-bash\">ubuntu config --default-user &lt;username&gt;\n</code></pre>\n<p><code>%userprofile%</code>  表示的是用户的文件路径，一般是  <code>C:Users\\&lt;windows-log-name&gt;</code> 。如果找不到  <code>AppData</code>  文件夹，看看是否启用了隐藏文件可见。</p>\n<p>然后指令中的  <code>&lt;username&gt;</code>  是指在第一次运行子系统时输入的用户名。执行完成之后，子系统默认使用普通用户进行登录。</p>\n<h1 id=\"安装-nodejs-服务\"><a class=\"anchor\" href=\"#安装-nodejs-服务\">#</a> 安装  <code>Node.js</code>  服务</h1>\n<p>之后本想尝试在子系统下使用  <code>Node.js</code>  来运行博客，但是后来发现子系统的文件  <code>I/O</code>  速度相比原生系统还是太慢，这里还是选择在  <code>Windows</code>  下使用  <code>Node.js</code>  来运行博客的的后台服务。下文内容暂且保留以备不时之需。</p>\n<h2 id=\"安装-n-管理-nodejs-版本\"><a class=\"anchor\" href=\"#安装-n-管理-nodejs-版本\">#</a> 安装  <code>n</code>  管理  <code>Node.js</code>  版本</h2>\n<p>在文章开头提到的子系统安装链接中，提到了使用  <code>n</code>  来管理  <code>Node.js</code>  的版本。由于直接使用官网<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>的命令安装无法成功获取脚本，因此仍然选择通过浏览器访问脚本文件，并在本地文件夹创建相应的脚本，在其中粘贴从浏览器复制的脚本内容。之后运行以下指令：</p>\n<pre><code class=\"language-bash\">bash n lts\n</code></pre>\n<p>以上指令可能需要使用  <code>sudo</code>  权限。<br />\n运行之后使用  <code>node --version</code>  和  <code>npm --version</code>  确认是否安装成功。</p>\n<p>安装完成后， <code>node</code>  命令运行正常，但是  <code>npm</code>  命令遇到了以下错误：</p>\n<div class=\"note warning\">\n<p>/usr/bin/env: ‘bash\\r’: No such file or directory</p>\n</div>\n<p>这里参考了<a href=\"https://peaku.co/questions/3239-despues-de-instalar-npm-en-wsl-ubuntu-2004,-aparece-el-mensaje-%26quot;-usr-bin-env:-%26%2339;bash%5Cr%26%2339;:-no-such-file-or-directory%26quot;\">此链接</a>解决。按照其中被采纳的答案，创建  <code>/etc/wsl.conf</code>  文件，并在其中添加以下内容：</p>\n<pre><code class=\"language-test\">[interop]\nappendWindowsPath = false\n</code></pre>\n<p>然后在  <code>Powershell</code>  中使用  <code>wsl --shutdown</code>  关闭子系统，之后重新打开，运行  <code>bash n lts</code>  安装命令。之后  <code>npm --version</code>  命令能够正常显示。</p>\n<h2 id=\"安装-yarn\"><a class=\"anchor\" href=\"#安装-yarn\">#</a> 安装 yarn</h2>\n<p>接下来，使用  <code>npm</code>  安装  <code>yarn</code>  进行包管理。相比于原生的  <code>npm</code> ，该工具更加现代。使用如下命令安装  <code>yarn</code> ：</p>\n<pre><code class=\"language-bash\">npm install -g yarn\n</code></pre>\n<p>运行  <code>yarn --version</code> ，成功输出版本信息则安装成功。</p>\n<h3 id=\"结合-yarn-安装-hexo\"><a class=\"anchor\" href=\"#结合-yarn-安装-hexo\">#</a> 结合 yarn 安装 Hexo</h3>\n<p>之后，参考一篇博客的内容<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>，使用  <code>yarn</code>  安装  <code>Hexo</code>  服务。</p>\n<p>使用如下指令安装  <code>hexo</code> ：</p>\n<pre><code class=\"language-bash\">yarn add hexo-cli -g\n</code></pre>\n<p>以上指令执行后，运行  <code>hexo -v</code>  如果返回版本等信息，则说明安装成功。</p>\n<p>在这里，我碰到了无法运行  <code>hexo</code>  的问题，尝试过参考  <code>StackOverflow</code>  中的答案<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>使用  <code>yarn global add hexo-cli</code>  安装，仍然无法解决该问题。</p>\n<p>后来发现，需要在环境变量添加  <code>yarn</code>  的相关路径，具体参考<a href=\"https://classic.yarnpkg.com/en/docs/cli/global\">此链接</a>，使用如下指令添加：</p>\n<pre><code class=\"language-bash\">export PATH=&quot;$(yarn global bin):$PATH&quot;\n</code></pre>\n<p>之后可以成功运行  <code>hexo</code>  命令。</p>\n<h2 id=\"卸载\"><a class=\"anchor\" href=\"#卸载\">#</a> 卸载</h2>\n<p>由于子系统的文件  <code>I/O</code>  过于缓慢，因此最后还是放弃在子系统中运行  <code>Hexo</code>  相关的服务。对于安装的上述软件，使用以下指令删除：</p>\n<pre><code class=\"language-bash\"># 删除 n 包管理器\nsudo bash n uninstall\n\n# 查找 yarn 和 node_modules 等残留文件\n# 以下例子表示查找包含 yarn 名称的文件，过滤 /mnt/ 开头的路径，这部分是 Windows 系统中的文件\nlocate '*yarn*' | grep -v '/mnt/' \n</code></pre>\n<p>找到路径后，使用  <code>rm</code>  删除相关的文件即可。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://superuser.com/questions/1550622/move-wsl2-file-system-to-another-drive\">https://superuser.com/questions/1550622/move-wsl2-file-system-to-another-drive</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://github.com/tj/n\"> <code>n</code>  的官方  <code>GitHub</code>  仓库</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"https://www.taojishu8.com/2021/01/28/%E3%80%90Hexo%E3%80%91%E2%91%A1%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">【Hexo】②如何使用 Hexo 和 GitHub 搭建个人博客</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"https://stackoverflow.com/questions/48484265/failed-to-install-hexo-cli-on-mac\">Failed to install hexo-cli on mac</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Configs",
                "WSL2"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Emacs/emacs-learning-4/",
            "url": "https://linn-ylz.com/Computer-Science/Emacs/emacs-learning-4/",
            "title": "Emacs 学习（四）Emacs 详细配置",
            "date_published": "2022-01-17T09:34:55.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>我个人主要使用的操作系统是  <code>Windows</code> ，所以我希望在这个环境下配置好  <code>Emacs</code> ，这里就有两个选择，一个是原生的  <code>Windows</code>  下的  <code>Emacs</code>  应用程序；另一种选择是  <code>Linux</code>  子系统下安装  <code>Emacs</code> ，因为现在  <code>Linux</code>  子系统也支持图形界面应用了，所以直接安装使用也非常方便。但是在实际配置的过程中间遇到了许多的问题，只能说各有优缺点，这里我最终还是选择了使用  <code>Windows</code>  下的原生  <code>Emacs</code>  程序。</p>\n<h2 id=\"linux-子系统\"><a class=\"anchor\" href=\"#linux-子系统\">#</a>  <code>Linux</code>  子系统</h2>\n<p>子系统下无论是安装  <code>Emacs</code>  还是设置其他配置都非常方便，基本和原生的  <code>Linux</code>  系统没有太大差别。但是一个比较大的问题就是对中文的支持并不好。在期间试过  <code>cnfonts</code>  插件<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>，但是中文仍然显示乱码。</p>\n<p>一开始我尝试通过在终端中而不是  <code>GUI</code>  界面使用  <code>Emacs</code> ，发现中文字体已经显示正常了。 <code>Emacs</code>  通过  <code>emacs -nw</code>  指令运行，可以进入非  <code>GUI</code>  的界面。本来到这里应该就能够结束了，但是后来发现部分快捷键在终端模式下失效，搜索一番后发现，原来是终端无法识别部分按键的模式，具体原因可以查看<a href=\"https://emacs.stackexchange.com/questions/1020/problems-with-keybindings-when-using-terminal\">这个回答</a><sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>。</p>\n<p>如此一来，只能尝试解决  <code>GUI</code>  界面的显示问题。后来经过搜索，发现是  <code>Linux</code>  子系统中无法直接找到  <code>Windows</code>  系统中的字体。 <code>Linux</code>  子系统中的字体可以通过  <code>fc-list</code>  指令查看，我发现其中并没有列举出中文相关字体，这也难怪中文显示会乱码了。</p>\n<p>在我的系统中，字体文件存储在  <code>/usr/share/fonts</code>  下，为了导入  <code>Windows</code>  下的字体，我使用下面的指令建立了一个软链接指向  <code>Windows</code>  系统下存放字体文件的文件夹：</p>\n<pre><code class=\"language-bash\">cd /usr/share/fonts\nln -s /mnt/c/Windows/Fonts ./windows\n</code></pre>\n<p>之后再使用  <code>fc-cache</code>  命令让系统识别新加入的字体，现在使用  <code>fc-list</code>  再查看字体就能够发现中文字体了。在  <code>GUI</code>  界面中使用  <code>cnfonts</code>  也能正常配置字体了。</p>\n<p>但是此时其他问题又困扰了我，在  <code>GUI</code>  界面中，无法调用  <code>Windows</code>  系统的输入法，而  <code>Emacs</code>  系统自己的中文输入法使用体验又非常糟糕。除此之外更重要的问题就是在我每次打开  <code>Emacs</code>  时，编辑界面会不断写入  <code>n</code>  字符，如果我不进行任何操作，便会一直输入，这在编辑文件时非常让人恼火，总不能每次打开  <code>Emacs</code>  还要先删除一遍多出来的这些  <code>n</code>  字符吧。于是我最终在一番折腾之后，还是尝试使用  <code>Windows</code>  原生程序进行配置了。</p>\n<h2 id=\"windows-原生程序\"><a class=\"anchor\" href=\"#windows-原生程序\">#</a>  <code>Windows</code>  原生程序</h2>\n<p>相比于  <code>Linux</code>  子系统下的  <code>Emacs</code>  程序， <code>Windows</code>  原生的  <code>Emacs</code>  程序对于中文的支持要好得多，系统的输入法也能够直接调用，这方面的配置可以直接省略。在此之外， <code>Windows</code>  安装一些配置的时候可能会要稍微麻烦一些，因为  <code>Windows</code>  下的  <code>Emacs</code>  程序会在  <code>C:\\Users\\YourUserName\\AppData\\Roaming</code>  路径下建立  <code>.emacs.d</code>  文件夹作为配置文件的存放位置。因此这里参考了别人的做法，在其中的  <code>init.el</code>  文件中写入了以下内容让其读取对应路径下的配置：</p>\n<pre><code class=\"language-lisp\">(setenv &quot;HOME&quot; &quot;D:/Programs/Emacs&quot;)\n(setenv &quot;PATH&quot; &quot;D:/Programs/Emacs&quot;)\n;;set the default file path\n(setq default-directory &quot;D:/Programs/Emacs&quot;)\n\n(load-file &quot;D:/Programs/Emacs/.emacs.d/init.el&quot;)\n</code></pre>\n<p>虽然配置的时候麻烦了一些，但是总的来说还算比较方便，也没有快捷键的问题。</p>\n<h1 id=\"emacs-配置\"><a class=\"anchor\" href=\"#emacs-配置\">#</a> Emacs 配置</h1>\n<p>在之前的文章中推荐过一个  <code>Emacs</code>  配置<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>，但是这个配置对中文的适配并不友好，而且很多东西确实用不到，所以我又搜索了一些其他的配置。下面算是对这个<s>愉快</s>心酸的配置过程的一个记录。</p>\n<h2 id=\"spacemacs-和-doom-emacs\"><a class=\"anchor\" href=\"#spacemacs-和-doom-emacs\">#</a>  <code>Spacemacs</code>  和  <code>Doom Emacs</code></h2>\n<p>在  <code>GitHub</code>  上可以搜索的许多人提供的  <code>Emacs</code>  配置，目前最热门的应该是  <code>Spacemacs</code> <sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup> 和  <code>Doom Emacs</code> <sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup>。但是这两个配置都比较庞大，添加的内容很多，而且在安装时因为需要从  <code>GitHub</code>  下载内容，经常安装到一半就因为网络问题出错。</p>\n<p>尤其是  <code>Doom Emacs</code> ，虽然在  <code>Emacs China</code>  有相关教程帖<sup class=\"footnote-ref\"><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup>，但是期间也还是会碰到许多问题。</p>\n<p>主要的一个问题就是  <code>clone</code>   <code>Github</code>  下的  <code>repo</code>  的时候经常无法成功，在配置了以下内容的时候才算是正常安装完成了：</p>\n<pre><code class=\"language-bash\">git config --global url.https://github.com.cnpmjs.org/.insteadof https://github.com/\n</code></pre>\n<p>这个是将  <code>github.com</code>  的域名替换成  <code>github.com.cnpmjs.org</code>  的镜像域名，确实在下载的时候速度要快很多。但是在完成安装之后发现  <code>Emacs</code>  无法正常读取  <code>Doom Emacs</code>  的配置，我个人估计应该是路径问题。但是我之前使用 purcell 的配置又是可以的，估计应该是  <code>Doom Emacs</code>  的配置特殊一点。</p>\n<p>于是我只能再尝试其他的配置了。</p>\n<h2 id=\"centaur-emacs\"><a class=\"anchor\" href=\"#centaur-emacs\">#</a>  <code>Centaur Emacs</code></h2>\n<p>最终我选择了  <code>Centaur Emacs</code> ，尽管没有  <code>Spacemacs</code>  和  <code>Doom Emacs</code>  那么流行，但是目前也有 1.5k 的 Star，而且作者应该是中国人，对中文的支持也更好。安装非常简单，使用：</p>\n<pre><code class=\"language-bash\">git clone --depth 1 https://github.com/seagle0128/.emacs.d.git ~/.emacs.d\n</code></pre>\n<p>将  <code>repo</code>   <code>clone</code>  下来之后即可使用。在第一次启动的时候，会下载安装一些插件，因此会比较慢一些。在安装过程中，可能会报出一些错误，如果是  <code>package</code>  找不到的错误，那么安装即可。我这里记录一些其他的错误，读者也可以参考其他的文章<sup class=\"footnote-ref\"><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup>。</p>\n<h3 id=\"图标及字体下载\"><a class=\"anchor\" href=\"#图标及字体下载\">#</a> 图标及字体下载</h3>\n<p><code>Centaur Emacs</code>  使用到了一些图标，因此需要安装相应的字体才能够显示，使用  <code>M-x all-the-icons-install-fonts</code>  能够安装相应的字体。但是这个指令是访问  <code>raw.githubusercontent.com</code>  这个域名进行下载，因此不使用代理就无法顺利下载。尽管我这里有代理，但是依然无法下载成功，虽然我在浏览器中是能够成功使用代理的，不知道是哪里没有配置对。一番搜索之后发现只要在网页中下载，然后将字体安装到系统中即可。其他问题可以参考  <code>GitHub</code>  仓库下的  <code>issue</code> 。</p>\n<p>将  <code>https://github.com/domtronn/all-the-icons.el</code> <sup class=\"footnote-ref\"><a href=\"#fn8\" id=\"fnref8\">[8]</a></sup> 这个  <code>repo</code>  中的  <code>fonts</code>  文件夹下的字体安装好即可顺利显示图标。</p>\n<p><s>不过有个图标还是显示异常，所以最终我还是决定关掉这个图标，在  <code>custom.el</code>  中将  <code>(setq centaur-icon nil)</code>  的注释去掉即可。</s></p>\n<p>经过一番查找，最终发现应该是  <code>Unicode</code>  字符显示异常，在  <code>custom.el</code>  中字体设置相关的语句中，将  <code>(cl-loop for font in '(&quot;Symbola&quot; &quot;Apple Color Emoji&quot; &quot;Segoe UI Symbol&quot; &quot;Symbol&quot;)</code>  中的字体顺序调整成了现在的这个顺序，默认优先使用  <code>Symbola</code>  字体，现在显示已经正常。</p>\n<h3 id=\"dashboard-不显示信息\"><a class=\"anchor\" href=\"#dashboard-不显示信息\">#</a> Dashboard 不显示信息</h3>\n<p>在  <code>repo</code>  下的 issue<sup class=\"footnote-ref\"><a href=\"#fn9\" id=\"fnref9\">[9]</a></sup> 中找到了相同的问题，解决方法是将  <code>.emacs.d</code>  下的  <code>elpa</code>  文件夹删除，然后重新打开  <code>Emacs</code>  重新安装即可。</p>\n<h3 id=\"org-mode-显示效果修改\"><a class=\"anchor\" href=\"#org-mode-显示效果修改\">#</a> org-mode 显示效果修改</h3>\n<p>我个人主要使用  <code>Emacs</code>  的  <code>org-mode</code> ，发现对于字体显示效果，配置会将  <code>*</code> ， <code>+</code>  等特殊字体效果的标记符号给隐藏，这和我的习惯不同，在  <code>list\\init-org.el</code>  配置文件中修改 <code>org-hide-emphasis-markers</code>  为  <code>nil</code> 。</p>\n<p>尽管如此，汉字斜体无法显示出倾斜的效果，这个应该是因为汉字字体没有真正的斜体字体，而是通过其他方式得到倾斜的效果，而  <code>Emacs</code>  是直接读取倾斜字体来显示倾斜效果的，对于没有倾斜字体的英文字体也无法显示出倾斜效果，因此这里就不折腾中文的显示效果了，可以用下划线或者其他方式体现强调的效果。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>尽管  <code>Emacs</code>  配置还是花费了很多时间，但也算是有了一些收获，对  <code>Emacs</code>  的配置也稍微有了些了解。在  <code>Doom Emacs</code>  的安装过程中，还发现了  <code>Scoop</code>  这款  <code>Windows</code>  下的包管理器，能够安装  <code>gcc</code>  是确实有些出乎我预料之外的，以后可以试着用  <code>Scoop</code>  来让  <code>Powerline</code>  下的命令和  <code>Linux</code>  终端更趋近一致，这样就不用再因为终端不同而要搜索不同命令了。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://github.com/tumashu/cnfonts\"> <code>cnfonts</code>  插件</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://emacs.stackexchange.com/questions/1020/problems-with-keybindings-when-using-terminal\">终端下  <code>Emacs</code>  快捷键失效</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"https://github.com/purcell/emacs.d\"> <code>Emacs</code>  配置推荐</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"https://github.com/syl20bnr/spacemacs\">Spacemacs</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p><a href=\"https://github.com/hlissner/doom-emacs\">Doom Emacs</a> <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn6\" class=\"footnote-item\"><p><a href=\"https://emacs-china.org/t/emacs-windows10-emacs-11/14335\">零秒精通 Emacs 之 Windows10 上畅行无碍地使用 emacs 的 11 步骤</a> <a href=\"#fnref6\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn7\" class=\"footnote-item\"><p><a href=\"https://www.5axxw.com/wiki/content/ipt6q1\">CentaurEmacs - 一个奇特而快速的 Emacs 配置</a> <a href=\"#fnref7\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn8\" class=\"footnote-item\"><p><a href=\"https://github.com/domtronn/all-the-icons.el\">All The Icons</a> <a href=\"#fnref8\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn9\" class=\"footnote-item\"><p><a href=\"https://github.com/seagle0128/doom-modeline/issues/321\">Doom-modeline not displaying anything except window number</a> <a href=\"#fnref9\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Emacs"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Emacs/emacs-learning-3/",
            "url": "https://linn-ylz.com/Computer-Science/Emacs/emacs-learning-3/",
            "title": "Emacs 学习（三）Org-mode 学习",
            "date_published": "2022-01-17T07:30:38.000Z",
            "content_html": "<h1 id=\"何为-org-mode\"><a class=\"anchor\" href=\"#何为-org-mode\">#</a> 何为  <code>Org-mode</code></h1>\n<p><code>Org-mode</code>  是  <code>Emacs</code>  的一种 Mode，主要的应用场景有笔记管理、任务计划、项目管理等日常工作场景。我主要计划用它做笔记管理和任务计划，笔记管理后续可以结合  <code>Org-roam</code>  打造一个双链的个人知识库。</p>\n<h1 id=\"语法\"><a class=\"anchor\" href=\"#语法\">#</a> 语法</h1>\n<p>这里简单记录一些较常用的语法及相关快捷键。这一部分参考了一些博客。<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<h2 id=\"标题\"><a class=\"anchor\" href=\"#标题\">#</a> 标题</h2>\n<pre><code class=\"language-markdown\">#+TITLE: emacs org-mode 的使用\n* 这是一个一级标题\n** 这是一个二级标题\n*** 以此类推（最多10个*）\n</code></pre>\n<div class=\"note warning\">\n<p>注意：  <code>*</code>  要位于行首； <code>*</code>  后面要有一个空格。</p>\n</div>\n<p>每个标题可以看作一个大纲。</p>\n<h3 id=\"常用快捷键\"><a class=\"anchor\" href=\"#常用快捷键\">#</a> 常用快捷键</h3>\n<h4 id=\"大纲折叠\"><a class=\"anchor\" href=\"#大纲折叠\">#</a> 大纲折叠</h4>\n<table>\n<caption id=\"\" style=\"caption-side: bottom\">大纲折叠</caption>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"kbd red\">S-TAB</span></td>\n<td>循环切换整个文档的大纲状态（三种状态：折叠，打开下一级，打开全部）</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">TAB</span></td>\n<td>循环切换光标所在大纲的状态 （三种状态：折叠，打开下一级，打开全部）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"在大纲间移动\"><a class=\"anchor\" href=\"#在大纲间移动\">#</a> 在大纲间移动</h4>\n<table>\n<caption id=\"\" style=\"caption-side: bottom\">大纲间移动</caption>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"kbd red\">C-c C-n/p</span></td>\n<td>下 / 上一标题</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c C-f/b</span></td>\n<td>下 / 上一标题（仅限同级标题）</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c C-u</span></td>\n<td>跳到上一级标题</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c C-j</span></td>\n<td>切换到大纲浏览状态</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"基于大纲的编辑\"><a class=\"anchor\" href=\"#基于大纲的编辑\">#</a> 基于大纲的编辑</h4>\n<table>\n<caption id=\"\" style=\"caption-side: bottom\">基于大纲的编辑</caption>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"kbd red\">M-RET</span></td>\n<td>插入一个同级标题</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-S-RET</span></td>\n<td>插入一个同级 TODO 标题</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-LEFT/RIGHT</span></td>\n<td>将当前标题升 / 降级</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-S-LEFT/RIGHT</span></td>\n<td>将子树升 / 降级</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-S-UP/DOWN</span></td>\n<td>将子树上 / 下移</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c *</span></td>\n<td>将本行设为标题 / 正文</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c C-w</span></td>\n<td>将子树或区域移动到另一标题处（跨缓冲区）</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-x n s/w</span></td>\n<td>只显示当前子树 / 返回</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c C-x b</span></td>\n<td>在新缓冲区显示当前分支（类似 C-x n s)</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c /</span></td>\n<td>只列出包含搜索结果的大纲，并高亮，支持多种搜索方式</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c C-c</span></td>\n<td>取消高亮</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"大纲的显示格式\"><a class=\"anchor\" href=\"#大纲的显示格式\">#</a> 大纲的显示格式</h4>\n<p><code>org</code>  的大纲显示模式会对不同级标题采用不同颜色显示，但是默认的大纲显示没有缩进，如果想添加缩进显示，可以用 <span class=\"kbd red\">M-x</span>，输入  <code>org-indent-mode</code> 。如果想让某个文件默认用这种方式打开，可以在文件头部增加：</p>\n<pre><code class=\"language-markdown\">#+STARTUP: indent\n</code></pre>\n<pre><code class=\"language-lisp\">(setq org-startup-indented t)\n</code></pre>\n<h2 id=\"段落\"><a class=\"anchor\" href=\"#段落\">#</a> 段落</h2>\n<p>在  <code>org-mode</code>  中需要两个回车来分隔一个段落，这点和  <code>Markdown</code>  一致。</p>\n<h2 id=\"字体\"><a class=\"anchor\" href=\"#字体\">#</a> 字体</h2>\n<pre><code class=\"language-markdown\">*粗体*\n/斜体/\n+删除线+\n_下划线_\n下标： H_2 O\n上标： E=mc^2\n高亮： =git=  或者 ～git～ （在我的终端里显示不同颜色）\n</code></pre>\n<p>这里和  <code>Markdown</code>  有一些差距，有需要的时候查找即可。</p>\n<h2 id=\"列表\"><a class=\"anchor\" href=\"#列表\">#</a> 列表</h2>\n<ul>\n<li>无序列表以  <code>-</code> 、 <code>+</code>  或者  <code>*</code>  开头</li>\n<li>有序列表以  <code>1.</code>  或者  <code>1)</code>  开头</li>\n<li>描述列表用  <code>::</code></li>\n<li>列表层级用缩进体现</li>\n</ul>\n<div class=\"note warning\">\n<p>列表符号后面都要有空格；同级别的列表缩进要相同；空两行之后列表结束；</p>\n</div>\n<p>示例：</p>\n<pre><code class=\"language-markdown\">+ treeroot \n    + branch1\n    + branch2\n\n+ treeroot\n    1) branch1\n    2) branch2\n</code></pre>\n<h3 id=\"快捷键\"><a class=\"anchor\" href=\"#快捷键\">#</a> 快捷键</h3>\n<table>\n<caption id=\"\" style=\"caption-side: bottom\">列表相关功能快捷键</caption>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"kbd red\">TAB</span></td>\n<td>折叠列表项</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-RET</span></td>\n<td>插入项</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-S-RET</span></td>\n<td>插入带复选框的项</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-S-UP/DOWN</span></td>\n<td>移动列表项</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-LEFT/RIGHT</span></td>\n<td>升 / 降级列表项，不包括子项</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-S-LEFT/RIGTH</span></td>\n<td>升 / 降级列表项，包括子项</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c C-c</span></td>\n<td>改变复选框状态</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c -</span></td>\n<td>更换列表标记（循环切换）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"表格\"><a class=\"anchor\" href=\"#表格\">#</a> 表格</h2>\n<p>一个普通表格：</p>\n<pre><code class=\"language-markdown\">#+CAPTION: 表格的标题\n| Name     | Height | Weight | Age |\n|----------+--------+--------+-----|\n| Abcdefgh |    178 |    123 |  18 |\n</code></pre>\n<p>注意表头和表格内容的分隔线和  <code>Markdown</code>  有略微不同。表头之上可以添加表格的标题（可选）。</p>\n<p>对于内容较多的表格，可以设置每一列显示的长度以及对齐方式：</p>\n<pre><code class=\"language-markdown\">| &lt;5&gt;   | &lt;l5&gt;  |  &lt;r5&gt; | &lt;c5&gt;  |\n| Name  | Hei=&gt; | Wei=&gt; | Age   |\n|-------+-------+-------+-------|\n| Ab=&gt;  |       |       |       |\n</code></pre>\n<p>可以在任意一个表格的空白项内输入数字来限制其所在列的长度，可以可以通过  <code>l</code> 、 <code>c</code> 、 <code>r</code>  来设置左中右对齐（默认左对齐）。比如（ <code>=&gt;</code>  代表内容隐藏内容，实际为  <code>Abcedfgh</code>  ）</p>\n<table>\n<caption id=\"\" style=\"caption-side: bottom\">表格相关功能快捷键</caption>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"kbd red\">C-c  <code>|</code> </span></td>\n<td>创建或转换成表格</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c C-c</span></td>\n<td>调整表格，不移动光标</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">TAB</span></td>\n<td>移动到下一区域，必要时新建一行</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">S-TAB</span></td>\n<td>移动到上一区域</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">RET</span></td>\n<td>移动到下一行，必要时新建一行</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-LEFT/RIGHT</span></td>\n<td>移动列</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-UP/DOWN</span></td>\n<td>移动行</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-S-LEFT/RIGHT</span></td>\n<td>删除 / 插入列</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">M-S-UP/DOWN</span></td>\n<td>删除 / 插入行</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c -</span></td>\n<td>添加水平分割线</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c RET</span></td>\n<td>添加水平分割线并跳到下一行</td>\n</tr>\n<tr>\n<td><span class=\"kbd red\">C-c ^</span></td>\n<td>根据当前列排序，可以选择排序方式</td>\n</tr>\n</tbody>\n</table>\n<p>目前表格不支持拆分和合并，只能使用如下格式替代。(本主题中安装的插件可以支持复杂格式的表格，具体参考插件 <a href=\"https://www.npmjs.com/package/markdown-it-multimd-table\"> <code>markdown-it-multimd-table</code> </a>，或者我之前的博客 <a href=\"/Hexo/blog-content-test/\" title=\"Shoka 主题测试\">Shoka 主题测试</a>)</p>\n<pre><code class=\"language-markdown\">| 一级部门 | 二级部门 | 人数 |\n|----------+----------+------|\n| A        | A.1      | 5    |\n|          | A.2      | 6    |\n|----------+----------+------|\n| B        | B.1      | 7    |\n|          | B.2      | 3    |\n</code></pre>\n<h2 id=\"org-roam-配置\"><a class=\"anchor\" href=\"#org-roam-配置\">#</a>  <code>Org-roam</code>  配置</h2>\n<p>在  <code>.emacs.d/lisp/</code>  下创建  <code>init-org-roam.el</code>  文件，并写入以下内容：</p>\n<pre><code class=\"language-lisp\">(use-package org-roam\n  :ensure t\n  :init\n  (setq org-roam-v2-ack t)\n  :custom\n  (make-directory &quot;~/org-roam&quot;)\n  (setq org-roam-db-gc-threshold most-positive-fixnum)\n  (setq org-roam-directory &quot;~/org-roam/&quot;)\n  (setq org-roam-completion-everywhere t)\n  (setq org-roam-v2-ack t)\n  (add-hook 'after-init-hook 'org-roam-mode)\n  :bind ((&quot;C-c n l&quot; . org-roam-buffer-toggle)\n         (&quot;C-c n f&quot; . org-roam-node-find)\n         (&quot;C-c n i&quot; . org-roam-node-insert)\n         :map org-mode-map\n         (&quot;C-M-i&quot; . completion-at-point))\n  :config\n  (org-roam-setup)\n\n  (use-package websocket\n    :ensure t)\n  (use-package simple-httpd\n    :ensure t)\n  (add-to-list 'load-path &quot;~/.emacs.d/site-lisp/org-roam-ui&quot;)\n  (load-library &quot;org-roam-ui&quot;)\n  (use-package org-roam-ui\n    :after org-roam\n    :config\n    (setq org-roam-ui-sync-theme t\n          org-roam-ui-follow t\n          org-roam-ui-follow-mode t\n          org-roam-ui-update-on-save t\n          org-roam-ui-open-on-start t))\n  )\n(use-package deft\n  :ensure t\n  :after org\n  :bind\n  (&quot;C-c n d&quot; . deft)\n  :custom\n  (deft-recursive t)\n  (deft-use-filter-string-for-filename t)\n  (deft-default-extension &quot;org&quot;)\n  (deft-directory org-roam-directory))\n\n(provide 'init-org-roam)\n</code></pre>\n<p>在  <code>init.el</code>  中加入：</p>\n<pre><code class=\"language-lisp\">(require 'use-package)  ;; just for org-roam installation\n(require 'init-org-roam)\n</code></pre>\n<p>注意这里需要安装  <code>use-package</code> ，如果报错，可以在  <code>Emacs</code>  界面中使用 <span class=\"kbd\">M-x package-install RET use-package RET</span> 进行安装。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://www.wenhui.space/docs/02-emacs/emacs_org_mode/#%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2\">emacs org-mode 的使用</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Emacs"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Emacs/emacs-learning-2/",
            "url": "https://linn-ylz.com/Computer-Science/Emacs/emacs-learning-2/",
            "title": "Emacs 学习（二）配置自定义及插件",
            "date_published": "2022-01-09T08:20:07.000Z",
            "content_html": "<h1 id=\"基础-elisp\"><a class=\"anchor\" href=\"#基础-elisp\">#</a> 基础  <code>ELisp</code></h1>\n<p>因为本科捣鼓过一点  <code>Lisp</code>  相关的东西，这里就放些简单例子，有需要再详细学习。</p>\n<pre><code class=\"language-lisp\">;; 2 + 2\n(+ 2 2)\n\n;; 2 + 3 * 4\n(+ 2 (* 3 4))\n\n;; 定义变量\n(setq name &quot;username&quot;)\n(message name) ; -&gt; &quot;username&quot;\n\n;; 定义函数\n(defun func ()\n  (message &quot;Hello, %s&quot; name))\n\n;; 执行函数\n(func) ; -&gt; Hello, username\n\n;; 设置快捷键\n(global-set-key (kbd &quot;&lt;f1&gt;&quot;) 'func)\n\n;; 使函数可直接被调用可添加 (interactive)\n(defun func ()\n  (interactive)\n  (message &quot;Hello, %s&quot; name))\n</code></pre>\n<h2 id=\"循环\"><a class=\"anchor\" href=\"#循环\">#</a> 循环</h2>\n<pre><code class=\"language-lisp\">;; 遍历每一个缓冲区（Buffer）\n(cl-loop for buf in (buffer-list)\n\t collect (buffer-file-name buf))\n\n;; 寻找 729 的平方根（设置最大为 100 为了防止无限循环）\n(cl-loop for x from 1 to 100\n\t for y = (* x x)\n\t until (&gt;= y 729)\n\t finally return (list x (= y 729)))\n</code></pre>\n<h2 id=\"quote\"><a class=\"anchor\" href=\"#quote\">#</a> quote</h2>\n<pre><code class=\"language-lisp\">;; 下面两行的效果完全相同的\n(quote foo)\n'foo\n\n(print '(+ 1 1)) ;; -&gt; (+ 1 1)\n(print (+ 1 1))  ;; -&gt; 2\n</code></pre>\n<h1 id=\"配置\"><a class=\"anchor\" href=\"#配置\">#</a> 配置</h1>\n<h2 id=\"前置知识\"><a class=\"anchor\" href=\"#前置知识\">#</a> 前置知识</h2>\n<p><code>Emacs</code>  的配置文件默认保存在  <code>~/.emacs.d/init.el</code>  文件中。（如果其不存在可自行创建， 配置文件也可保存在  <code>~/.emacs</code>  文件中，通常  <code>~/.emacs</code>  的优先级更高）。</p>\n<div class=\"note warning\">\n<p>注意： 如果希望把配置放在～/.emacs.d/init.el 文件中，那么需要手工删除～/.emacs 文件。</p>\n</div>\n<p>为了便于管理，我们采用模块化的方式来存储我们的配置文件。</p>\n<p>一般  <code>~/.emacs.d/</code>  目录中的结构如下：</p>\n<pre><code class=\"language-bash\">├── auto-save-list # 自动生成的保存数据\n├── elpa           # 下载的插件目录\n├── init.el        # 我们的配置文件\n└── recentf        # 最近访问的文件列表\n</code></pre>\n<p>通常我们只保存配置文件并对其进行版本控制，其他的插件均在第一次使用编辑器时再通过网络重新下载。</p>\n<p>由于  <code>Elisp</code>  中并没有命名空间（Namespace），所有的变量均为全局变量，所以其命名方法就变的非常重要。一种简单的命名规则如下：</p>\n<pre><code class=\"language-bash\">#自定义变量可以使用自己的名字作为命名方式（可以是变量名或者函数名）\nmy/XXXX\n\n#模式命名规则\nModeName-mode\n\n#模式内的变量则可以使用\nModeName-VariableName\n</code></pre>\n<p>通常情况使用一个  <code>init.el</code>  文件便足以存储配置的内容，但是当配置内容较多时，使用模块化的设计更加便于管理。我们通常可以将配置文件分为以下几个部分：</p>\n<pre><code class=\"language-bash\">init-packages.el        # 插件管理\ninit-ui.el              # 视觉层配置\ninit-better-defaults.el # 增强内置功能\ninit-keybindings.el     # 快捷键绑定\ninit-org.el             # Org 模式相关的全部设定\ncustome.el              # 存放使用编辑器接口产生的配置信息\n</code></pre>\n<p>在目录中的结构如下：</p>\n<pre><code class=\"language-bash\">├── init.el\n└── lisp\n    ├── custom.el\n    ├── init-better-defaults.el\n    ├── init-helper.el\n    ├── init-keybindings.el\n    ├── init-packages.el\n    ├── init-ui.el\n    └── init-org.el\n</code></pre>\n<p>此时  <code>init.el</code>  是所有配置内容的入口，我们可以快速定位想要更改的配置的位置。</p>\n<h2 id=\"major-mode-与-minor-mode\"><a class=\"anchor\" href=\"#major-mode-与-minor-mode\">#</a> Major Mode 与 Minor Mode</h2>\n<p><code>Emacs</code>  中存在 Major Mode 与 Minor Mode 两种 Mode。Major Mode 通常定义对于一种文件类型编辑的核心规则，例如语法高亮、缩进、快捷键绑定等。 而 Minor Mode 是除去 Major Mode 所提供的核心功能以外的额外的编辑功能（辅助功能）。例如在下面的配置文件中  <code>tool-bar-mode</code>  与  <code>linum-mode</code>  等均为 Minor Mode。</p>\n<p>一种文件类型同时只能存在一种 Major Mode，但是它可以同时激活一种或多种 Minor Mode。如果想知道当前的模式信息，可以使用 <span class=\"kbd\">C-h m</span> 来显示当前所有开启的全部的 Minor Mode 的信息。</p>\n<p>在  <code>Emacs</code>  中，Major Mode 又分为三种，</p>\n<ul>\n<li><code>text-mode</code> ，用于编辑文本文件；</li>\n<li><code>special-mode</code> ，特殊模式（很少见）；</li>\n<li><code>prog-mode</code> ，所有的编程语言的父模式；</li>\n</ul>\n<p>在每一个模式（mode）中它的名称与各个变量还有函数都有特定的命名规则，比如所有的模式都被命名为  <code>ModeName-mode</code> ，里面所设置的快捷键则为  <code>ModeName-mode-key-map</code> ，而所有的钩子则会被命名为  <code>ModeName-mode-hook</code> 。</p>\n<h2 id=\"插件包配置\"><a class=\"anchor\" href=\"#插件包配置\">#</a> 插件包配置</h2>\n<p>在  <code>./lisp/init-packages.el</code>  中写入以下内容：</p>\n<pre><code class=\"language-lisp\">;;  __        __             __   ___\n;; |__)  /\\  /  ` |__/  /\\  / _` |__\n;; |    /~~\\ \\__, |  \\ /~~\\ \\__&gt; |___\n;;                      __   ___        ___      ___\n;; |\\/|  /\\  |\\ |  /\\  / _` |__   |\\/| |__  |\\ |  |\n;; |  | /~~\\ | \\| /~~\\ \\__&gt; |___  |  | |___ | \\|  |\n(when (&gt;= emacs-major-version 24)\n    (require 'package)\n    (package-initialize)\n    (setq package-archives '((&quot;gnu&quot;   . &quot;http://elpa.emacs-china.org/gnu/&quot;)\n\t\t\t (&quot;melpa&quot; . &quot;http://elpa.emacs-china.org/melpa/&quot;))))\n\n;; cl - Common Lisp Extension\n(require 'cl)\n\n;; Add Packages\n(defvar my/packages '(\n    ;; --- Auto-completion ---\n    company\n    ;; --- Better Editor ---\n    smooth-scrolling\n    hungry-delete\n    swiper\n    counsel\n    smartparens\n    popwin\n    ;; --- Major Mode ---\n    js2-mode\n    markdown-mode\n\n;; ...\n\n;; 文件末尾\n(provide 'init-packages)\n</code></pre>\n<p>在  <code>init.el</code>  中的入口内容如下：</p>\n<pre><code class=\"language-lisp\">(package-initialize)\n\n(add-to-list 'load-path &quot;~/.emacs.d/lisp/&quot;)\n\n;; Package Management\n;; -----------------------------------------------------------------\n(require 'init-packages)\n</code></pre>\n<p>从以上内容我们可以简单总结出配置模块化的一个方法。首先将某部分内容的配置写入相关的文件中，然后和在文件的末尾添加  <code>(provide 'module-name)</code>  以使得其在入口文件中能够被调用。而在入口文件中，我们首先添加  <code>(add-to-list 'load-path &quot;~/.emacs.d/lisp/&quot;)</code> ，从而使得程序能够找到配置文件的位置，然后写入  <code>(require 'module-name)</code>  便能够引入相关配置。</p>\n<h2 id=\"配置推荐\"><a class=\"anchor\" href=\"#配置推荐\">#</a> 配置推荐</h2>\n<p>对于  <code>Emacs</code>  初学者而言，陷入到配置文件的细节中往往会打消其学习的热情。这里推荐一个比较成熟的配置。<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<p>这是 purcell 开源的一套配置，在  <code>GitHub</code>  上目前有超过 6k 个 star，且目前依旧保持更新。</p>\n<p>通过命令：</p>\n<pre><code class=\"language-bash\">git clone https://github.com/purcell/emacs.d.git ~/.emacs.d\n</code></pre>\n<p>将仓库克隆下来，然后就可以直接使用了。这里需要对  <code>init.el</code>  做些微修改，更换插件源为  <code>Emacs China</code>  中文社区的镜像。由于配置的内容较多，初次打开  <code>Emacs</code>  时需要等待一段时间下载并应用插件。</p>\n<p>如果有自己想要定义的配置，那么可以自己新建一个  <code>.el</code>  文件，按照前文模块化配置的方式加入自己所需的配置。</p>\n<h1 id=\"中文乱码问题\"><a class=\"anchor\" href=\"#中文乱码问题\">#</a> 中文乱码问题</h1>\n<p><code>Emacs</code>  的 GUI 模式不能很好的支持中文。通过  <code>emacs -nw</code>  可以在终端界面显示  <code>Emacs</code>  的界面，这个和  <code>Vim</code>  的显示方式比较相似，且无中文支持的问题。可以在  <code>.bashrc</code>  之类的文件中通过  <code>alias emacs=emacs -nw</code>  来默认终端方式启动。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://github.com/purcell/emacs.d\"> <code>Emacs</code>  配置推荐</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Emacs"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Emacs/emacs-learning-1/",
            "url": "https://linn-ylz.com/Computer-Science/Emacs/emacs-learning-1/",
            "title": "Emacs 学习（一）基本操作",
            "date_published": "2022-01-09T08:13:51.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>本系列内容基于  <code>Emacs China</code>  提供的教程<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n<p><code>Emcas</code>  的深入学习可以阅读  <code>GNU</code>  提供的教程<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>。</p>\n<h1 id=\"预备说明\"><a class=\"anchor\" href=\"#预备说明\">#</a> 预备说明</h1>\n<table>\n<caption id=\"\" style=\"caption-side: bottom\">重要快捷键缩写</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C</span></td>\n<td style=\"text-align:left\"><span class=\"kbd red\">Ctrl</span> 键</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">S</span></td>\n<td style=\"text-align:left\"><span class=\"kbd red\">Shift</span> 键</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M</span></td>\n<td style=\"text-align:left\"><span class=\"kbd red\">Alt</span> 键</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">RET</span></td>\n<td style=\"text-align:left\"><span class=\"kbd red\">Enter</span> 键</td>\n</tr>\n</tbody>\n</table>\n<p><span class=\"kbd red\">C-x</span> <span class=\"kbd red\">d</span> <span class=\"kbd red\">RET</span> 代表先同时按下 <span class=\"kbd red\">Ctrl</span> 和 <span class=\"kbd red\">x</span>，再按下 <span class=\"kbd red\">d</span>，最后再按下 <span class=\"kbd red\">RET</span>。</p>\n<p><code>Emacs</code>  里的大部分地方都支持自动补全，快捷键是 <span class=\"kbd red\">TAB</span></p>\n<h1 id=\"快捷键\"><a class=\"anchor\" href=\"#快捷键\">#</a> 快捷键</h1>\n<h2 id=\"光标移动\"><a class=\"anchor\" href=\"#光标移动\">#</a> 光标移动</h2>\n<table>\n<caption id=\"1\" style=\"caption-side: bottom\">光标移动快捷键 1</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-f</span></td>\n<td style=\"text-align:left\">前移一个字符，<span class=\"kbd red\">f</span> 代表 forward；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-b</span></td>\n<td style=\"text-align:left\">后移一个字符，<span class=\"kbd red\">b</span> 代表 backward；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-f</span></td>\n<td style=\"text-align:left\">前移一个 word；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-b</span></td>\n<td style=\"text-align:left\">后移一个 word；</td>\n</tr>\n</tbody>\n</table>\n<table>\n<caption id=\"2\" style=\"caption-side: bottom\">光标移动快捷键 2</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-p</span></td>\n<td style=\"text-align:left\">上移至前一行，<span class=\"kbd red\">p</span> 代表 previous；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-n</span></td>\n<td style=\"text-align:left\">上移至下一行，<span class=\"kbd red\">n</span> 代表 next；</td>\n</tr>\n</tbody>\n</table>\n<table>\n<caption id=\"3\" style=\"caption-side: bottom\">光标移动快捷键 3</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-a</span></td>\n<td style=\"text-align:left\">移至行首，<span class=\"kbd red\">a</span> 代表 ahead；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-e</span></td>\n<td style=\"text-align:left\">移至行尾，<span class=\"kbd red\">e</span> 代表 end；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-a</span></td>\n<td style=\"text-align:left\">前移一个 sentence；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-e</span></td>\n<td style=\"text-align:left\">后移一个 sentence；</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"屏幕移动\"><a class=\"anchor\" href=\"#屏幕移动\">#</a> 屏幕移动</h2>\n<table>\n<caption id=\"4\" style=\"caption-side: bottom\">屏幕移动快捷键 4</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-v</span></td>\n<td style=\"text-align:left\">屏幕向下滚动一页，类似于键盘中的 <span class=\"kbd red\">PgUp</span>；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-v</span></td>\n<td style=\"text-align:left\">屏幕向上滚动一页，类似于键盘中的 <span class=\"kbd red\">PgDown</span></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-l</span></td>\n<td style=\"text-align:left\">屏幕光标内容居中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-&lt;</span></td>\n<td style=\"text-align:left\">光标移动到文件最开始的位置，注意 <span class=\"kbd red\">&lt;</span> 需要按住 <span class=\"kbd red\">Shift</span> 键，所以实际上是按住三个键；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-&gt;</span></td>\n<td style=\"text-align:left\">光标移动到文件最末尾的位置，同上，需要按住 <span class=\"kbd red\">Shift</span> 键；</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"接收数字作为参数\"><a class=\"anchor\" href=\"#接收数字作为参数\">#</a> 接收数字作为参数</h2>\n<p>上述很多命令均只能移动一个字符、一个 word 或者一个 sentence。在按下按键之前，先按下 <span class=\"kbd red\">C-u</span>，再输入一个数字之后，再按下上述命令，则可以移动更多数量的单位。</p>\n<p>例如：<span class=\"kbd red\">C-u 8 C-f</span> 向前移动 8 个字符。</p>\n<h2 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h2>\n<p>打断组合键为 <span class=\"kbd red\">C-g</span> ，它用于终端取消之前的指令。</p>\n<p>编辑器内显示行号可使用 <span class=\"kbd red\">M-x</span>  <code>linum-mode</code>  来开启。</p>\n<h1 id=\"文本编辑操作\"><a class=\"anchor\" href=\"#文本编辑操作\">#</a> 文本编辑操作</h1>\n<p>插入和通常编辑器的文本输入一样。<span class=\"kbd red\">RET</span> 表示回车键 <span class=\"kbd red\">Enter</span>，用于换行。</p>\n<p>使用 <span class=\"kbd red\">DEL</span> 删除，它表示 <span class=\"kbd red\">Backspace</span> 键。这一点也和通常的文本编辑器相同。</p>\n<p>以上这两点是我想要改用  <code>Emacs</code>  的原因，之前尝试深入学习过  <code>Vim</code> ，但是切换模式这种操作方式，让我这种用习惯了普通编辑器的人很不适应。快捷键倒是可以多用多记，但是操作习惯要改变还是很难的，何况平常打字都是这种习惯。因此， <code>Emacs</code>  这种类似于普通编辑器的快捷键方式更符合我自身的习惯。</p>\n<p>除此之外，还有更高级的一些插入和删除方式。</p>\n<h2 id=\"插入\"><a class=\"anchor\" href=\"#插入\">#</a> 插入</h2>\n<p>上文中有提到 <span class=\"kbd red\">C-u 8 C-f</span> 这种形式的命令，普通文本的插入也可以使用这种方式。向编写  <code>C++</code>  代码，添加注释的时候，可能会插入很多个  <code>*</code>  号，使用 <span class=\"kbd red\">C-u 8 *</span> 就可以插入 8 个  <code>*</code>  号。</p>\n<h2 id=\"删除\"><a class=\"anchor\" href=\"#删除\">#</a> 删除</h2>\n<table>\n<caption id=\"1\" style=\"caption-side: bottom\">删除快捷键 1</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">DEL</span></td>\n<td style=\"text-align:left\">删除（Delete）光标前的一个字符；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-d</span></td>\n<td style=\"text-align:left\">删除光标后的一个字符；</td>\n</tr>\n</tbody>\n</table>\n<table>\n<caption id=\"2\" style=\"caption-side: bottom\">删除快捷键 2</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-DEL</span></td>\n<td style=\"text-align:left\">剪切（Kill）光标当前所在 word 的起始位置到光标位置的字符；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-d</span></td>\n<td style=\"text-align:left\">剪切光标到光标当前所在 word 的终止位置的字符；</td>\n</tr>\n</tbody>\n</table>\n<table>\n<caption id=\"3\" style=\"caption-side: bottom\">删除快捷键 3</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-k</span></td>\n<td style=\"text-align:left\">剪切光标到当前行末尾的所有字符；（不包含换行符）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">M-k</span></td>\n<td style=\"text-align:left\">剪切光标到当前句子末尾的所有字符；（他们的差别类似于 <span class=\"kbd red\">C-e</span> 和 <span class=\"kbd red\">M-e</span>）</td>\n</tr>\n</tbody>\n</table>\n<p>对一个非空行使用 <span class=\"kbd red\">C-k</span> 并不会剪切该行的换行符，此时如果再按下一次，则换行符也被剪切掉，而  <code>Windows</code>  中通常的 <span class=\"kbd red\">Ctrl-x</span> 则直接包含换行符。</p>\n<p>如果在 <span class=\"kbd red\">C-k</span> 前接上 <span class=\"kbd red\">C-u 2</span> 这样的内容，则表示剪切多行，并且<ins class=\"danger\">包含</ins>换行符。这个连续按多次 <span class=\"kbd red\">C-k</span> 是不一样的。</p>\n<p>另一点不同则是，在同一行连续使用 <span class=\"kbd red\">C-k</span>，多次剪切的内容会存储在一起，在粘贴的时候所有内容会一并粘贴。</p>\n<p><code>Emacs</code>  文档中使用 Delete 表示删除，Kill 表示剪切的含义。</p>\n<h2 id=\"选中\"><a class=\"anchor\" href=\"#选中\">#</a> 选中</h2>\n<p>在想要选中的起始位置按下 <span class=\"kbd red\">C-SPC</span>，即 <span class=\"kbd red\">Ctrl</span> 和 <span class=\"kbd red\">Space</span> 键，此时底部信息栏会显示  <code>Mark set</code> ，表示进入选中模式；移动光标直到其包含所有想要选中的内容，按下 <span class=\"kbd red\">C-w</span> 会将选中的文本剪切。使用 <span class=\"kbd red\">M-w</span> 则是进行复制。</p>\n<h2 id=\"粘贴\"><a class=\"anchor\" href=\"#粘贴\">#</a> 粘贴</h2>\n<p><code>Emacs</code>  中使用 yank 表示粘贴，使用 <span class=\"kbd red\">C-y</span> 进行粘贴操作。</p>\n<p>如果想要粘贴的内容不是最近剪切的，那么使用 <span class=\"kbd red\">M-y</span> 可以对粘贴的内容进行替换，连续按下便会一直替换，直到又重新循环到最近剪切的内容。</p>\n<p>而 <span class=\"kbd red\">M-y</span> 还可以添加正整数或者负整数作为参数，选择粘贴的内容。</p>\n<h2 id=\"搜索\"><a class=\"anchor\" href=\"#搜索\">#</a> 搜索</h2>\n<p><code>Emacs</code>  搜索是增量式（incremental）的，当输入内容时即开始搜索。使用 <span class=\"kbd red\">C-s</span> 向前跳转，使用 <span class=\"kbd red\">C-r</span> 向后跳转。按下回车将会终止搜索，<span class=\"kbd red\">C-g</span> 同样能够终止搜索。</p>\n<h2 id=\"撤销\"><a class=\"anchor\" href=\"#撤销\">#</a> 撤销</h2>\n<p><span class=\"kbd red\">C-/</span> 用于撤销。连续使用多次则可以逐次撤回过往的编辑内容。<span class=\"kbd red\">C-_</span> 与 <span class=\"kbd red\">C-/</span> 等价。<span class=\"spoiler\" title=\"你知道得太多了\">但是这个按键位置有点奇怪...</span></p>\n<p><span class=\"kbd red\">C-x u</span> 也是撤销功能，但是需要按两次按键，不那么方便。</p>\n<h2 id=\"文件操作\"><a class=\"anchor\" href=\"#文件操作\">#</a> 文件操作</h2>\n<p><code>Emacs</code>  界面底部的信息栏左下角，显示当前编辑的文件名称。</p>\n<table>\n<caption id=\"1\" style=\"caption-side: bottom\">文件操作快捷键 1</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-x C-f</span></td>\n<td style=\"text-align:left\">打开目标文件， f 代表 find/file；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-x C-s</span></td>\n<td style=\"text-align:left\">保存当前缓冲区（Buffer）， s 代表 save。</td>\n</tr>\n</tbody>\n</table>\n<p><span class=\"kbd red\">C-x</span> 是  <code>Emacs</code>  的快捷键中常用的前缀命令。其它常见的还有 <span class=\"kbd red\">C-c</span>, <span class=\"kbd red\">C-h</span>。</p>\n<p><code>Emacs</code>  存储文件时，会临时在原文件名称的末尾添加  <code>~</code>  后缀（这点和  <code>Office</code>  有些类似），以防止原文件丢失。</p>\n<h2 id=\"缓冲区\"><a class=\"anchor\" href=\"#缓冲区\">#</a> 缓冲区</h2>\n<p>如果我们在已有打开文件的同时，打开一个新的文件，之前的文件仍旧保留在  <code>Emacs</code>  的缓冲区之中。此时可以通过 <span class=\"kbd red\">C-x C-f</span> 指令切换到该文件（就是打开目标文件的指令）。</p>\n<p>使用 <span class=\"kbd red\">C-x C-b</span> 可以查看当前的缓冲区列表。再使用 [C-x 1] 可以退出缓冲区列表界面。</p>\n<p>当有多个缓冲区希望保存时，可以使用 {C-x s}{.kbd .red}，此时  <code>Emacs</code>  会对每个发生了修改的缓冲区进行询问，我们可以选择是否保存该缓冲区。</p>\n<h2 id=\"关闭-emacs\"><a class=\"anchor\" href=\"#关闭-emacs\">#</a> 关闭  <code>Emacs</code></h2>\n<p>使用 <span class=\"kbd red\">C-x C-c</span> 关闭  <code>Emacs</code> ，在关闭前，会询问是否真的要关闭软件。</p>\n<h1 id=\"扩展指令集\"><a class=\"anchor\" href=\"#扩展指令集\">#</a> 扩展指令集</h1>\n<p><code>Emacs</code>  可以使用 <span class=\"kbd red\">C-x</span> 或者 <span class=\"kbd red\">M-x</span> 使用扩展指令，<span class=\"kbd red\">C-x</span> 接续一个按键指令，而 <span class=\"kbd red\">M-x</span> 则接续一个较长的命令名称，通常用于使用频率较少的指令。</p>\n<p>对于 <span class=\"kbd red\">M-x</span> 执行的指令，可以通过 <span class=\"kbd red\">Tab</span> 进行补全。</p>\n<h1 id=\"窗口\"><a class=\"anchor\" href=\"#窗口\">#</a> 窗口</h1>\n<p>在分屏操作之前，先学习一个新的命令 <span class=\"kbd red\">C-x 1</span>，它将当前光标所在窗口最大化，并关闭其他所有窗口。</p>\n<p><span class=\"kbd red\">C-x 2</span> 在窗口底部创建一个新的子窗口。通过 <span class=\"kbd red\">C-x o</span> 可以在不同窗口之间进行切换，o 在这里表示 other。可以通过 <span class=\"kbd red\">C-M-S-v</span> 使得另一个窗口的内容向下滚动，而不需要切换窗口。</p>\n<p><span class=\"kbd red\">C-x 3</span> 则是在当前窗口右侧创建一个新的子窗口。</p>\n<p><span class=\"kbd red\">C-x 5 2</span> 可以创建一个新的窗口，<span class=\"kbd red\">C-x 5 0</span> 可以关闭当前光标所在窗口。当我们较慢速度输入指令的时候，可以看到其他可用的指令，这是只需要按下对应的按键即可。</p>\n<h2 id=\"获取帮助\"><a class=\"anchor\" href=\"#获取帮助\">#</a> 获取帮助</h2>\n<p><code>Emacs</code>  是一个富文档编辑器（Self document, extensible editor），而下面的三种方法在学习 Emacs 的过程中也非常重要。他们分别是：</p>\n<table>\n<caption id=\"\" style=\"caption-side: bottom\">帮助相关快捷键</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-h c</span></td>\n<td style=\"text-align:left\">显示快捷键的功能；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-h k</span></td>\n<td style=\"text-align:left\">寻找快捷键对应函数的文档；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-h v</span></td>\n<td style=\"text-align:left\">寻找变量的帮助信息；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"kbd red\">C-h f</span></td>\n<td style=\"text-align:left\">寻找函数的帮助信息；</td>\n</tr>\n</tbody>\n</table>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://book.emacs-china.org/\">Emacs 教程</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://www.gnu.org/software/emacs/manual/html_mono/eintr.html\">An Introduction to Programming in Emacs Lisp</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Emacs"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Programming-Pearls/chapter-1-cracking-the-oyster/",
            "url": "https://linn-ylz.com/Computer-Science/Programming-Pearls/chapter-1-cracking-the-oyster/",
            "title": "《编程珠玑》（一）——开篇",
            "date_published": "2022-01-09T07:42:58.000Z",
            "content_html": "<p>本章内容以作者的一次经历为线索，介绍了他解决问题时的一些思路，并总结了遇到问题时的一些思考原理。同时，作者也简要介绍了归并排序相关的一些内容。</p>\n<h1 id=\"一次友好的对话\"><a class=\"anchor\" href=\"#一次友好的对话\">#</a> 一次友好的对话</h1>\n<p>下文的斜体内容为作者朋友的回答，其余内容为作者所说的内容。J 表示作者，F 表示作者的朋友。</p>\n<hr />\n<p>J：为什么需要自己编写排序代码，而不使用库提供的排序函数？</p>\n<p>F：<em>我需要在一个大系统中进行排序，由于不明的原因，无法调用库函数进行排序。</em></p>\n<p>J：需要排序的内容是什么？文件中有多少条记录？每条记录的格式是怎么样的？</p>\n<p>F：<em>文件最多包含 1000 万条记录，每条记录都是 7 位的整数。</em></p>\n<p>J：既然文件这么小，为什么不在内存中而在磁盘上进行排序呢？</p>\n<p>F：<em>排序功能是大系统中的一部分，到时只有  <code>1 MB</code>  的内存可用。</em></p>\n<p>J：还有什么其他信息吗？</p>\n<p>F：<em>每条记录都是 7 位数的整数，无其他数据。每个整数最多只出现一次。</em></p>\n<hr />\n<p>作者通过上述对话了解程序运行的系统信息，以及处理的数据类型和数值范围，这对于后续程序的编写可以提供很大的帮助。</p>\n<p>在当时，美国的电话号码由 3 位区号和后续的 7 位号码组成，拨打 800 免费区号开头的号码则是免费的。这位朋友应该正在开发这类数据库处理系统的号码排序功能。这个应用背景也定义了相应的性能需求，当与系统的会话时间较长时，用户大约每小时请求一次有序文件，并且需要在排序完成之前一直等待。因此，排序最多只允许耗时几分钟来执行排序，10 秒是比较理想的运行时间。</p>\n<h1 id=\"准确的问题描述\"><a class=\"anchor\" href=\"#准确的问题描述\">#</a> 准确的问题描述</h1>\n<ul>\n<li>输入：一个最多包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个正整数的文件，每个数都小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>10</mn><mn>7</mn></msup></mrow><annotation encoding=\"application/x-tex\">n=10^7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span>。如果在输入中包含重复的整数，算作  <code>Fatal Error</code> ；</li>\n<li>输出：按升序排列的输入整数的列表；</li>\n<li>约束：最多有大约  <code>1 MB</code>  的内存空间可用，有充足的磁盘空间可用。运行时间最多几分钟，运行时间为 10 秒左右时不需要进一步的优化。</li>\n</ul>\n<h1 id=\"程序设计\"><a class=\"anchor\" href=\"#程序设计\">#</a> 程序设计</h1>\n<p>显而易见的方法是以一般的基于磁盘的归并排序程序为起点，对其进行一定调整后能够在几十行的代码之内完成需求，但是程序可能需要几天的时间运行（以作者当时的设备而言）。</p>\n<p>另一种方案则是利用改排序问题的特殊性，任务中需要排序的号码是 7 位数。</p>\n<ul>\n<li>如果使用字符串存储，那么每个数据需要 7 字节来存储，那么  <code>1 MB</code>  的空间可以存储大约 143 000 个号码。归并排序需要额外的空间储存中间的数组结果，而内存空间不足以存放额外的数据，因此还需要将中间结果存储到其他的文件中（称为工作文件）。即排序过程中需要多次读写工作文件。而输入文件和输出文件则只读取和写入一次；</li>\n<li>如果使用 32 位整数来表示的话， <code>1 MB</code>  的空间可以存储 250 000 个号码；需要读取输入文件 40 次来完成排序。第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 次读取从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>×</mo><mn>250000</mn></mrow><annotation encoding=\"application/x-tex\">i \\times 250 000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">250000</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mn>250000</mn></mrow><annotation encoding=\"application/x-tex\">(i + 1) \\times 250 000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">250000</span></span></span></span> 之间的数字，进行排序后输出。所有的数字只需要输出一次。</li>\n</ul>\n<p>如果有一种排序能够只读取输入文件一次，写入输出文件一次，并且能够在  <code>1 MB</code>  的空间限制条件下完成排序，那么它应当就是我们能够找到的最佳方案了。那么问题的关键就在于能否用大约 800 万个可用位来表示最多 1000 多万个互不相同的整数。</p>\n<h1 id=\"实现概要\"><a class=\"anchor\" href=\"#实现概要\">#</a> 实现概要</h1>\n<p>若想要达成这个目标，需要利用位图或者位向量来表示输入数据的集合。例如，用一个 20 位的位图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 来表示所有元素都小于 20 的简单的非负整数集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>13</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">S = \\{1, 2, 3, 5, 8, 13\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">13</span><span class=\"mclose\">}</span></span></span></span>，则可以用  <code>0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0</code>  来表示。即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo stretchy=\"false\">[</mo><mi>S</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">G[S[i]]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]]</span></span></span></span> 设置为 1。</p>\n<p>在这个问题中，我们使用 1000 万个位的空间来表示这个文件中的数据。其中，当且仅当整数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 在文件中存在时，第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 位为 1。这种表示利用了输入数据的性质：</p>\n<ul>\n<li>输入数据在某一个范围之内；</li>\n<li>输入数据没有重复；</li>\n<li>输入数据没有其他任何关联数据。</li>\n</ul>\n<p>假定  <code>bit</code>  表示该位图，则可以分为三个阶段来编写程序：</p>\n<pre><code class=\"language-cpp\">/* Phase 1: Initialize set to empty */\nfor i = [0, n)\n    bit[i] = 0\n/* Phase 2: Insert present elements into the set */\nfor each i in the input file\n    bit[i] = 1\n/* Phase 3: Write sorted output */\nfor i = [0, n)\n    if bit[i] == 1\n        write i on the output file\n</code></pre>\n<h1 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h1>\n<p>从作者的朋友将他的问题进行说明，并花费了一刻钟明确了问题的关键所在之后，他花了几个小时完成了这个排序程序。最后的结果远远比预期的效果更好。</p>\n<p>从这些事实中可以总结出该实例研究所得到的第一个结论：对小问题的仔细分析有时可以得到明显的实际益处。该实例阐明了如下的一般原理：</p>\n<ul>\n<li>正确的问题</li>\n<li>位图数据结构</li>\n<li>多趟算法</li>\n<li>时间 - 空间折衷与双赢</li>\n<li>简单的设计</li>\n</ul>\n<blockquote>\n<p>设计者确定其设计已经达到了完美的标准不是不能再增加任何东西，而是不能减少任何东西。—— Antoine de Saint-Exupery (法国作家兼飞机设计师)</p>\n</blockquote>\n<h1 id=\"习题\"><a class=\"anchor\" href=\"#习题\">#</a> 习题</h1>\n<h2 id=\"一\"><a class=\"anchor\" href=\"#一\">#</a> 一</h2>\n<div class=\"note primary\">\n<p>如果不缺内存，如何使用一个具有库的语言来实现一种排序算法以表示和排序集合？</p>\n</div>\n<p>使用  <code>C++</code>  实现算法，可以直接使用  <code>set</code>  数据结构。 <code>set</code>  在数据插入时会自动按照一定的顺序插入，直接遍历输出便能够得到有序的集合。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n    set&lt;int&gt; S&#123;5, 7, 10, 2, 3, 1, 4, 9, 6, 8&#125;;\n    for (int num : S) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<p>或者使用  <code>unordered_set</code> ，通过  <code>sort</code>  函数对集合进行排序。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;unordered_set&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main() &#123;\n    unordered_set&lt;int&gt; S&#123;5, 7, 10, 2, 3, 1, 4, 9, 6, 8&#125;;\n    sort(S.begin(), S.end());\n    for (int num : S) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<p>当然如果要自己实现排序算法的话，可以实现一个简单的快速排序算法。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;random&gt;\n\nusing namespace std;\n\nint partition(vector&lt;int&gt;&amp; arr, int start, int end) &#123;\n    int index = start + (rand() % (end - start));\n    swap(arr[start], arr[index]);\n    int pivot = arr[start];\n    int left = start, right = end - 1;\n    while (left &lt; right) &#123;\n        while (left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123;\n            --right;\n        &#125;\n        arr[left] = arr[right];\n        while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;\n            ++left;\n        &#125;\n        arr[right] = arr[left];\n    &#125;\n    arr[left] = pivot;\n    return left;\n&#125;\n\nvoid fast_sort_wrapper(vector&lt;int&gt;&amp; arr, int start, int end) &#123;\n    if (start &gt;= end) &#123;\n        return;\n    &#125;\n    int mid = partition(arr, start, end);\n    fast_sort_wrapper(arr, start, mid);\n    fast_sort_wrapper(arr, mid + 1, end);\n&#125;\n\nvoid fast_sort(vector&lt;int&gt;&amp; arr) &#123;\n    fast_sort_wrapper(arr, 0, arr.size());\n&#125;\n</code></pre>\n<h2 id=\"二\"><a class=\"anchor\" href=\"#二\">#</a> 二</h2>\n<div class=\"note primary\">\n<p>如何使用位逻辑运算（如与、或、移位）来实现位向量？</p>\n</div>\n<h3 id=\"库实现\"><a class=\"anchor\" href=\"#库实现\">#</a> 库实现</h3>\n<p><code>C++</code>  提供了  <code>bitset</code>  数据结构，可以很方便地利用其实现位向量。使用时需要包含  <code>&lt;bitset&gt;</code>  头文件。以下内容参考自  <code>Cppreference</code>  中  <code>bitset</code>  的相关内容。<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<p><code>bitset</code>  数据结构是一个包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 比特的固定长度的序列。 <code>bitset</code>  可以进行标准的逻辑运算，可以和  <code>string</code>  和  <code>integer</code>  类型进行相互转换。</p>\n<p>其定义为：</p>\n<pre><code class=\"language-cpp\">#include &lt;bitset&gt;\ntemplate &lt;std::size_t N&gt;\nclass bitset;\n</code></pre>\n<p>其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 表示分配的比特的数量。需要注意的是，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 的值在编译期间无法确定，那么推荐使用  <code>std::vector&lt;bool&gt;</code> 。</p>\n<p>一段示例程序如下：</p>\n<pre><code class=\"language-cpp\">#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n \nint main()\n&#123;\n    // constructors:\n    constexpr std::bitset&lt;4&gt; b1;\n    constexpr std::bitset&lt;4&gt; b2&#123;0xA&#125;; // == 0B1010\n    std::bitset&lt;4&gt; b3&#123;&quot;0011&quot;&#125;; // can't be constexpr yet\n    std::bitset&lt;8&gt; b4&#123;&quot;ABBA&quot;, /*length*/4, /*0:*/'A', /*1:*/'B'&#125;; // == 0B0000'0110\n \n    // bitsets can be printed out to a stream:\n    std::cout &lt;&lt; &quot;b1:&quot; &lt;&lt; b1 &lt;&lt; &quot;; b2:&quot; &lt;&lt; b2 &lt;&lt; &quot;; b3:&quot; &lt;&lt; b3 &lt;&lt; &quot;; b4:&quot; &lt;&lt; b4 &lt;&lt; '\\n';\n \n    // bitset supports bitwise operations:\n    b3 |= 0b0100; assert(b3 == 0b0111);\n    b3 &amp;= 0b0011; assert(b3 == 0b0011);\n    b3 ^= std::bitset&lt;4&gt;&#123;0b1100&#125;; assert(b3 == 0b1111);\n \n    // operations on the whole set:\n    b3.reset(); assert(b3 == 0);\n    b3.set(); assert(b3 == 0b1111);\n    assert(b3.all() &amp;&amp; b3.any() &amp;&amp; !b3.none());\n    b3.flip(); assert(b3 == 0);\n \n    // operations on individual bits:\n    b3.set(/* position = */ 1, true); assert(b3 == 0b0010);\n    b3.set(/* position = */ 1, false); assert(b3 == 0);\n    b3.flip(/* position = */ 2); assert(b3 == 0b0100);\n    b3.reset(/* position = */ 2); assert(b3 == 0);\n \n    // subscript operator[] is supported:\n    b3[2] = true; assert(true == b3[2]);\n \n    // other operations:\n    assert(b3.count() == 1);\n    assert(b3.size() == 4);\n    assert(b3.to_ullong() == 0b0100ULL);\n    assert(b3.to_string() == &quot;0100&quot;);\n&#125;\n</code></pre>\n<p>最终的运行结果如下：</p>\n<pre><code class=\"language-cpp\">b1:0000; b2:1010; b3:0011; b4:00000110\n</code></pre>\n<p>从上面的示例可以看出， <code>bitset</code>  支持多种初始化方式，并且支持  <code>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</code>  等位运算操作，也可以通过下标对某一特定位置的比特进行访问。常用的一些函数如下：</p>\n<table>\n<caption id=\"bitset\" style=\"caption-side: bottom\">bitset 常用函数表</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">函数名称</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>size</code></td>\n<td style=\"text-align:left\">返回  <code>bitset</code>  中的比特数量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>count</code></td>\n<td style=\"text-align:left\">返回  <code>bitset</code>  中值为  <code>true</code>  的比特数量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>all</code> ,  <code>any</code> ,  <code>none</code></td>\n<td style=\"text-align:left\">检查  <code>bitset</code>  中是否全部、部分、不存在值为  <code>true</code>  的比特</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>set</code></td>\n<td style=\"text-align:left\">设置比特为  <code>true</code>  或者给定值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>reset</code></td>\n<td style=\"text-align:left\">设置所有比特为  <code>false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>flip</code></td>\n<td style=\"text-align:left\">反转所有比特的值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>to_string</code> ,  <code>to_ulong</code> ,  <code>to_ullong</code></td>\n<td style=\"text-align:left\">返回  <code>bitset</code>  对应的  <code>string</code> 、 <code>unsigned long</code> 、 <code>unsigned long long</code>  数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"简易版\"><a class=\"anchor\" href=\"#简易版\">#</a> 简易版</h3>\n<p>当然，我们也可以自己实现一个简易版本的  <code>bitset</code> ，一方面可以加深对位运算的了解；另一方面，后续的习题中也存在需要对  <code>bitset</code>  进行改造的内容，因此自己实现的版本能够方便后续修改。这里只重点关注代码的逻辑实现，对于鲁棒性没有做太高的要求。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nclass bitmap &#123;\npublic:\n    bitmap(size_t n) &#123;\n        size = n;\n        capacity = ceil(n * 1.0 / byte_size);\n        bits = new unsigned char[capacity];\n        memset(bits, 0, capacity);\n    &#125;\n\n    void set(size_t pos, bool val) &#123;\n        size_t major_offset = pos / byte_size;\n        size_t minor_offset = pos % byte_size;\n        unsigned char mask = 0x1 &lt;&lt; (byte_size - minor_offset - 1);\n        if (val) &#123; // 置为 1\n            bits[major_offset] |= mask;\n        &#125; else &#123; // 置为 0\n            bits[major_offset] &amp;= (~mask);\n        &#125;\n    &#125;\n\n    void print() &#123;\n        int major_offset = size / byte_size;\n        int minor_offset = size % byte_size;\n        for (int i = 0; i &lt; major_offset; ++i) &#123;\n            unsigned char val = bits[i];\n            for (int j = byte_size - 1; j &gt;= 0; --j) &#123;\n                cout &lt;&lt; ((val &gt;&gt; j) &amp; 1);\n            &#125;\n            cout &lt;&lt; ' ';\n        &#125;\n        unsigned char val = bits[major_offset - 1];\n        for (int j = byte_size - 1; j &gt; byte_size - 1 - minor_offset; --j) &#123;\n            cout &lt;&lt; ((val &gt;&gt; j) &amp; 1);\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n\nprivate:\n    unsigned char* bits;\n    size_t size;\n    size_t capacity;\n    static const size_t byte_size = 8;\n&#125;;\n\nint main() &#123;\n    bitmap b(10);\n    b.set(1, true);\n    b.set(5, true);\n    b.print();\n    return 0;\n&#125;\n</code></pre>\n<p>输出如下：</p>\n<pre><code class=\"language-cpp\">01000100 01\n</code></pre>\n<p>这里暂时只实现了  <code>set</code>  函数。</p>\n<h2 id=\"三\"><a class=\"anchor\" href=\"#三\">#</a> 三</h2>\n<div class=\"note primary\">\n<p>运行时效率是设计目标的一个重要组成部分，所得到的程序需要足够高效。在你自己的系统上实现位图排序并度量其运行时间。该时间与系统排序的运行时间以及习题 1 中排序的运行时间相比如何？假设 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10000000</mn></mrow><annotation encoding=\"application/x-tex\">10 000 000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10000000</span></span></span></span>，且输入文件包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1000000</mn></mrow><annotation encoding=\"application/x-tex\">1 000 000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1000000</span></span></span></span> 个整数。</p>\n</div>\n<p>这里假定输入是没有重复的整数。其实推荐先查看习题 3，因为这里包含一个生成小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的不重复的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个整数的问题。这里假定已经有这样的方法，并且得到了这样的一个随机整数集合。在习题 2 的自定义的  <code>bitmap</code>  的基础上添加一个  <code>sort</code>  函数：</p>\n<pre><code class=\"language-cpp\">class bitmap &#123;\npublic:\n......\n    void sort() &#123;\n        int major_offset = size / byte_size;\n        int minor_offset = size % byte_size;\n        size_t cnt = 0;\n        for (int i = 0; i &lt; major_offset; ++i) &#123;\n            unsigned char val = bits[i];\n            for (int j = byte_size - 1; j &gt;= 0; --j, ++cnt) &#123;\n                if ((val &gt;&gt; j) &amp; 1) &#123;\n                    cout &lt;&lt; cnt &lt;&lt; ' ';\n                &#125;\n            &#125;\n        &#125;\n        unsigned char val = bits[major_offset - 1];\n        for (int j = byte_size - 1; j &gt; byte_size - 1 - minor_offset; --j, ++cnt) &#123;\n            if ((val &gt;&gt; j) &amp; 1) &#123;\n                cout &lt;&lt; cnt &lt;&lt; ' ';\n            &#125;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n......\n&#125;;\n\n</code></pre>\n<p>这里的代码假定已经通过遍历输入集合，将对应比特位置的值置为  <code>true</code> 。</p>\n<p>如果是使用  <code>C++</code>  库中的  <code>bitset</code>  实现则更加简单，也是直接遍历即可。示例代码中假定数字的输入范围不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">20</span></span></span></span>。</p>\n<pre><code class=\"language-cpp\">#include &lt;bitset&gt;\n#include &lt;iostream&gt;\n\nbitset&lt;20&gt; b&#123;0x0&#125;;\n    for (int num : arr) &#123;\n        b[num] = true;\n    &#125;\n    for (int i = 0; i &lt; b.size(); ++i) &#123;\n        if (b[i]) &#123;\n            cout &lt;&lt; i &lt;&lt; ' ';\n        &#125;\n    &#125;\n    cout &lt;&lt; endl;\n\n</code></pre>\n<h2 id=\"四\"><a class=\"anchor\" href=\"#四\">#</a> 四</h2>\n<div class=\"note primary\">\n<p>如果认真考虑了习题 3，你将会面对生成小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 且没有重复的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个整数的问题，最简单的方法就是使用前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个正整数。这个极端的数据集合将不会明显地改变位图方法的运行时间，但是可能会歪曲系统排序的运行时间。如何生成位于 0 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> - 1 之间的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 不同的随机顺序的随机整数？尽量使你的程序简短且高效。</p>\n</div>\n<p>题目想问的就是洗牌算法相关的内容。下面摘抄一些比较经典的洗牌算法。</p>\n<h3 id=\"洗牌算法\"><a class=\"anchor\" href=\"#洗牌算法\">#</a> 洗牌算法 <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></h3>\n<h4 id=\"fisher-yates-shuffle-算法\"><a class=\"anchor\" href=\"#fisher-yates-shuffle-算法\">#</a> Fisher-Yates Shuffle 算法</h4>\n<p>此算法最早由 Ronald A. Fisher 和 Frank Yates 提出。算法步骤如下：</p>\n<ol>\n<li>初始化原始数组长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，存储 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mtext>-</mtext><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, n\\text{-}1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>；</li>\n<li>假设原始数组中还剩余 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字，随机产生一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[0, k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> 之间的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>；</li>\n<li>将剩余数组中的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> 个数字取出，放入新数组；</li>\n<li>重复步骤 2 和步骤 3，直到所有数组均被取出；</li>\n<li>新数组中存放的即是一个打乱后的数列。</li>\n</ol>\n<p>其随机性证明 —— 即每个元素放置在新数组中的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个位置的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>—— 如下：</p>\n<p>一个元素 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 放入第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个位置的概率 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span></span></span></span> 前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mtext>-</mtext><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i\\text{-}1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">1</span></span></span></span> 个位置选择元素时没有选择 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 的概率 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>×</mo></mrow><annotation encoding=\"application/x-tex\">\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">×</span></span></span></span> 第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个位置选中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 的概率，即：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>P</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo>×</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>×</mo><mo>⋯</mo><mo>×</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>2</mn></mrow></mfrac><mo>×</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">P = \\frac{n-1}{n}\\times\\frac{n-2}{n-1}\\times\\cdots\\times\\frac{n-i+1}{n-i+2}\\times\\frac{1}{n-i+1}=\\frac{1}{n}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0908em;vertical-align:-0.7693em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1059em;vertical-align:-0.7693em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3365em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0908em;vertical-align:-0.7693em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<pre><code class=\"language-cpp\">void Fisher_Yates_Shuffle(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; res) &#123;\n    srand((unsigned)time(NULL));\n    int k;\n    int len = arr.size();\n    for (int i = 0; i &lt; len; ++i) &#123;\n        k = rand() % arr.size();\n        res.push_back(arr[k]);\n        arr.erase(arr.begin() + k);\n    &#125;\n&#125;\n</code></pre>\n<p>算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。这里时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 的原因是， <code>vector</code>  在移除元素时，会对该元素之后的其他元素进行移动。</p>\n<h4 id=\"knuth-durstenfeld-shuffle-算法\"><a class=\"anchor\" href=\"#knuth-durstenfeld-shuffle-算法\">#</a> Knuth-Durstenfeld Shuffle 算法</h4>\n<p>Knuth 和 Durstenfeld 在 Fisher 和 Yates 洗牌算法的基础上进行了改进，在原数组中进行数据交换，将空间复杂度降低为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。算法步骤为：</p>\n<ol>\n<li>初始化原始数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>，长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，存储 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mtext>-</mtext><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, n\\text{-}1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>；</li>\n<li>对 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mtext>-</mtext><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n\\text{-}1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">1</span></span></span></span> 进行循环：\n<ol>\n<li>生成一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mtext>-</mtext><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,n\\text{-}i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 范围内的随机数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>；</li>\n<li>将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[n-i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span> 进行交换；</li>\n</ol>\n</li>\n<li>最终 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 中存放被打乱的数组。</li>\n</ol>\n<p>证明：</p>\n<p>对于数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 的元素 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>，洗牌后：</p>\n<ul>\n<li>在第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mtext>-</mtext><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n\\text{-}1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">1</span></span></span></span> 位置的概率是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n<li>在第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mtext>-</mtext><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n\\text{-}2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">2</span></span></span></span> 位置的概率是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo>×</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n-1}{n}\\times\\frac{1}{n-1}=\\frac{1}{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⋯</mo></mrow><annotation encoding=\"application/x-tex\">\\cdots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.313em;\"></span><span class=\"minner\">⋯</span></span></span></span>；</li>\n<li>在第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mtext>-</mtext><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n\\text{-}k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 位置的概率是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mo lspace=\"0em\" rspace=\"0em\">×</mo></mfrac><mfrac><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>×</mo><mo>⋯</mo><mo>×</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></mfrac><mo>×</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n-1}\\times\\frac{n-2}{n-1}\\times\\cdots\\times\\frac{n-k+1}{n-k+2}\\times\\frac{1}{n-k+1}=\\frac{1}{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">×</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2834em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n</ul>\n<p>即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 在任意一个位置的概率均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</p>\n<pre><code class=\"language-cpp\">void Knuth_Durstenfeld_Shuffle(vector&lt;int&gt;&amp; arr) &#123;\n    for (int i = arr.size() - 1; i &gt;= 0; --i) &#123;\n        srand((unsigned)time(NULL));\n        swap(arr[rand() % (i + 1)], arr[i]);\n    &#125;\n&#125;\n</code></pre>\n<p>以上算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, 空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。需要注意的是，该算法是在原数组上进行操作的，如果不希望原数组的内容被修改，那么则需要先进行复制操作；对于流式数据也无法进行处理。</p>\n<h4 id=\"inside-out-shuffle-算法\"><a class=\"anchor\" href=\"#inside-out-shuffle-算法\">#</a> Inside-Out Shuffle 算法</h4>\n<p>Inside-Out Shuffle 算法的基本思想是从前向后扫描原始数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>，对元素 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>，在位置 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 中随机选择一个位置 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，在新数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo mathvariant=\"normal\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">A^\\prime</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span> 中将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo mathvariant=\"normal\">′</mo></msup><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A^\\prime[k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span> 赋值给 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo mathvariant=\"normal\">′</mo></msup><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A^\\prime[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>，然后将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 赋值给 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo mathvariant=\"normal\">′</mo></msup><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A^\\prime[k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span>。</p>\n<p>证明：</p>\n<p>原数组中元素 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 在新数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo mathvariant=\"normal\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">A^\\prime</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span> 中前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个位置的概率均为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mn>1</mn><mi>i</mi></mfrac><mo>×</mo><mfrac><mi>i</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mfrac><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></mfrac><mo>×</mo><mo>⋯</mo><mo>×</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{i}\\times\\frac{i}{i+1}\\frac{i+1}{i+2}\\times\\cdots\\times\\frac{n-1}{n}=\\frac{1}{n}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1059em;vertical-align:-0.7693em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3365em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3365em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>即第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 次刚好随机放到了该位置，在后面的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mtext>-</mtext><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">n\\text{-}i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord mathnormal\">i</span></span></span></span> 次选择中该数字不被选中）。</p>\n<p>原数组中元素 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 在新数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo mathvariant=\"normal\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">A^\\prime</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span> 中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 以后位置的概率为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mn>1</mn><mi>k</mi></mfrac><mo>×</mo><mfrac><mi>k</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mfrac><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></mfrac><mo>×</mo><mo>⋯</mo><mo>×</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{k}\\times\\frac{k}{k+1}\\frac{k+1}{k+2}\\times\\cdots\\times\\frac{n-1}{n}=\\frac{1}{n}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1408em;vertical-align:-0.7693em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>即第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 次刚好随机放到了该位置，在后面的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mtext>-</mtext><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n\\text{-}k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 次选择中该数字不被选中。</p>\n<p>该算法时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。因为是从前往后遍历，可以处理动态增长的数组。</p>\n<h4 id=\"蓄水池抽样算法\"><a class=\"anchor\" href=\"#蓄水池抽样算法\">#</a> 蓄水池抽样算法</h4>\n<p>从大小未知的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个元素中等概率取出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个元素，能够在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 时间内对 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个数据进行等概率随机抽取。即使元素数量在继续增长，依然可以做到等概率抽取。</p>\n<p>伪代码：(下标从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 开始)</p>\n<pre><code class=\"language-markdown\">Init: a reservoir with size: k\n    for i = k + 1 to N\n        M = random(1, i)\n        if (M &lt; k)\n            swap the Mth value and ith value\n    end for\n</code></pre>\n<p>上述伪代码的含义是，第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个元素有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mi>i</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 的概率被选中，然后能够等概率 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mi>k</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 替换掉已经选中的元素中的一个。最终前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个元素即我们所需的最后结果。</p>\n<p>证明：在选择第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个元素时，前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mtext>-</mtext><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i\\text{-}1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">1</span></span></span></span> 个元素出现在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个元素中的概率是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mi>i</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>N</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">i\\in [k+1, N]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">]</span></span></span></span></p>\n<ol>\n<li>对于第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个元素，此时蓄水池中的元素为前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个元素，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 此时随机从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[1,k+1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 中选取，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">M &lt; k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{k+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2834em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，即第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个元素被选中的概率；而对于前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个元素，他们如果要被替换，那么必须 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">M &lt; k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 和自己的下标相等。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo>&lt;</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mi>k</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">P(M&lt;k) = \\frac{k}{k+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2834em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo>=</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>∈</mo><mo stretchy=\"false\">[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>k</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">P(M=x,x\\in[1,k])=\\frac{1}{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">])</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，即被替换的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo>&lt;</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo>=</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>∈</mo><mo stretchy=\"false\">[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mi>k</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>⋅</mo><mfrac><mn>1</mn><mi>k</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">P(M&lt;k)\\cdot P(M=x,x\\in[1,k])=\\frac{k}{k+1}\\cdot\\frac{1}{k}=\\frac{1}{k+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">])</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2834em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，那么他们不被替换的 —— 即还在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个选中的元素中的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{k+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2834em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n<li>假设当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">j=i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的时候结论成立，第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个元素被选中的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mi>i</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mtext>-</mtext><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i\\text{-}1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">1</span></span></span></span> 个元素在选中的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个元素中的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mi>i</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n<li>下面证明当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">j=i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的时候结论成立：\n<ol>\n<li>第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个元素被选中的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2834em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n<li>由 2 的假设可知前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个元素出现在被选择的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个元素中的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mi>i</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n<li>前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个元素中，在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个元素中的元素，被替换的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>×</mo><mfrac><mn>1</mn><mi>k</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{i+1}\\times\\frac{1}{k}=\\frac{1}{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2834em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n<li>那么不被替换的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mi>i</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">1 - \\frac{1}{i+1}=\\frac{i}{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.259em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8557em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n</ol>\n</li>\n<li>综上，前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 元素出现在蓄水池中的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mi>i</mi></mfrac><mo>×</mo><mfrac><mi>i</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mi>k</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{i}\\times\\frac{i}{i+1}=\\frac{k}{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.259em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8557em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2834em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</li>\n</ol>\n<p>证明：数据中的每个元素被选中的概率为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>k</mi><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k}{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</p>\n<p>第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个元素被选中的概率 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span></span></span></span> 选择 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个概率 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>×</mo></mrow><annotation encoding=\"application/x-tex\">\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">×</span></span></span></span> (其后元素不被选中的概率 + 其后元素被选中的概率<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>×</mo></mrow><annotation encoding=\"application/x-tex\">\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">×</span></span></span></span> 不替换第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个元素的概率)，即：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>P</mi><mo>=</mo><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>×</mo><munderover><mo>∏</mo><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy=\"false\">(</mo><mfrac><mrow><mi>i</mi><mo>−</mo><mi>k</mi></mrow><mi>i</mi></mfrac><mo>+</mo><mfrac><mi>k</mi><mi>i</mi></mfrac><mo>×</mo><mfrac><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></mfrac><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>×</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>=</mo><mfrac><mi>k</mi><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">P = \\frac{k}{m}\\times\\prod\\limits_{m+1}^{n}(\\frac{i-k}{i} + \\frac{k}{i}\\times\\frac{k-1}{k}) = \\frac{k}{m}\\times\\frac{m}{n} = \\frac{k}{n}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.9768em;vertical-align:-1.3254em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6514em;\"><span style=\"top:-1.8829em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∏</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3254em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.7936em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1076em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>蓄水池抽样算法适合不知道数据总量的场景，例如对机器学习的数据集进行划分或者采样的时候可以使用。</p>\n<h2 id=\"五\"><a class=\"anchor\" href=\"#五\">#</a> 五</h2>\n<div class=\"note primary\">\n<p>那个程序员说他有  <code>1 MB</code>  的可用存储空间，但是我们概要描述的代码需要  <code>1.25 MB</code>  的空间。他可以不费力气地索取到额外的空间。如果  <code>1 MB</code>  空间是严格的边界，你会推荐如何处理呢？你的算法的运行时间又是多少？</p>\n</div>\n<p>采用多趟排序的算法， <code>1 MB</code>  可以存储约 500 万个数字，那么可以先排序 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>4999999</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,4999999]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4999999</span><span class=\"mclose\">]</span></span></span></span>，第二趟再排序 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>5000000</mn><mo separator=\"true\">,</mo><mn>9999999</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[5000000, 9999999]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">5000000</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">9999999</span><span class=\"mclose\">]</span></span></span></span>。</p>\n<h2 id=\"六\"><a class=\"anchor\" href=\"#六\">#</a> 六</h2>\n<div class=\"note primary\">\n<p>如果那个程序员说的不是每个整数最多出现一次，而是每个整数最多出现 10 次，你又如何建议他呢？你的解决方案如何随着可用存储空间的总量的变化而变化？</p>\n</div>\n<p>10 需要用 4 比特的空间来表示。对每个数字，用 4 比特存储其出现次数，即半比特的空间。总共需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10000000</mn><mo>×</mo><mn>4</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo>=</mo><mn>20000000</mn></mrow><annotation encoding=\"application/x-tex\">10000000 \\times 4 / 2 = 20000000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">10000000</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4/2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">20000000</span></span></span></span> 字节的空间来完成排序。当保存的数字出现次数发生变化时，可以进一步调整分配的比特大小。另外，比特的大小最好是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 的幂次，这样便于使用位运算进行处理。</p>\n<p>假定我们使用  <code>unsigned char</code>  类型进行存储，对应 1 个字节，即 8 个比特。如果每个数字使用 4 比特存储出现的次数，那么可以存储 2 个数字出现的次数。更进一步，假定一个数字需要使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 比特进行存储（这里假设 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding=\"application/x-tex\">k = 2^m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span></span></span>），那么总共可以存储 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>8</mn><mi mathvariant=\"normal\">/</mi><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n = 8/k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">8/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字的数量。用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 表示存储所有数字数量的数组。</p>\n<p>如果我们需要对特定数字的内容进行操作，假设该数字是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，那么要对应的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 中的内容应该在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>&gt;</mo><mo>&gt;</mo><mi>m</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i &gt;&gt; m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span></span></span></span>。在定位到这个元素之后，我们需要对 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 对应的比特进行操作。</p>\n<p>如何找到对应的比特？我在之前的习题中是按照  <code>|0 1|2 3|4 5|...</code>  这样的顺序来存储每个数字的数量，但是在查找其他人的博客<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>之后发现，使用  <code>|1 0|3 2|5 4|...</code>  这样的方式进行存储时，位运算会更加简洁。这里两个  <code>|</code>  即表示一个  <code>unsigned char</code>  存储的对应数字的数量，这里假设每个数字使用 4 比特存储。如果使用 2 比特存储，那么内容应该是  <code>|3 2 1 0|7 6 5 4|...</code>  这样的内容。</p>\n<p>我们现在已经找到了对应数组元素 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>&gt;</mo><mo>&gt;</mo><mi>m</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i &gt;&gt; m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span></span></span></span>，要进一步确定比特的位置。对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i % n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 即表示 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 对应 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>&gt;</mo><mo>&gt;</mo><mi>m</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i &gt;&gt; m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span></span></span></span> 中的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i % n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 比特。</p>\n<p>假定现在加入了一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的数量应当加一，对应的代码应该是  <code>A[i &gt;&gt; m] += 1 &lt;&lt; (k * (i % n))</code> 。</p>\n<p>如果要把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 对应的值置 0，为了不影响其他数字的值，需要使用按位与操作，即其他值对应的比特位置都需要为 1，而 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 对应的值需要为 0 。为了更具一般性，假设使用 2 比特存储出现的次数，那么  <code>unsigned char</code>  的 8 个比特可以分为 4 组。假设现在  <code>01 10 00 11</code>  分别对应  <code>3 2 1 0</code>  出现的次数  <code>1 2 0 3</code> 。如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">i = 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>，那么我们需要使用  <code>11 00 11 11</code>  与  <code>01 10 00 11</code>  进行  <code>&amp;</code>  运算。</p>\n<p><code>11 00 11 11</code>  可以通过  <code>00 11 00 00</code>  取反得到，而  <code>00 11 00 00</code>  可以通过  <code>0x03</code>  左移得到。而  <code>0x03</code>  这个 magic number，对于  <code>unsigned char</code> ，可以通过  <code>0xF &gt;&gt; (8 - m)</code>  得到。如果使用  <code>unsigned int</code> ，则对应  <code>0xFFFF &gt;&gt; (32 - m)</code> 。</p>\n<p>所以置零操作代码为  <code>A[i &gt;&gt; m] &amp;= ~((0xF &gt;&gt; (8 - m)) &lt;&lt; (4 * (i % n)))</code>  得到。</p>\n<p>假如要取出 2 对应的数值，只要在置零操作的基础上进行修改。使用  <code>00 11 00 11</code>  进行  <code>&amp;</code>  运算，然后进行移位： <code>A[i &gt;&gt; m] &amp; ((0xF &gt;&gt; (8 - m)) &lt;&lt; (4 * (i % n))) &gt;&gt; (4 * (i % n))</code> 。</p>\n<h2 id=\"七\"><a class=\"anchor\" href=\"#七\">#</a> 七</h2>\n<div class=\"note primary\">\n<p>本书  <code>1.4</code>  节中描述的程序存在一些缺陷。首先是假定输入中没有出现两次的整数。如果某个数出现超过一次的话，会发生什么？在这种情况下，如何修改程序来调用错误处理函数？当输入整数小于零或大于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 时，又会发生什么？如果某个输入不是数值又如何？在这些情况下，程序该如何处理？程序还应该包含哪些明智的检查？描述一些用以测试程序的小型数据集合，并说明如何正确处理上述以及其他的不良情况。</p>\n</div>\n<p>第一个问题：某个数字出现次数超过一次，那么最终输出结果的时候，只有对应的一个值，不会有多个值。</p>\n<p>第二个问题：输入整数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">&lt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\ge n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，需要在读取数字的时候做出判断，过滤掉不在范围内的输入数据。</p>\n<p>第三个问题：输入数据不是数值，在读取输入时，检查输入的结果类型。如果不符合要求，直接  <code>continue</code>  或者报错结束程序，根据实际需求实现。</p>\n<h2 id=\"八\"><a class=\"anchor\" href=\"#八\">#</a> 八</h2>\n<div class=\"note primary\">\n<p>当那个程序员解决该问题的时候，美国所有免费电话的区号都是 800。现在免费电话的区号包括 800、877 和 888，而且还在增多。如何在  <code>1 MB</code>  空间内完成对这些免费号码的排序？如何将免费电话号码存储在一个集合中，要求可以实现非常快速的查找以判定一个给定的免费电话号码是否可用或者已经存在？</p>\n</div>\n<p>排序操作依然可以使用位图进行排序。可以将位图作为文件进行存储，查找的时候，直接访问数字对应的位图比特，如果对应的值为 1，那么说明该号码存在，这样的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"九\"><a class=\"anchor\" href=\"#九\">#</a> 九</h2>\n<div class=\"note primary\">\n<p>使用更多的空间来换取更少的运行时间存在一个问题：初始化空间本身需要消耗大量的时间。说明如何设计一种技术，在第一次访问向量的项时将其初始化为 0。你的方案应该使用常量时间进行初始化和向量访问，使用的额外空间应正比于向量的大小。因为该方法通过进一步增加空间来减少初始化的时间，所以仅在空间很低廉、时间很宝贵且向量很稀疏的情况下才考虑使用。</p>\n</div>\n<p>这道问题参考了相关的博客<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>，当数组的大小 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 非常大时，初始化也是一个非常耗时的操作。因此对所有数据进行统一初始化是不可取的。为了达到时间性能的要求，我们仅对访问的元素（访问到的元素的数量远小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>）进行初始化。</p>\n<p>而这样做就带来了一个问题 —— 我们需要在访问元素之前，对其进行判断，是否已经对该元素进行了初始化。《编程珠玑》的答案中引入了两个数组  <code>from</code>  和  <code>to</code>  以及整数  <code>top</code> ， <code>top</code>  初始化为 0，对于元素  <code>data[i]</code> ，其已经初始化的条件是  <code>from[i] &lt; top &amp;&amp; to[from[i]] == i</code> 。</p>\n<p>现在具体分析一下这个条件。假设第一次访问的元素下标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，一般而言  <code>from[i]</code>  中的随机数是大于  <code>top</code>  的，但是并没有 100% 的保证。此时，第二个判断条件  <code>to[from[i]] == i</code>  就起了作用，这个条件里面相当于取出了  <code>from[i]</code>  和  <code>to[from[i]]</code>  两个随机数，并且该随机数还要恰好等于  <code>i</code> ，虽然在未初始化的情况也有概率可能满足这个结果，但是概率几乎为 0。因此，对于满足这个条件的元素  <code>data[i]</code>  的下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，可以认为其已经经过了初始化。</p>\n<p>在不满足该条件时，我们需要执行下述代码进行初始化：</p>\n<pre><code class=\"language-cpp\">from[i] = top;\nto[top] = i;\ndata[i] = 0;\n++top;\n</code></pre>\n<p>这是一个用空间换时间的方法。</p>\n<h2 id=\"十\"><a class=\"anchor\" href=\"#十\">#</a> 十</h2>\n<div class=\"note primary\">\n<p>在成本低廉的隔日送达时代之前，商店允许顾客通过电话订购商品，并在几天后上门自取。商店的数据库使用客户的电话号码作为其检索的主关键字（客户知道他们自己的电话号码，而且这些关键字几乎都是唯一的）。你如何组织商店的数据库，以允许高效的插入和检索操作？</p>\n</div>\n<p>对电话号码的最后 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 位进行哈希，发生冲突时使用开链法，按照手机尾号顺序存储。当顾客抵达进行检索商品时，营业员按顺序检索订单，这是经典的用 “顺序搜索来解决冲突的开放散列”。如果两位不够，也可以使用更多位，比如我们在验证时，经常使用手机后 4 位判断是否是本人的手机号码。</p>\n<h2 id=\"十一\"><a class=\"anchor\" href=\"#十一\">#</a> 十一</h2>\n<div class=\"note primary\">\n<p>在 20 世纪 80 年代早期，洛克希德公司加利福尼亚州桑尼维尔市工厂的工程师每天都要将许多由计算机辅助设计（CAD）系统生成的图纸从工厂送到位于圣克鲁斯市的测试站。虽然仅有 40 公里远，但使用汽车快递服务每天都需要一个多小时的时间（由于交通阻塞和山路崎岖），花费 100 美元。请给出新的数据传输方案并估计每一种方案的费用。</p>\n</div>\n<p>飞鸽传书；网络传输（传真机）。<span class=\"spoiler\" title=\"你知道得太多了\">emmm</span></p>\n<h2 id=\"十二\"><a class=\"anchor\" href=\"#十二\">#</a> 十二</h2>\n<div class=\"note primary\">\n<p>载人航天的先驱们很快就意识到需要在外太空的极端环境下实现顺利书写。民间盛传美国国家宇航局（NASA）花费 100 万美元研发出了一种特殊的钢笔来解决这个问题。那么，前苏联又会如何解决相同的问题呢？</p>\n</div>\n<blockquote>\n<p>According to the urban legend, the Soviets solved their problem with a <ins class=\"danger\">pencil</ins>, of course. For background on the true story, learn about the Fisher Space Pen company. The company was founded in 1948, and its writing instruments have been used by the Russian Space Agency, underwater explorers, and Himalayan climbing expeditions. <sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup></p>\n</blockquote>\n<p>所以根据都市传说，苏联使用的是铅笔。但是实际上，他们也是使用的特别研制的所谓 “太空笔”。</p>\n<h1 id=\"深入阅读\"><a class=\"anchor\" href=\"#深入阅读\">#</a> 深入阅读</h1>\n<p>本章描述的问题中，既有技术相关的问题，也有一些看似非常无厘头，但是却能够出发创新型思维的问题。作者提供这样的一些习题正是为了激励读者去打破一些这样的壁垒。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://en.cppreference.com/w/cpp/utility/bitset\">Cppreference  <code>bitset</code>  相关内容</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://blog.csdn.net/qq_26399665/article/details/79831490\">三种洗牌算法 shuffle</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"https://www.cnblogs.com/Zeroinger/p/5502382.html\">编程珠玑第一章习题答案</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"https://blog.csdn.net/wordwarwordwar/article/details/40517331\">编程珠玑 第一章第 9 题 空间换时间的数据结构问题</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p><a href=\"https://blog.csdn.net/wordwarwordwar/article/details/40509925\">编程珠玑第一章习题解答</a> <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "Computer-Science",
                "Programming-Pearls"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Configs/oh-my-zsh-and-plugins/",
            "url": "https://linn-ylz.com/Computer-Science/Configs/oh-my-zsh-and-plugins/",
            "title": "Oh My Zsh 及插件配置",
            "date_published": "2022-01-08T15:41:04.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p><code>Oh My Zsh</code>  是一款非常流行的  <code>zsh</code>  配置管理工具，而  <code>zsh</code>  又是一款能够很好地替代  <code>bash</code>  的  <code>shell</code> 。二者的结合能够为终端提供许多非常实用的功能。</p>\n<p>我个人使用  <code>Windows</code>  系统的  <code>WSL</code> ，使用  <code>Ubuntu</code>  环境。因此下文中的命令执行环境默认都是  <code>Ubuntu</code> 。</p>\n<h1 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h1>\n<h2 id=\"安装-zsh\"><a class=\"anchor\" href=\"#安装-zsh\">#</a> 安装  <code>zsh</code></h2>\n<p>要安装  <code>Oh My Zsh</code> ，首先必须要有一个  <code>zsh</code>  环境， <code>zsh</code>  是原始的  <code>bash</code>  终端  <code>shell</code>  的一个良好的替代品。安装  <code>zsh</code>  非常简单：</p>\n<pre><code class=\"language-bash\">apt install zsh\n</code></pre>\n<p>安装完成之后，使用下列指令将默认  <code>shell</code>  改为  <code>zsh</code> ：</p>\n<pre><code class=\"language-bash\">chsh -s /usr/bin/zsh\n</code></pre>\n<p>命令中的路径可能需要根据实际情况进行修改，可以使用  <code>which zsh</code>  命令查看  <code>zsh</code>  的路径。</p>\n<h2 id=\"安装-oh-my-zsh\"><a class=\"anchor\" href=\"#安装-oh-my-zsh\">#</a> 安装  <code>Oh My Zsh</code></h2>\n<p>安装完  <code>zsh</code>  之后，便可以开始  <code>Oh My Zsh</code>  的安装了。更详细的内容，可以参考<a href=\"https://github.com/ohmyzsh/ohmyzsh\" title=\"Oh My Zsh 官方 GitHub 链接\">官方链接</a>，本文只做简要的介绍。</p>\n<table>\n<caption id=\"ohmyzsh\" style=\"caption-side: bottom\">Oh My Zsh 安装命令</caption>\n<thead>\n<tr>\n<th style=\"text-align:left\">Method</th>\n<th style=\"text-align:left\">Command</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>curl</code></td>\n<td style=\"text-align:left\"><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>wget</code></td>\n<td style=\"text-align:left\"><code>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>fetch</code></td>\n<td style=\"text-align:left\"><code>sh -c &quot;$(fetch -o - https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td>\n</tr>\n</tbody>\n</table>\n<p>在这一步，虽然我使用了代理，也能够  <code>Ping</code>  通链接域名  <code>raw.githubusercontent.com</code> ，但是命令仍然不能执行成功。替代方法是在浏览器中直接访问这个链接，复制其中的文件内容，在本地创建  <code>install.sh</code>  脚本，并运行  <code>sh install.sh</code>  进行安装。</p>\n<p>安装完成之后，应该能够看到终端命令行的  <code>prompt</code>  会发生变化，这说明安装成功了。如果没有任何改变，可能需要重新启动终端。</p>\n<h1 id=\"主题和插件配置\"><a class=\"anchor\" href=\"#主题和插件配置\">#</a> 主题和插件配置</h1>\n<p>安装完成之后可以进一步配置主题来自定义终端的样式，或者安装其他的插件来增强终端的功能，提升终端的使用体验。</p>\n<h2 id=\"主题配置\"><a class=\"anchor\" href=\"#主题配置\">#</a> 主题配置</h2>\n<p><code>Oh My Zsh</code>  的主题需要修改  <code>~/.zshrc</code>  来进行配置，在其中找到  <code>ZSH_THEME</code>  这一变量所在的位置，根据需要将后面的主题改为自己喜欢的主题的名称，比如最经典的  <code>robbyrussell</code> 。</p>\n<p>在  <code>~/.oh-my-zsh/themes</code>  文件夹中有许多内置的主题文件，可以根据自己的喜好进行选择。如果还想要更多的主题，可以在网上进行搜索，然后放到这个文件夹下，并修改  <code>~/.zshrc</code>  中的配置。我自己基于  <code>xiong-chiamiov-plus</code>  主题自定义了一个主题。</p>\n<p>修改完成后记得执行  <code>source ~/.zshrc</code>  指令以使得修改得到应用。</p>\n<h2 id=\"插件配置\"><a class=\"anchor\" href=\"#插件配置\">#</a> 插件配置</h2>\n<p>插件配置需要在  <code>~/.zshrc</code>  中找到  <code>plugins</code>  变量所在的位置，在括号中写入需要的插件的名称，注意插件名称之间使用空格进行分隔， <code>Oh My Zsh</code>  默认启用了对  <code>git</code>  插件。</p>\n<p>在  <code>~/.oh-my-zsh/plugins</code>  路径下能找到许多其他的插件，可以根据需要进行启用。这里推荐几个我自己使用的插件。</p>\n<h3 id=\"zsh-autosuggestions\"><a class=\"anchor\" href=\"#zsh-autosuggestions\">#</a>  <code>zsh-autosuggestions</code></h3>\n<p>这一插件会根据过往输入的指令历史，依照你当前输入的指令内容推测你想要输入的完整指令，在你输入了部分指令之后，会在终端上给出提示，如果是想要的指令的话，可以使用方向键右键应用这条指令。快捷键可以根据自己的需要进行修改。</p>\n<p>执行下述命令将插件下载到  <code>$ZSH_CUSTOM/plugins</code>  文件夹下，默认位置在  <code>~/.oh-my-zsh/plugins</code>  此处：</p>\n<pre><code class=\"language-bash\">    git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions\n\n</code></pre>\n<p>然后编辑  <code>~/.zshrc</code>  中的  <code>plugins</code>  变量：</p>\n<pre><code class=\"language-bash\">plugins=( \n    # other plugins...\n    zsh-autosuggestions\n)\n</code></pre>\n<p>使用  <code>source ~/.zshrc</code>  应用修改。</p>\n<h3 id=\"zsh-syntax-highlighting\"><a class=\"anchor\" href=\"#zsh-syntax-highlighting\">#</a>  <code>zsh-syntax-highlighting</code></h3>\n<p>这一插件能够高亮你在命令行中的输入，具体的示例可以参看官方  <code>GitHub</code>  的内容。这里我个人觉得最实用的功能就是能够显示你当前输入的命令是否正确，如果输入的指令存在，那么会以绿色进行高亮，否则会以红色进行高亮，这样能够直观地判断指令是否输入正确。</p>\n<p>和上一段的安装过程类似，执行下述命令下载插件：</p>\n<pre><code class=\"language-bash\">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting\n\n</code></pre>\n<p>然后修改  <code>~/.zshrc</code>  中的  <code>plugins</code>  变量：</p>\n<pre><code class=\"language-bash\">plugins=( [plugins...] zsh-syntax-highlighting)\n\n</code></pre>\n<p>使用  <code>source ~/.zshrc</code>  应用修改。</p>\n<h3 id=\"autojump\"><a class=\"anchor\" href=\"#autojump\">#</a>  <code>autojump</code></h3>\n<p>这个指令会根据过往的文件访问内容为每个文件夹确定一个权重，根据权重高低选择跳转的文件夹。例如我最近经常访问某个  <code>src</code>  文件夹，那么我输入  <code>j src</code>  指令之后，便会自动跳转到该文件夹。更多的功能可以查看该项目的 <a href=\"https://github.com/wting/autojump\"> <code>GitHub</code>  主页</a>。</p>\n<p>执行下列指令进行安装：</p>\n<pre><code class=\"language-bash\">apt install autojump\n</code></pre>\n<p>修改  <code>~/.zshrc</code>  的  <code>plugins</code>  变量：</p>\n<pre><code class=\"language-bash\">plugins=( [plugins...] autojump)\n\n</code></pre>\n<p>使用  <code>source ~/.zshrc</code>  应用修改。</p>\n<h3 id=\"material-colors\"><a class=\"anchor\" href=\"#material-colors\">#</a>  <code>material-colors</code></h3>\n<p>根据文件类型用不同颜色显示其名称。</p>\n<pre><code class=\"language-bash\">git clone https://github.com/zpm-zsh/material-colors ~/.oh-my-zsh/custom/plugins/material-colors\n</code></pre>\n<p>修改  <code>~/.zshrc</code>  的  <code>plugins</code>  变量：</p>\n<pre><code class=\"language-bash\">plugins=( [plugins...] material-colors)\n\n</code></pre>\n<h3 id=\"内置插件\"><a class=\"anchor\" href=\"#内置插件\">#</a> 内置插件</h3>\n<p>出了第三方插件之外， <code>Oh My Zsh</code>  内置了许多插件，出了最常用的  <code>git</code>  插件之外，还有一些插件也值得推荐。</p>\n<h4 id=\"extract\"><a class=\"anchor\" href=\"#extract\">#</a>  <code>extract</code></h4>\n<p>用于解压文件，不用再去纠结  <code>tar</code>  一类命令的具体参数细节。</p>\n<h4 id=\"colored-man-pages\"><a class=\"anchor\" href=\"#colored-man-pages\">#</a>  <code>colored-man-pages</code></h4>\n<p>使用  <code>man</code>  命令查看其他指令的说明文档时，对内容进行高亮，使得内容更加清晰。</p>\n<h1 id=\"其他选项设置\"><a class=\"anchor\" href=\"#其他选项设置\">#</a> 其他选项设置</h1>\n<p>在某些比较到的工程项目文件夹之下， <code>git</code>  插件的  <code>prompt</code>  功能会严重影响  <code>shell</code>  的响应速度。尽管这一功能能够帮助我们查看  <code>git</code>  项目中是否有文件被修改，但是严重影响了终端的响应速度，而实际中我们经常会使用  <code>git status</code>  确认文件的修改情况，因此权衡之后，还是决定关闭这个功能以提升日常的使用体验。</p>\n<p>这里去除  <code>~/.zshrc</code>  中的以下内容的注释：</p>\n<pre><code class=\"language-bash\">DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;\n</code></pre>\n<p>之后使用</p>\n<pre><code class=\"language-bash\">git config --global --add oh-my-zsh.hide-dirty 1\n</code></pre>\n<p>停用追踪文件修改的功能以提升  <code>shell</code>  的响应速度。</p>\n<p>执行上述操作之后，实测  <code>shell</code>  的响应速度有了明显的提升。</p>\n",
            "tags": [
                "Computer-Science",
                "Configs",
                "Oh-My-Zsh"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Programming-Pearls/chapter-0-introduction/",
            "url": "https://linn-ylz.com/Computer-Science/Programming-Pearls/chapter-0-introduction/",
            "title": "《编程珠玑》（零）——简介",
            "date_published": "2022-01-08T05:37:23.000Z",
            "content_html": "<h1 id=\"说明\"><a class=\"anchor\" href=\"#说明\">#</a> 说明</h1>\n<p>本文是关于《编程珠玑》这本书籍的相关文章的说明。接下来的时间内我将会用一系列文章记录阅读《编程珠玑》这本书时的相关笔记，如果按照保守估计，一个章节一篇博客来计算的话，至少也是十五篇文章的内容了。<span class=\"spoiler\" title=\"你知道得太多了\">当然，实际上可能会更多就是了。</span></p>\n<p>这本书买了也有一段时间了，只是一直没能找到比较好的时间进行仔细地阅读。想了想今后的安排，还是决定慢慢地开始，一点一点地记录相关的内容吧，否则反倒是一直不能开始，也就辜负了书中的内容了。</p>\n<h1 id=\"关于本书\"><a class=\"anchor\" href=\"#关于本书\">#</a> 关于本书</h1>\n<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>本书作者 Jon Bentley 是美国著名的程序员和计算机科学家，他于 20 世纪 70 年代前后在很有影响力的《ACM 通讯》（<em>Communications of the ACM</em>）上以专栏的形式发表了一系列的短文，这些文章大受读者欢迎。后来在 ACM 的鼓励之下，作者对这些文章进行了整理和修订，并精心安排了各个章节的内容，最终汇集成了 <em>Programming Pearls</em> 以及 <em>More Programming Pearls</em> 这两本书。</p>\n<p>我自己购买的这本中文版是作者在 2000 年修订的《编程珠玑（第 2 版）》，书中的代码示例均改用  <code>C</code>  进行编写。另一本《编程珠玑・续》打算在本书读完之后再购买阅读。</p>\n<h2 id=\"内容\"><a class=\"anchor\" href=\"#内容\">#</a> 内容</h2>\n<p>本书的每一章节都独立成篇，但是各章节之间又有着逻辑分组。</p>\n<ul>\n<li>第一部分（1~5）：回顾了编程的基本原理，包括问题定义、算法、数据结构以及程序验证和测试；</li>\n<li>第二部分（6~10）：围绕效率这一主题展开；</li>\n<li>第三部分（11~15）：使用前两个部分介绍的技术来解决排序、搜索和字符串等重要问题。</li>\n</ul>\n<p>在每一章节的末尾，作者会给出一定数量的习题。作者本人提倡放慢阅读本书的速度，每次最好阅读一个章节，并尝试解答每个章节提出的问题 —— 有些问题可能需要集中精力思考一两个小时才会变得容易。在书籍的末尾会又一些习题的提示和答案。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<p>书中的程序采用简洁的代码风格：</p>\n<ul>\n<li>短变量名</li>\n<li>很少空行</li>\n<li>很少或没有错误检测</li>\n</ul>\n<p>这种风格虽然不适合于大型软件项目开发，但是有助于表达算法的核心思想。</p>\n<p>本书中的大多数函数均使用伪代码表示。记号 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi>o</mi><mi>r</mi><mi>i</mi><mo>=</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">for i = [0,n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 表示从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mtext>-</mtext><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n\\text{-}1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\">-</span></span><span class=\"mord\">1</span></span></span></span> 的范围内对 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 进行迭代。表达式 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>function</mtext><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{function}(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">function</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 表示用参数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 调用函数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>array</mtext><mo stretchy=\"false\">[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\text{array}[i,j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">array</span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 表示访问数组元素。</p>\n<h1 id=\"相关文章导航\"><a class=\"anchor\" href=\"#相关文章导航\">#</a> 相关文章导航</h1>\n<p>此处将会放上本系列文章内容的相关链接。</p>\n<ul>\n<li><a href=\"/Computer-Science/Programming-Pearls/chapter-0-introduction/\" title=\"《编程珠玑》（零）——简介\">《编程珠玑》（零）——简介</a></li>\n<li>···</li>\n</ul>\n",
            "tags": [
                "Computer-Science",
                "Programming-Pearls"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Configs/clion-wsl2-cuda-configs/",
            "url": "https://linn-ylz.com/Computer-Science/Configs/clion-wsl2-cuda-configs/",
            "title": "通过 CLion 在 WSL2 的 CUDA 环境下使用 libtorch",
            "date_published": "2021-10-08T15:32:30.000Z",
            "content_html": "<h1 id=\"说明\"><a class=\"anchor\" href=\"#说明\">#</a> 说明</h1>\n<p>本文记录使用  <code>CLion</code>  的  <code>IDE</code>  环境，使用  <code>WSL2</code>  环境下的  <code>CUDA</code>  来调用  <code>PyTorch</code>  的  <code>libtorch</code>  库内容。</p>\n<p><code>libtorch</code>  是  <code>PyTorch</code>  框架提供的  <code>C++</code>  接口，因为最近的课题对性能有比较高的要求，并且有自定义算子的需求，所以需要用到相关的代码。</p>\n<p><code>WSL2</code>  下的  <code>CUDA</code>  环境配置可以参考 <a href=\"/Computer-Science/Configs/wsl2-cuda-configs/\" title=\"WSL2 下的 CUDA 配置\">这篇文章</a>。</p>\n<h1 id=\"配置\"><a class=\"anchor\" href=\"#配置\">#</a> 配置</h1>\n<h2 id=\"下载-libtorch\"><a class=\"anchor\" href=\"#下载-libtorch\">#</a> 下载  <code>libtorch</code></h2>\n<p>从  <code>PyTorch</code>  的<a href=\"https://pytorch.org/\">官方网站</a>下载自己所需版本的  <code>libtorch</code>  。注意和自己的  <code>CUDA</code>  版本也要对应。</p>\n<h2 id=\"clion-配置\"><a class=\"anchor\" href=\"#clion-配置\">#</a>  <code>CLion</code>  配置</h2>\n<p>打开  <code>CLion</code>  新建一个  <code>CUDA executable</code>  工程。然后修改  <code>CMakeLists.txt</code>  和  <code>CMake</code>  的相关配置。</p>\n<h3 id=\"wsl2-环境配置\"><a class=\"anchor\" href=\"#wsl2-环境配置\">#</a>  <code>WSL2</code>  环境配置</h3>\n<p>参考这篇<a href=\"https://zhuanlan.zhihu.com/p/272522594\">知乎文章</a>中的<strong>第三步 - 配置 Clion 内的 Toolchains</strong> 这一部分的内容。</p>\n<h3 id=\"cmake-配置\"><a class=\"anchor\" href=\"#cmake-配置\">#</a>  <code>CMake</code>  配置</h3>\n<p>按照  <code>File</code> -&gt; <code>Settings</code> -&gt; <code>Build,Execution,Development</code> -&gt; <code>CMake</code>  的路径，在其中的  <code>CMake options</code>  选项中添加  <code>-DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc</code>  的内容。如下图所示：</p>\n<p><img loading=\"lazy\" data-src=\"/images/clion-wsl2-cuda-configs-cmake-options.jpg\" alt=\"CMake options\" /></p>\n<h3 id=\"修改-cmakeliststxt\"><a class=\"anchor\" href=\"#修改-cmakeliststxt\">#</a> 修改  <code>CMakeLists.txt</code></h3>\n<p>首先将下载好的  <code>libtorch</code>  文件解压，这里我解压到了本文件夹下的  <code>libtorch</code>  文件夹中。在  <code>CMakeLists.txt</code>  文件中设置  <code>CMAKE_PREFIX_PATH</code>  变量，添加  <code>libtorch</code>  的路径。添加  <code>find_package(Torch REQUIRED)</code>  语句，以及  <code>target_link_libraries(ProjectName &quot;$&#123;TORCH_LIBRARIES&#125;&quot;)</code> ，这两行是最关键的内容。</p>\n<pre><code class=\"language-cmake\">project(ProjectName CXX CUDA)\nset(CMAKE_PREFIX_PATH libtorch)\nfind_package(Torch REQUIRED)\ntarget_link_libraries(ProjectName &quot;$&#123;TORCH_LIBRARIES&#125;&quot;)\n</code></pre>\n<p>上方的代码中省去了  <code>CLion</code>  中默认提供的内容，以便让内容更清晰。</p>\n<h3 id=\"代码测试\"><a class=\"anchor\" href=\"#代码测试\">#</a> 代码测试</h3>\n<p>在工程中添加一个  <code>main.cpp</code>  文件，注意在  <code>CMakeLists.txt</code>  也要对应修改  <code>add_executable(ProjectName main.cpp)</code>  这一行的内容。</p>\n<p>在  <code>main.cpp</code>  中添加如下的测试代码：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;torch/torch.h&gt;\n\nint main() &#123;\n    torch::Tensor tensor = torch::rand(&#123;2,3&#125;);\n    std::cout &lt;&lt; tensor &lt;&lt; std::endl;\n    std::cout &lt;&lt; tensor.cuda() &lt;&lt; std::endl;\n    return 0;\n&#125;\n</code></pre>\n<p>如果编译并运行成功，那么配置完成。</p>\n<h1 id=\"可能的错误\"><a class=\"anchor\" href=\"#可能的错误\">#</a> 可能的错误</h1>\n<p>如果碰到  <code>PyTorch requires cuDNN 7 and above.</code>  这一问题，可以参考这个 <a href=\"https://github.com/pytorch/pytorch/issues/40965\"> <code>GitHub</code>  链接</a>。问题的原因在于无法识别系统中的  <code>cuDNN</code>  版本。我自己碰到这个问题的原因是没有把  <code>cuDNN</code>  中的  <code>cudnn_version.h</code>  这一头文件复制到对应位置，在复制之后问题解决。</p>\n",
            "tags": [
                "Computer-Science",
                "CUDA",
                "Configs",
                "WSL2",
                "CLion",
                "PyTorch"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Configs/wsl2-cuda-configs/",
            "url": "https://linn-ylz.com/Computer-Science/Configs/wsl2-cuda-configs/",
            "title": "WSL2 下的 CUDA 配置",
            "date_published": "2021-10-08T14:56:26.000Z",
            "content_html": "<h1 id=\"说明\"><a class=\"anchor\" href=\"#说明\">#</a> 说明</h1>\n<p>本文记录  <code>Windows</code>  环境下  <code>WSL2</code>  系统中配置  <code>CUDA</code>  环境的过程。配置过程主要参考这篇<a href=\"https://zhuanlan.zhihu.com/p/350399229\">知乎文章</a>以及<a href=\"https://docs.nvidia.com/cuda/wsl-user-guide/index.html\">官方文档</a>。</p>\n<p>本文内容中省去在  <code>Windows</code>  下安装  <code>WSL2</code>  的过程，这里默认已经安装该环境。如果没有安装  <code>WSL2</code> ，可以参考官方文档中提供的说明。</p>\n<h1 id=\"配置\"><a class=\"anchor\" href=\"#配置\">#</a> 配置</h1>\n<h2 id=\"安装驱动\"><a class=\"anchor\" href=\"#安装驱动\">#</a> 安装驱动</h2>\n<p>参考官方文档中的 <a href=\"https://docs.nvidia.com/cuda/wsl-user-guide/index.html#:~:text=Release%20Preview%20Channel.-,2.3.%C2%A0Installing%20NVIDIA%20Windows%20Drivers%20for%20CUDA%2C%20DirectX%2C%20and%20DirectML%20Support,-Download%20the%20NVIDIA\">2.3 小节</a>。</p>\n<p>下载好驱动之后直接安装，安装选项均为默认值。</p>\n<h2 id=\"安装-cuda\"><a class=\"anchor\" href=\"#安装-cuda\">#</a> 安装  <code>CUDA</code></h2>\n<p>参考官方文档中的 <a href=\"https://docs.nvidia.com/cuda/wsl-user-guide/index.html#ch03a-setting-up-cuda\">2.6 小节</a>。文档中提供了几种可选的方法，任选一种即可，如果全部执行一遍反而可能会出问题。我自己选择的是  <code>Installation of CUDA Toolkit using WSL-Ubuntu Package</code>  这一节中的方法。依照后续的指令来看， <code>WSL2</code>  需要安装  <code>Ubuntu-20.04</code>  的版本。</p>\n<p>首先依次执行以下指令：</p>\n<pre><code class=\"language-bash\">wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin\nsudo mv cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600\nwget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda-repo-wsl-ubuntu-11-4-local_11.4.0-1_amd64.deb\nsudo dpkg -i cuda-repo-wsl-ubuntu-11-4-local_11.4.0-1_amd64.deb\nsudo apt-key add /var/cuda-repo-wsl-ubuntu-11-4-local/7fa2af80.pub\nsudo apt-get update\nsudo apt-get -y install cuda\n</code></pre>\n<p>上述指令中安装的  <code>CUDA</code>  版本是  <code>11.4</code>  的，虽然我自己的  <code>Windows</code>  中安装的  <code>CUDA</code>  版本是  <code>10.1</code> ，但是好像不匹配也并无大碍。安装过程中可以将  <code>apt</code>  的源更换为阿里提供的镜像，具体更改方法可以参考此<a href=\"https://cloud.tencent.com/developer/article/1538304\">链接</a>。</p>\n<p>安装完成后，修改  <code>WSL2</code>  系统的环境变量。通常是在  <code>~/.bashrc</code>  文件中添加如下内容：</p>\n<pre><code class=\"language-bash\">export CUDA_HOME=/usr/local/cuda\nexport PATH=$PATH:$CUDA_HOME/bin\nexport LD_LIBRARY_PATH=/usr/local/cuda-11.4/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;\n</code></pre>\n<p>我自己因为安装了  <code>zsh</code>  中断，所以我在  <code>~/.zshrc</code>  文件中添加上述内容。注意其中的  <code>CUDA</code>  版本号和自己的版本对应。</p>\n<p>上述修改完成后，在终端输入如下指令：</p>\n<pre><code class=\"language-bash\">nvcc --version\n</code></pre>\n<p>如果得到如下类似的输出说明安装成功了：</p>\n<p><img loading=\"lazy\" data-src=\"/images/wsl2-cuda-configs-nvcc-version.jpg\" alt=\"nvcc version\" /></p>\n<h2 id=\"安装-cudnn\"><a class=\"anchor\" href=\"#安装-cudnn\">#</a> 安装  <code>cuDNN</code></h2>\n<p>在<a href=\"com/rdp/cudnn-download\">官网</a>下载和  <code>CUDA</code>  对应的  <code>cuDNN</code>  版本。可能需要预先注册账号。下载时选择  <code>cuDNN Library for Linux (x86)</code> 。</p>\n<p>下载完成后使用如下指令解压，并将文件移动到对应的文件夹：</p>\n<pre><code class=\"language-bash\">tar -zxvf cudnn-11.4-linux-x64-v8.2.4.15.tgz\nsudo cp -P cuda/lib64/libcudnn* /usr/local/cuda-11.4/lib64/\nsudo cp  cuda/include/cudnn* /usr/local/cuda-11.4/include/\n</code></pre>\n<p>然后为所有文件设置权限：</p>\n<pre><code class=\"language-bash\">sudo chmod a+r /usr/local/cuda-11.0/include/cudnn*\nsudo chmod a+r /usr/local/cuda-11.0/lib64/libcudnn*\n</code></pre>\n<h2 id=\"验证安装\"><a class=\"anchor\" href=\"#验证安装\">#</a> 验证安装</h2>\n<p>执行以下指令：</p>\n<pre><code class=\"language-bash\">cd /usr/local/cuda/samples/4_Finance/BlackScholes\nsudo make\n./BlackScholes\n</code></pre>\n<p>如果得到  <code>Test passed</code>  的输出说明安装成功：</p>\n<p><img loading=\"lazy\" data-src=\"/images/wsl2-cuda-configs-check-cuda-installation.jpg\" alt=\"check cuda installation\" /></p>\n",
            "tags": [
                "Computer-Science",
                "CUDA",
                "Configs",
                "WSL"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-11/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-11/",
            "title": "剑指 Offer （十一）",
            "date_published": "2021-10-01T12:10:18.000Z",
            "content_html": "<h1 id=\"面试题-58翻转字符串\"><a class=\"anchor\" href=\"#面试题-58翻转字符串\">#</a> 面试题 58：翻转字符串</h1>\n<h2 id=\"题目一翻转单词顺序\"><a class=\"anchor\" href=\"#题目一翻转单词顺序\">#</a> 题目一：翻转单词顺序</h2>\n<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串  <code>I am a student.</code> ，则输出  <code>student. a am I</code> 。</p>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p>第一步翻转句子中所有的字符。比如翻转  <code>I am a student.</code>  中所有的字符得到  <code>.tneduts a ma I</code> ，此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。第二步再翻转每个单词中字符的顺序，就得到了  <code>student. a am I</code> 。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nvoid reverse(string &amp;str, int begin, int end) &#123;\n    if (begin &gt;= str.size() || end &gt;= str.size() || begin &gt; end) &#123;\n        return;\n    &#125;\n\n    while (begin &lt; end) &#123;\n        swap(str[begin], str[end]);\n\n        ++begin;\n        --end;\n    &#125;\n&#125;\n\nvoid reverse_word(string &amp;str) &#123;\n    if (str.empty()) &#123;\n        return;\n    &#125;\n\n    int begin = 0;\n    int end = str.size() - 1;\n\n    reverse(str, begin, end);\n\n    begin = end = 0;\n    while (begin &lt; str.size()) &#123;\n        if (str[begin] == ' ') &#123;\n            ++begin;\n            ++end;\n        &#125; else if (end == str.size() || str[end] == ' ') &#123;\n            reverse(str, begin, --end);\n            begin = ++end;\n        &#125; else &#123;\n            ++end;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"题目二左旋转字符串\"><a class=\"anchor\" href=\"#题目二左旋转字符串\">#</a> 题目二：左旋转字符串</h2>\n<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串  <code>abcdefg</code>  和数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>，该函数将返回左旋转两位得到的结果  <code>cdefgab</code> 。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>以  <code>abcdefg</code>  为例，可以把它分为两部分。把前两个字符分到第一部分，把后面的所有字符分到第二部分。先分别翻转这两部分，于是就得到  <code>bagfedc</code> 。接下来翻转整个字符串，得到的  <code>cdefgab</code>  刚好就是把原始字符串左旋转两位的结果。通过前面的分析，可以发现只需耍调用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 次前面的  <code>reverse</code>  函数就可以实现字符串的左旋转功能。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nvoid reverse(string &amp;str, int begin, int end) &#123;\n    if (begin &gt;= str.size() || end &gt;= str.size() || begin &gt; end) &#123;\n        return;\n    &#125;\n\n    while (begin &lt; end) &#123;\n        swap(str[begin], str[end]);\n\n        ++begin;\n        --end;\n    &#125;\n&#125;\n\nvoid left_rotate_string(string &amp;str, int n) &#123;\n    if (str.empty()) &#123;\n        return;\n    &#125;\n\n    int len = str.size();\n    if (len &gt; 0 &amp;&amp; n &gt; 0 &amp;&amp; n &lt; len) &#123;\n        int first_start = 0;\n        int first_end = n - 1;\n        int second_start = n;\n        int second_end = len - 1;\n\n        reverse(str, first_start, first_end);\n\n        reverse(str, second_start, second_end);\n\n        reverse(str, first_start, second_end);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"面试题-59队列的最大值\"><a class=\"anchor\" href=\"#面试题-59队列的最大值\">#</a> 面试题 59：队列的最大值</h1>\n<h2 id=\"题目一滑动窗口的最大值\"><a class=\"anchor\" href=\"#题目一滑动窗口的最大值\">#</a> 题目一：滑动窗口的最大值</h2>\n<p>给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{2,3,4,2,6,2,5,1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> 及滑动窗口的大小 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>，那么一共存在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span> 个滑动窗口，它们的最大值分别为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{4,4,6,6,6,5\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">}</span></span></span></span>。</p>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>使用单调队列 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> 存储当前窗口的最大值的下标，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> 使用双端队列  <code>deque</code>  实现。每次移动窗口时，判断当前队首的元素的下标是否仍在当前窗口的范围内。如果不在范围内，则需要将该元素从队首端移除。</p>\n<p>对于新添加的元素，将其和队尾元素进行比较，如果小于队尾元素，则将其直接存储到队列中；如果大于队尾元素，则将队尾元素从队尾端移除，并继续进行比较，直到某个元素比新添加的元素更大，或者队列中无其他元素。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;deque&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; max_in_windows(const vector&lt;int&gt; &amp;numbers, unsigned int size) &#123;\n    vector&lt;int&gt; max_in_windows;\n\n    if (numbers.size() &gt;= size &amp;&amp; size &gt;= 1) &#123;\n        deque&lt;int&gt; index;\n\n        for (unsigned int i = 0; i &lt; size; ++i) &#123;\n            while (!index.empty() &amp;&amp; numbers[i] &gt;= numbers[index.back()]) &#123;\n                index.pop_back();\n            &#125;\n\n            index.push_back(i);\n        &#125;\n\n        for (unsigned int i = size; i &lt; numbers.size(); ++i) &#123;\n            max_in_windows.push_back(numbers[index.front()]);\n\n            while (!index.empty() &amp;&amp; numbers[i] &gt;= numbers[index.back()]) &#123;\n                index.pop_back();\n            &#125;\n\n            if (!index.empty() &amp;&amp; index.front() &lt;= (int)(i - size)) &#123;\n                index.pop_front();\n            &#125;\n\n            index.push_back(i);\n        &#125;\n        max_in_windows.push_back(numbers[index.front()]);\n    &#125;\n\n    return max_in_windows;\n&#125;\n</code></pre>\n<h2 id=\"题目二队列的最大值\"><a class=\"anchor\" href=\"#题目二队列的最大值\">#</a> 题目二：队列的最大值</h2>\n<p>请定义一个队列并实现函数  <code>max</code>  得到队列里的最大值，要求函数  <code>max</code> 、 <code>push_back</code>  和  <code>pop_front</code>  的时间复杂度都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>滑动窗口可以看成一个队列。因此和上一题的思路类似。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass QueueWithMax &#123;\npublic:\n    QueueWithMax() : current_index(0) &#123;&#125;\n\n    void push_back(T number) &#123;\n        while (!maximums.empty() &amp;&amp; number &gt;= maximums.back().number) &#123;\n            maximums.pop_back();\n        &#125;\n\n        InternalData internal_data = &#123;number, current_index&#125;;\n        data.push_back(internal_data);\n        maximums.push_back(internal_data);\n\n        ++current_index;\n    &#125;\n\n    void pop_front() &#123;\n        if (maximums.empty()) &#123;\n            throw &quot;Queue is empty.&quot;;\n        &#125;\n\n        if (maximums.front().index == data.front().index) &#123;\n            maximums.pop_front();\n        &#125;\n\n        data.pop_front();\n    &#125;\n\n    T max() const &#123;\n        if (maximums.empty()) &#123;\n            throw &quot;Queue is empty.&quot;;\n        &#125;\n\n        return maximums.front().number;\n    &#125;\n\nprivate:\n    struct InternalData &#123;\n        T number;\n        int index;\n    &#125;;\n\n    deque&lt;InternalData&gt; data;\n    deque&lt;InternalData&gt; maximums;\n    int current_index;\n&#125;;\n</code></pre>\n<h1 id=\"面试题-60n-个骰子的点数\"><a class=\"anchor\" href=\"#面试题-60n-个骰子的点数\">#</a> 面试题 60：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个骰子的点数</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个骰子扔在地上，所有骰子朝上一面的点数之和为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>。输入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，打印出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 的所有可能的值出现的概率。</p>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>考虑用两个数组来存储每种骰子点数的总和出现的次数。</p>\n<p>在一轮循环中，第一个数组中的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个数字表示骰子和为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 出现的次数。在下一轮循环中，加上一个新的骰子，此时和为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的骰子出现的次数应该等于上一轮循环中骰子点数和为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n-2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">n-3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">n-4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">n-5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 与 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">n-6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span> 的次数的总和，所以把另一个数组的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个数字设为前一个数组对应的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n-2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">n-3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">n-4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">n-5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 与 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">n-6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span> 这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span> 项之和。</p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nconst int MAX_VALUE = 6;\n\nvoid print_probability(int number) &#123;\n    if (number &lt; 1) &#123;\n        return;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; probabilities(2, vector&lt;int&gt;(MAX_VALUE * number + 1, 0));\n\n    int flag = 0;\n    for (int i = 1; i &lt; MAX_VALUE; ++i) &#123;\n        probabilities[flag][i] = 1;\n    &#125;\n\n    for (int k = 2; k &lt;= number; ++k) &#123;\n        for (int i = 0; i &lt; k; ++i) &#123;\n            probabilities[1 - flag][i] = 0; // 小于 k 点的骰子点数总和不存在\n        &#125;\n\n        for (int i = k; i &lt;= MAX_VALUE * k; ++i) &#123;\n            probabilities[1 - flag][i] = 0;\n            for (int j = 1; j &lt;= i &amp;&amp; j &lt;= MAX_VALUE; ++j) &#123;\n                probabilities[1 - flag][i] += probabilities[flag][i - j];\n            &#125;\n        &#125;\n\n        flag = 1 - flag;\n    &#125;\n\n    double total = pow(MAX_VALUE, number);\n    for (int i = number; i &lt;= MAX_VALUE * number; ++i) &#123;\n        double ratio = (double)probabilities[flag][i] / total;\n        printf(&quot;%d:%e\\n&quot;, i, ratio);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"面试题-61扑克牌的顺子\"><a class=\"anchor\" href=\"#面试题-61扑克牌的顺子\">#</a> 面试题 61：扑克牌的顺子</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>从扑克牌中随机抽 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 张牌，判断是不是一个顺子，即这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 张牌、是不是连续的。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10</span></span></span></span> 为数字本身， <code>A</code>  为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>， <code>J</code>  为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>11</mn></mrow><annotation encoding=\"application/x-tex\">11</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">11</span></span></span></span>， <code>Q</code>  为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>12</mn></mrow><annotation encoding=\"application/x-tex\">12</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">12</span></span></span></span>， <code>K</code>  为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>13</mn></mrow><annotation encoding=\"application/x-tex\">13</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">13</span></span></span></span>，而大、小王可以看成任意数字。</p>\n<h2 id=\"思路-6\"><a class=\"anchor\" href=\"#思路-6\">#</a> 思路</h2>\n<p>不妨把大小王视为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>。如何判断 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 可以当成任意数字，可以用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 去补满数组中的空缺。</p>\n<p>如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，那么只要我们有足够的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 可以补满这两个数字的空缺，这个数组实际上还是连续的。</p>\n<p>于是我们需要做 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 件事情：首先把数组排序；其次统计数组中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 的个数；最后统计排序之后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或者等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 的个数，那么这个数组就是连续的；反之则不连续。</p>\n<h2 id=\"代码-6\"><a class=\"anchor\" href=\"#代码-6\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nbool is_continuous(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.empty()) &#123;\n        return false;\n    &#125;\n\n    sort(numbers.begin(), numbers.end());\n\n    int num_of_zero = 0;\n    int num_of_gap = 0;\n\n    for (int i = 0; i &lt; numbers.size() &amp;&amp; numbers[i] == 0; ++i) &#123;\n        ++num_of_zero;\n    &#125;\n\n    int small = num_of_zero;\n    int large = num_of_zero + 1;\n    while (large &lt; numbers.size()) &#123;\n        if (numbers[small] == numbers[large]) &#123;\n            return false;   // 有对子出现\n        &#125;\n\n        num_of_gap += numbers[large] - numbers[small] - 1;\n        small = large;\n        ++large;\n    &#125;\n\n    return num_of_gap &lt;= num_of_zero;\n&#125;\n</code></pre>\n<h1 id=\"面试题-62圆圈中最后剩下的数字\"><a class=\"anchor\" href=\"#面试题-62圆圈中最后剩下的数字\">#</a> 面试题 62：圆圈中最后剩下的数字</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，……，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个数字排成一个圆圈，从数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 开始，每次从这个圆圈里删除第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个数字。求出这个圆圈里剩下的最后一个数字。</p>\n<h2 id=\"思路-7\"><a class=\"anchor\" href=\"#思路-7\">#</a> 思路</h2>\n<p>本题是著名的约瑟夫环（Josephuse) 问题。有两种解题方法。</p>\n<p>第一种是用链表模拟圆圈。这里略过。</p>\n<p>第二种是分析被删除数字的规律并直接计算出圆圈中最后剩下的数字。这里详细描述这种解决方法。</p>\n<p>首先定义一个关于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 的方程 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n,m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，表示每次在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、……、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 中删除第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个数字最后剩下的数字。</p>\n<p>在这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个数字中，第一个被删除的数字是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">%</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(m-1)\\%n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">%</span><span class=\"mord mathnormal\">n</span></span></span></span>，不妨记起为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。那么删除 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 之后剩下的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个数字为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、……、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、……、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，并且下一次删除从数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 开始计数，从而形成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、……、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、……、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的环，该序列最后剩下的数字也应该是关于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 的函数，记为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n-1,m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>。最初的序列最后剩下的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n,m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> 一定是删除一个数字之后的序列最后剩下的数字，即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n,m)=f(n-1,m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>把剩下的这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个数字的序列进行重新映射，形成一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n-2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 的序列：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn><mo>→</mo><mn>0</mn><mspace linebreak=\"newline\"></mspace><mi>k</mi><mo>+</mo><mn>2</mn><mo>→</mo><mn>1</mn><mspace linebreak=\"newline\"></mspace><mo>⋯</mo><mspace linebreak=\"newline\"></mspace><mi>n</mi><mo>−</mo><mn>1</mn><mo>→</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>2</mn><mspace linebreak=\"newline\"></mspace><mn>0</mn><mo>→</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>1</mn><mspace linebreak=\"newline\"></mspace><mn>1</mn><mo>→</mo><mi>n</mi><mo>−</mo><mi>k</mi><mspace linebreak=\"newline\"></mspace><mo>⋯</mo><mspace linebreak=\"newline\"></mspace><mi>k</mi><mo>−</mo><mn>1</mn><mo>→</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">k+1 \\rightarrow 0 \\\\\nk+2 \\rightarrow 1 \\\\\n\\cdots \\\\\nn-1 \\rightarrow n-k-2 \\\\\n0 \\rightarrow n-k-1 \\\\\n1 \\rightarrow n-k \\\\\n\\cdots \\\\\nk-1 \\rightarrow n-2\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.313em;\"></span><span class=\"minner\">⋯</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.313em;\"></span><span class=\"minner\">⋯</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span></p>\n<p>将该映射定义为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>，则 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">%</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">p(x)=(x-k-1)\\%n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">%</span><span class=\"mord mathnormal\">n</span></span></span></span>。该映射的逆映射是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>p</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">%</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">p^{-1}(x)=(x+k+1)\\%n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">%</span><span class=\"mord mathnormal\">n</span></span></span></span>。</p>\n<p>由于映射之后的序列和最初的序列具有同样的形式，即都是从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 开始的连续序列，因此仍然可以用函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 来表示，记为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo mathvariant=\"normal\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^\\prime(n-1,m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>。根据映射规则，映射之前的序列中最后剩下的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>p</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">[</mo><msup><mi>f</mi><mo mathvariant=\"normal\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">%</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">f(n-1,m)=p^{-1}[f^\\prime(n-1,m)+k+1]\\%n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mord\">%</span><span class=\"mord mathnormal\">n</span></span></span></span>。把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">%</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">k=(m-1)\\%n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">%</span><span class=\"mord mathnormal\">n</span></span></span></span> 代入得到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>f</mi><mo mathvariant=\"normal\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>m</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">%</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">f(n,m)=f^\\prime(n-1,m)=[f(n-1,m)+m]\\%n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span><span class=\"mord\">%</span><span class=\"mord mathnormal\">n</span></span></span></span>。</p>\n<p>由此可以得到递推公式：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>0</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>1</mn><mo separator=\"true\">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>m</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">%</mi><mi>n</mi><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">f(n,m) = \\begin{cases}\n0, &amp; \\text{if } n = 1;\\\\\n[f(n-1,m)+m]\\%n, &amp; \\text{if } n &gt; 1\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span><span class=\"mord\">%</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">;</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<h2 id=\"代码-7\"><a class=\"anchor\" href=\"#代码-7\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;list&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint simulate(unsigned int n, unsigned int m) &#123;\n    if (n &lt; 1 || m &lt; 1) &#123;\n        return -1;\n    &#125;\n\n    list&lt;int&gt; numbers;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        numbers.push_back(i);\n    &#125;\n\n    list&lt;int&gt;::iterator current = numbers.begin();\n    while (numbers.size() &gt; 1) &#123;\n        for (int i = 1; i &lt; m; ++i) &#123;\n            ++current;\n            if (current == numbers.end()) &#123;\n                current == numbers.begin();\n            &#125;\n        &#125;\n\n        list&lt;int&gt;::iterator next = ++current;\n        if (next == numbers.end()) &#123;\n            next = numbers.begin();\n        &#125;\n\n        --current;\n        numbers.erase(current);\n        current = next;\n    &#125;\n\n    return *(current);\n&#125;\n\n\nint analysis(unsigned int n, unsigned int m) &#123;\n    if (n &lt; 1 || m &lt; 1) &#123;\n        return -1;\n    &#125;\n\n    int last = 0;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        last = (last + m) % i;\n    &#125;\n\n    return last;\n&#125;\n</code></pre>\n<h1 id=\"面试题-63股票的最大利润\"><a class=\"anchor\" href=\"#面试题-63股票的最大利润\">#</a> 面试题 63：股票的最大利润</h1>\n<h2 id=\"题目-4\"><a class=\"anchor\" href=\"#题目-4\">#</a> 题目</h2>\n<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？例如，一只股票在某些时间节点的价格为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>11</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>12</mn><mo separator=\"true\">,</mo><mn>16</mn><mo separator=\"true\">,</mo><mn>14</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{9,11,8,5,7,12,16,14\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">11</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">12</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">16</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">14</span><span class=\"mclose\">}</span></span></span></span>。如果我们能在价格为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 的时候买入并在价格为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">16</span></span></span></span> 时卖出，则能收获最大的利润 11。</p>\n<h2 id=\"思路-8\"><a class=\"anchor\" href=\"#思路-8\">#</a> 思路</h2>\n<p>定义函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>diff</mtext><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{diff}(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">diff</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> 为当卖出价为数组中第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字时可能获得的最大利润。显然，在卖出价固定时，买入价越低获得的利润越大。也就是说，如果在扫描到数组中的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字时，只要能够记住之前的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个数字中的最小值，就能算出在当前价位卖出时可能得到的最大利润。</p>\n<h2 id=\"代码-8\"><a class=\"anchor\" href=\"#代码-8\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint max_diff(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.size() &lt; 2) &#123;\n        return 0;\n    &#125;\n\n    int min_val = numbers[0];\n    int max_diff = numbers[1] - min_val;\n\n    for (int i = 2; i &lt; numbers.size(); ++i) &#123;\n        if (numbers[i - 1] &lt; min_val) &#123;\n            min_val = numbers[i - 1];\n        &#125;\n\n        int cur_diff = numbers[i] - min_val;\n        if (cur_diff &gt; max_diff) &#123;\n            max_diff = cur_diff;\n        &#125;\n    &#125;\n\n    return max_diff;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-10/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-10/",
            "title": "剑指 Offer （十）",
            "date_published": "2021-09-30T13:04:51.000Z",
            "content_html": "<h1 id=\"面试题-53在排序数组中查找数字\"><a class=\"anchor\" href=\"#面试题-53在排序数组中查找数字\">#</a> 面试题 53：在排序数组中查找数字</h1>\n<h2 id=\"题目一数字在排序数组中出现的次数\"><a class=\"anchor\" href=\"#题目一数字在排序数组中出现的次数\">#</a> 题目一：数字在排序数组中出现的次数</h2>\n<p>统计一个数字在排序数组中出现的次数。例如，输入排序数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,3,3,3,3,4,5\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">}</span></span></span></span> 和数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>，由于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 在这个数组中出现了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span> 次，因此输出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>。</p>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p>由于输入的数组是有序的，那么我们只需要找到目标数字第一次和最后一次出现的位置，然后即可知道目标数字出现的次数。</p>\n<p>可以通过二分法查找目标数字的上界和下界。详细解析可以参考这个<a href=\"https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/\">链接</a>。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint binarySearch(vector&lt;int&gt;&amp; nums, int target, bool lower) &#123;\n    int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();\n    while (left &lt;= right) &#123;\n        int mid = (left + right) / 2;\n        if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;\n            right = mid - 1;\n            ans = mid;\n        &#125; else &#123;\n            left = mid + 1;\n        &#125;\n    &#125;\n    return ans;\n&#125;\n\nint search(vector&lt;int&gt;&amp; nums, int target) &#123;\n    int leftIdx = binarySearch(nums, target, true);\n    int rightIdx = binarySearch(nums, target, false) - 1;\n    if (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.size() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;\n        return rightIdx - leftIdx + 1;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"题目二0~n-1-中缺失的数字\"><a class=\"anchor\" href=\"#题目二0~n-1-中缺失的数字\">#</a> 题目二：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 中缺失的数字</h2>\n<p>一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 之内。在范围 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 内的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 这些数字在数组中是排序的，因此数组中开始的一些数字与它们的下标相同。即是说 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 在下标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 的位置，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 在下标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的位置，以此类推。如果不在数组中的那个数字记为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>，那么所有比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 小的数字的下标都与它们的值相同。由于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 不在数组中，那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">m+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 处在下标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 的位置，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">m+2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 处在下标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">m+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的位置，以此类推。可以发现 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 正好是数组中第一个数值和下标不相等的下标，因此这个问题转换成在排序数组中找出第一个值和下标不相等的元素。</p>\n<p>可以基于二分査找的算法用如下过程查找：如果中间元素的值和下标相等，那么下一轮只需要查找右半边；如果中间元素的值和下标不相等，并且它前面一个元素和它的下标相等，这意味着这个中间的数字正好是第一个值和下标不相等的元素，它的下标就是在数组中不存在的数字；如果中间元素的值和下标不相等，并且它前面一个元素和它的下标不相等，这意味着下一轮只需要在左半边查找即可。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint get_missing_number(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.empty()) &#123;\n        return -1;\n    &#125;\n\n    int left = 0;\n    int right = numbers.size() - 1;\n    while (left &lt;= right) &#123;\n        int mid = (left + right) &gt;&gt; 1;\n        if (numbers[mid] != mid) &#123;\n            if (mid == 0 || numbers[mid - 1] == mid - 1) &#123;\n                return mid;\n            &#125;\n            right = mid - 1;\n        &#125; else &#123;\n            left = mid + 1;\n        &#125;\n    &#125;\n\n    if (left == numbers.size()) &#123;\n        return left;\n    &#125;\n\n    return -1;\n&#125;\n</code></pre>\n<h2 id=\"题目三数组中数值和下标相等的元素\"><a class=\"anchor\" href=\"#题目三数组中数值和下标相等的元素\">#</a> 题目三：数组中数值和下标相等的元素</h2>\n<p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数，找出数组中任意一个数值等于其下标的元素。例如，在数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo>−</mo><mn>3</mn><mo separator=\"true\">,</mo><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{-3,-1,1,3,5\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">−</span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">}</span></span></span></span> 中，数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 和它的下标相等。</p>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>由于数组是单调递增排序的，因此可以用二分查找算法来进行查找：假设某一步抵达数组中的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字，且该数字的值刚好也是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，那么我们就找到了一个数字和其下标相等。</p>\n<p>如果数字的值和下标不相等，假设数字的值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>。</p>\n<p>先考虑 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的情形，即数字的值大于它的下标。由于数组中的所有数字都唯一并且单调递增，那么对于任意大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，位于下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">i+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的数字的值大于或等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">m+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。另外，因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">m&gt;i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，所以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>+</mo><mi>k</mi><mo>&gt;</mo><mi>i</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">m+k&gt;i+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。因此，位于下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">i+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的数字的值一定大于它的下标。这意味着如果第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字的值大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，那么它右边的数字都大于对应的下标，都可以忽略。下一轮只需要从它左边的数字中査找即可。数字的值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 小于它的下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的情形和上面类似。它左边的所有数字的值都小于对应的下标，也可以忽略。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint get_number_same_as_index(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.empty()) &#123;\n        return -1;\n    &#125;\n\n    int left = 0;\n    int right = numbers.size() - 1;\n    while (left &lt;= right) &#123;\n        int mid = (left + right) &gt;&gt; 1;\n        if (numbers[mid] == mid) &#123;\n            return mid;\n        &#125;\n\n        if (numbers[mid] &gt; mid) &#123;\n            right = mid - 1;\n        &#125; else &#123;\n            left = mid + 1;\n        &#125;\n    &#125;\n\n    return -1;\n&#125;\n</code></pre>\n<h1 id=\"面试题-54二叉搜索树的第-k-大节点\"><a class=\"anchor\" href=\"#面试题-54二叉搜索树的第-k-大节点\">#</a> 面试题 54：二叉搜索树的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 大节点</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>给定一棵二叉搜索树，请找出其中第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 大的节点。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>如果按照中序遍历的顺序遍历一棵二叉搜索树，则遍历序列的数值是递增排序的。因此，只需要用中序遍历算法遍历一棵二叉搜索树，就可以很容易找出它的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 大节点。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nBinaryTreeNode *get_Kth_node_core(BinaryTreeNode *root, unsigned int &amp;k) &#123;\n    BinaryTreeNode *target = nullptr;\n\n    if (root-&gt;m_left != nullptr) &#123;\n        target = get_Kth_node_core(root-&gt;m_left, k);\n    &#125;\n\n    if (target == nullptr) &#123;\n        if (k == 1) &#123;\n            target = root;\n        &#125;\n        k--;\n    &#125;\n\n    if (target == nullptr &amp;&amp; root-&gt;m_right != nullptr) &#123;\n        target = get_Kth_node_core(root-&gt;m_right, k);\n    &#125;\n\n    return target;\n&#125;\n\nBinaryTreeNode *get_Kth_node(BinaryTreeNode *root, unsigned int k) &#123;\n    if (root == nullptr || k == 0) &#123;\n        return nullptr;\n    &#125;\n\n    return get_Kth_node_core(root, k);\n&#125;\n</code></pre>\n<h1 id=\"面试题-55二叉树的深度\"><a class=\"anchor\" href=\"#面试题-55二叉树的深度\">#</a> 面试题 55：二叉树的深度</h1>\n<h2 id=\"题目一二叉树的深度\"><a class=\"anchor\" href=\"#题目一二叉树的深度\">#</a> 题目一：二叉树的深度</h2>\n<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>如果一棵树只有一个节点，那么它的深度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。如果根节点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；同样，如果根节点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。如果既有右子树又有左子树，那么该树的深度就是其左、右子树深度的较大值再加 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nint depth_of_tree(BinaryTreeNode *root) &#123;\n    if (root == nullptr) &#123;\n        return 0;\n    &#125;\n\n    int left = depth_of_tree(root-&gt;m_left);\n    int right = depth_of_tree(root-&gt;m_right);\n\n    return max(left, right) + 1;\n&#125;\n</code></pre>\n<h2 id=\"题目二平衡二叉树\"><a class=\"anchor\" href=\"#题目二平衡二叉树\">#</a> 题目二：平衡二叉树</h2>\n<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左、右子树的深度相差不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，那么它就是一棵平衡二叉树。</p>\n<h2 id=\"思路-6\"><a class=\"anchor\" href=\"#思路-6\">#</a> 思路</h2>\n<p>用后序遍历的方式遍历二叉树的每个节点，那么在遍历到一个节点之前已经遍历了它的左、右子树。只要在遍历每个节点的时候记录它的深度，就可以一边遍历一边判断每个节点是不是平衡的。</p>\n<h2 id=\"代码-6\"><a class=\"anchor\" href=\"#代码-6\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\n\nbool is_balanced(BinaryTreeNode *root, int &amp;depth) &#123;\n    if (root == nullptr) &#123;\n        depth = 0;\n        return true;\n    &#125;\n\n    int left, right;\n    if (is_balanced(root-&gt;m_left, left) &amp;&amp;\n        is_balanced(root-&gt;m_right, right)) &#123;\n        int diff = left - right;\n        if (abs(diff) &lt;= 1) &#123;\n            depth = max(left, right) + 1;\n            return true;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n\nbool is_balanced(BinaryTreeNode *root) &#123;\n    int depth = 0;\n    return is_balanced(root, depth);\n&#125;\n</code></pre>\n<h1 id=\"面试题-56数组中数字出现的次数\"><a class=\"anchor\" href=\"#面试题-56数组中数字出现的次数\">#</a> 面试题 56：数组中数字出现的次数</h1>\n<h2 id=\"题目一数组中只出现一次的两个数字\"><a class=\"anchor\" href=\"#题目一数组中只出现一次的两个数字\">#</a> 题目一：数组中只出现一次的两个数字</h2>\n<p>一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，空间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"思路-7\"><a class=\"anchor\" href=\"#思路-7\">#</a> 思路</h2>\n<p>异或运算具有一个性质：任何一个数字异或它自己都等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>。也就是说，如果从头到尾依次异或数组中的每个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些成对出现两次的数字全部在异或中抵消了。</p>\n<p>如果能够把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现两次，那么就可以利用异或得到这个数字。</p>\n<p>如果从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果，因为其他数都出现了两次，在异或中全部抵消了。由于这两个数字肯定不同，那么异或的结果一定不为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，也就是说，在这个结果数字的二进制表示中至少有一位为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。我们在结果数字中找到第一个为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的位的位置，记为第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 位。</p>\n<p>现在以第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 位是否为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 位都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，而第二个子数组中每个数字的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 位都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>。两个相同的数字的任意一位都是相同的，因此它们必定分在同一个数组中。每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。之后便可以通过异或运算的方式得到只出现一次的数字。</p>\n<h2 id=\"代码-7\"><a class=\"anchor\" href=\"#代码-7\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nbool is_bit_one(int num, unsigned int index_bit) &#123;\n    num = num &gt;&gt; index_bit;\n    return (num &amp; 1);\n&#125;\n\nunsigned int find_first_bit_one(int num) &#123;\n    int index_bit = 0;\n    while (((num &amp; 1) == 0) &amp;&amp; (index_bit &lt; 8 * sizeof(int))) &#123;\n        num = num &gt;&gt; 1;\n        ++index_bit;\n    &#125;\n\n    return index_bit;\n&#125;\n\nvector&lt;int&gt; find_number_appear_once(vector&lt;int&gt; &amp;data) &#123;\n    vector&lt;int&gt; ans;\n    if (data.empty()) &#123;\n        return ans;\n    &#125;\n\n    int result_XOR = 0;\n    for (int i = 0; i &lt; data.size(); ++i) &#123;\n        result_XOR ^= data[i];\n    &#125;\n\n    unsigned int index_of_one = find_first_bit_one(result_XOR);\n\n    ans.push_back(0);\n    ans.push_back(0);\n\n    for (int j = 0; j &lt; data.size(); ++j) &#123;\n        if (is_bit_one(data[j], index_of_one)) &#123;\n            ans[0] ^= data[j];\n        &#125; else &#123;\n            ans[1] ^= data[j];\n        &#125;\n    &#125;\n    return ans;\n&#125;\n</code></pre>\n<h2 id=\"题目二数组中唯一只出现一次的数字\"><a class=\"anchor\" href=\"#题目二数组中唯一只出现一次的数字\">#</a> 题目二：数组中唯一只出现一次的数字</h2>\n<p>在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>\n<h2 id=\"思路-8\"><a class=\"anchor\" href=\"#思路-8\">#</a> 思路</h2>\n<p>如果数组中的数字除一个只出现一次之外，其他数字都出现了两次。我们可以用异或位运算解决这个简化的问题。</p>\n<p>尽管这里不能应用异或运算，还是可以沿用位运算的思路。如果一个数字出现三次，那么它的二进制表示的每一位（<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 或者<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>）也出现三次。如果把所有出现三次的数字的二进制表示的每一位都分别加<br />\n起来，那么每一位的和都能被 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 整除。</p>\n<p>如果某一位的和能被 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 整除，那么那个只出现一次的数字二进制表示中对应的那一位是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>；否则就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<h2 id=\"代码-8\"><a class=\"anchor\" href=\"#代码-8\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint find_number_appearing_once(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.empty()) &#123;\n        throw &quot;Invalid input.&quot;;\n    &#125;\n\n    int bit_sum[32] = &#123;0&#125;;\n    for (int i = 0; i &lt; numbers.size(); ++i) &#123;\n        int bit_mask = 1;\n        for (int j = 31; j &gt;= 0; --j) &#123;\n            int bit = numbers[i] &amp; bit_mask;\n            if (bit != 0) &#123;\n                bit_sum[j] += 1;\n            &#125;\n            bit_mask = bit_mask &lt;&lt; 1;\n        &#125;\n    &#125;\n\n    int ans = 0;\n    for (int i = 0; i &lt; 32; ++i) &#123;\n        ans = ans &lt;&lt; 1;\n        ans += bit_sum[i] % 3;\n    &#125;\n\n    return ans;\n&#125;\n</code></pre>\n<h1 id=\"面试题-57和为-s-的数字\"><a class=\"anchor\" href=\"#面试题-57和为-s-的数字\">#</a> 面试题 57：和为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 的数字</h1>\n<h2 id=\"题目一和为-s-的两个数字\"><a class=\"anchor\" href=\"#题目一和为-s-的两个数字\">#</a> 题目一：和为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 的两个数字</h2>\n<p>输入一个递增排序的数组和一个数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 在数组中査找两个数，使得它们的和正好是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>。如果有多对数字的和等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>，则输出任意一对即可。</p>\n<h2 id=\"思路-9\"><a class=\"anchor\" href=\"#思路-9\">#</a> 思路</h2>\n<p>由于数组是有序的，使用双指针法， <code>left</code>  和  <code>right</code>  一开始分别指向最小和最大的数字。如果当前  <code>left</code>  和  <code>right</code>  指向的数字之和大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>，则左移  <code>right</code> ；如果和小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>，则右移  <code>left</code> ；如果和等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>，则找到这样的一组数；如果  <code>left</code>  和  <code>right</code>  指向了相同的数字，那么说明数组中不存在这样的一组数。</p>\n<h2 id=\"代码-9\"><a class=\"anchor\" href=\"#代码-9\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; find_numbers_with_sum(vector&lt;int&gt; &amp;data, int target) &#123;\n    vector&lt;int&gt; ans;\n\n    if (data.empty()) &#123;\n        return ans;\n    &#125;\n\n    int left = 0, right = data.size() - 1;\n    while (left &lt; right) &#123;\n        long long cur_sum = data[left] + data[right];\n        if (cur_sum == target) &#123;\n            ans.push_back(data[left]);\n            ans.push_back(data[right]);\n            break;\n        &#125; else if (cur_sum &gt; target) &#123;\n            --right;\n        &#125; else &#123;\n            ++left;\n        &#125;\n    &#125;\n\n    return ans;\n&#125;\n</code></pre>\n<h2 id=\"题目二和为-s-的连续正数序列\"><a class=\"anchor\" href=\"#题目二和为-s-的连续正数序列\">#</a> 题目二：和为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 的连续正数序列</h2>\n<p>输入一个正数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>，打印出所有和为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 的连续正数序列（至少含有两个数)。</p>\n<h2 id=\"思路-10\"><a class=\"anchor\" href=\"#思路-10\">#</a> 思路</h2>\n<p>用两个数  <code>small</code>  和  <code>large</code>  分别表示序列的最小值和最大值。首先把  <code>small</code>  初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>， <code>large</code>  初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>。如果从  <code>small</code>  到  <code>large</code>  的序列的和大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>，则可以从序列中去掉较小的值，也就是增大  <code>small</code>  的值。如果从  <code>small</code>  到  <code>large</code>  的序列的和小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>，则可以增大 <code>large</code> ，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加  <code>small</code>  到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">(1+s)/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mord\">/2</span></span></span></span> 为止。</p>\n<h2 id=\"代码-10\"><a class=\"anchor\" href=\"#代码-10\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid print(int small, int large) &#123;\n    for (int i = small; i &lt;= large; ++i) &#123;\n        cout &lt;&lt; i &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid find_continuous_sequence_with_sum(int sum) &#123;\n    if (sum &lt; 3) &#123;\n        return;\n    &#125;\n\n    int small = 1;\n    int large = 2;\n    int mid = (1 + sum) / 2;\n    int cur_sum = small + large;\n\n    while (small &lt; mid) &#123;\n        if (cur_sum == sum) &#123;\n            print(small, large);\n        &#125;\n\n        while (cur_sum &gt; sum &amp;&amp; small &lt; mid) &#123;\n            cur_sum -= small;\n            ++small;\n\n            if (cur_sum == sum) &#123;\n                print(small, large);\n            &#125;\n        &#125;\n\n        ++large;\n        cur_sum += large;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-9/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-9/",
            "title": "剑指 Offer （九）",
            "date_published": "2021-09-30T11:02:27.000Z",
            "content_html": "<h1 id=\"面试题-49丑数\"><a class=\"anchor\" href=\"#面试题-49丑数\">#</a> 面试题 49：丑数</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>我们把只包含因子 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1500</mn></mrow><annotation encoding=\"application/x-tex\">1500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1500</span></span></span></span> 个丑数。例如，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 都是丑数，但 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>14</mn></mrow><annotation encoding=\"application/x-tex\">14</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">14</span></span></span></span> 不是，因为它包含因子 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">7</span></span></span></span>。习惯上把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 当作第一个丑数。</p>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p>比较直观的做法是从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 开始，判断一个数是否是丑数，直到找到第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1500</mn></mrow><annotation encoding=\"application/x-tex\">1500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1500</span></span></span></span> 个丑数，但是这样的做法效率不高。</p>\n<p>换一种思路。丑数的因子只有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 这三种，对于任意一个丑数，可以分解成只包含这些因子的式子。对于每个因子，使用一个计数值来表示该因子的个数。那么对于任意一个丑数，都可以用这样的一个三元组来表示。</p>\n<p>不妨设  <code>factor_2</code> 、 <code>factor_3</code>  和  <code>factor_5</code>  表示每个因子的数量。我们需要一种方法来有序的遍历每个丑数。对于一个丑数，将其乘以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 中的任意一个因子，都可以得到另一个丑数。我们不妨设当前得到的最大的三个丑数是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>M</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_1,M_2,M_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 并且满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>M</mi><mn>2</mn></msub><mo>&lt;</mo><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_1 &lt; M_2 &lt; M_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，那么下一个丑数必定是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>×</mo><mn>5</mn><mo separator=\"true\">,</mo><msub><mi>M</mi><mn>2</mn></msub><mo>×</mo><mn>3</mn><mo separator=\"true\">,</mo><msub><mi>M</mi><mn>3</mn></msub><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">M_1 \\times 5, M_2\\times 3, M_3\\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 中的最小值。通过这样的方式，可以有序地遍历丑数，从而找到目标的丑数。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n\nusing namespace std;\n\nint get_ugly_number(int n) &#123;\n    vector&lt;int&gt; vec = &#123;1&#125;;\n    int p_2 = 0, p_3 = 0, p_5 = 0;\n    for (int i = 1; i &lt; n; ++i) &#123;\n        int val = min(2 * vec[p_2], min(3 * vec[p_3], 5 * vec[p_5]));\n        if (val == 2 * vec[p_2]) &#123;\n            ++p_2;\n        &#125;\n        if (val == 3 * vec[p_3]) &#123;\n            ++p_3;\n        &#125;\n        if (val == 5 * vec[p_5]) &#123;\n            ++p_5;\n        &#125;\n        vec.push_back(val);\n    &#125;\n    return vec.back();\n&#125;\n</code></pre>\n<h1 id=\"面试题-50第一个只出现一次的字符\"><a class=\"anchor\" href=\"#面试题-50第一个只出现一次的字符\">#</a> 面试题 50：第一个只出现一次的字符</h1>\n<h2 id=\"题目一字符串中第一个只出现一次的字符\"><a class=\"anchor\" href=\"#题目一字符串中第一个只出现一次的字符\">#</a> 题目一：字符串中第一个只出现一次的字符</h2>\n<p>在字符串中找出第一个只出现一次的字符。如输入  <code>abaccdeff</code> ，则输出  <code>b</code> 。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>使用一个哈希表，哈希表的键值（Key）定义为字符，值（Value）为该字符出现的次数。</p>\n<p>第一次扫描字符串时，每扫描到一个字符，就在哈希表的对应项中把次数加 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。接下来第二次扫描时，每扫描到一个字符，就能从哈希表中得到该字符出现的次数。这样，第一个只出现一次的字符就是符合要求的输出。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nchar first_not_repeating_char(string &amp;str) &#123;\n    unordered_map&lt;char, int&gt; table;\n    char ans = '0';\n    for (char c : str) &#123;\n        table[c]++;\n    &#125;\n\n    for (char c : str) &#123;\n        if (table[c] == 1) &#123;\n            ans = c;\n            break;\n        &#125;\n    &#125;\n\n    return ans;\n&#125;\n</code></pre>\n<h2 id=\"题目二字符流中第一个只出现一次的字符\"><a class=\"anchor\" href=\"#题目二字符流中第一个只出现一次的字符\">#</a> 题目二：字符流中第一个只出现一次的字符</h2>\n<p>请实现一个函数，用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符  <code>go</code>  时，第一个只出现一次的字符是  <code>g</code> ；当从该字符流中读出前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span> 个字符  <code>google</code>  时，第一个只出现一次的字符是  <code>l</code> 。</p>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>和题目一的思路类似。注意点在于，当一个字符第一次从字符流中读取到时，将其存储到某个容器中；而当该字符再次出现时，将其从容器中删除。需要记录只出现一次的字符的下标。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<p>略。</p>\n<h1 id=\"面试题-51数组中的逆序对\"><a class=\"anchor\" href=\"#面试题-51数组中的逆序对\">#</a> 面试题 51：数组中的逆序对</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如，在数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>4</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{7,5,6,4\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">}</span></span></span></span> 中，一共存在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 个逆序对，分别是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>6</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(7,6)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(7,5)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>4</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(7,4)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>4</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(6,4)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>4</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(5,4)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>先把数组分隔成子数组，统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。整个过程类似于归并排序。</p>\n<p>详细解析参考<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h/\">链接</a>。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint inverse_pairs(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;tmp, int left, int right) &#123;\n    if (left &gt;= right) &#123;\n        return 0;\n    &#125;\n\n    int mid = (left + right) / 2;\n    int ans = inverse_pairs(nums, tmp, left, mid) + inverse_pairs(nums, tmp, mid + 1, right);\n\n    // Merge\n    int i = left, j = mid + 1;\n    for (int k = left; k &lt;= right; ++k) &#123;\n        tmp[k] = nums[k];\n    &#125;\n    for (int k = left; k &lt;= right; ++k) &#123;\n        if (i == mid + 1) &#123;\n            nums[k] = tmp[j++];\n        &#125; else if (j == right + 1 || tmp[i] &lt;= tmp[j]) &#123;\n            nums[k] = tmp[i++];\n        &#125; else &#123;\n            nums[k] = tmp[j++];\n            ans += mid - i + 1; // inverse pairs\n        &#125;\n    &#125;\n\n    return ans;\n&#125;\n\nint inverse_pairs(vector&lt;int&gt; &amp;nums) &#123;\n    vector&lt;int&gt; tmp(nums.size());\n    return inverse_pairs(nums, tmp, 0, nums.size() - 1);\n&#125;\n</code></pre>\n<h1 id=\"面试题-52两个链表的第一个公共节点\"><a class=\"anchor\" href=\"#面试题-52两个链表的第一个公共节点\">#</a> 面试题 52：两个链表的第一个公共节点</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>输入两个链表，找出它们的第一个公共节点。链表节点定义如下：</p>\n<pre><code class=\"language-cpp\">struct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n</code></pre>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>如果两个单向链表有公共的节点，那么这两个链表从某一节点开始，它们的  <code>m_next</code>  都指向同一个节点。因此从第一个公共节点开始，之后它们所有的节点都是重合的，不可能再出现分叉。所以两个有公共节点而部分重合的链表，其拓扑形状看起来像一个  <code>Y</code> ，而不可能像  <code>X</code> 。我们可以先遍历一次得到两个链表的长度，第二次先在长的链表上走它比短链表多出来的节点数目。接下来两个链表同时遍历，直到找到它们第一个相同的节点，这就是目标节点。</p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n\nListNode *find_first_common_node(ListNode *head1, ListNode *head2) &#123;\n    int len1 = 0, len2 = 0;\n    ListNode *ptr1 = head1;\n    ListNode *ptr2 = head2;\n    while (ptr1) &#123;\n        ++len1;\n        ptr1 = ptr1-&gt;m_next;\n    &#125;\n    while (ptr2) &#123;\n        ++len2;\n        ptr2 = ptr2-&gt;m_next;\n    &#125;\n\n    if (len2 &gt; len1) &#123;\n        swap(head1, head2);\n        swap(len1, len2);\n    &#125;\n\n    ptr1 = head1;\n    ptr2 = head2;\n\n    for (int i = 0; i &lt; len1 - len2; ++i) &#123;\n        ptr1 = ptr1-&gt;m_next;\n    &#125;\n\n    while (ptr1 != nullptr &amp;&amp;\n           ptr2 != nullptr &amp;&amp;\n           ptr1 != ptr2) &#123;\n        ptr1 = ptr1-&gt;m_next;\n        ptr2 = ptr2-&gt;m_next;\n    &#125;\n\n    return ptr1;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-8/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-8/",
            "title": "剑指 Offer （八）",
            "date_published": "2021-09-30T06:29:01.000Z",
            "content_html": "<h1 id=\"面试题-39数组中出现次数超过一半的数字\"><a class=\"anchor\" href=\"#面试题-39数组中出现次数超过一半的数字\">#</a> 面试题 39：数组中出现次数超过一半的数字</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span> 的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,3,2,2,2,5,4,2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span>。由于数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 在数组中出现了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 次，超过数组长度的一半，因此输出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>。</p>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<h3 id=\"解法一基于-partition-函数的时间复杂度为-on-的算法\"><a class=\"anchor\" href=\"#解法一基于-partition-函数的时间复杂度为-on-的算法\">#</a> 解法一：基于  <code>Partition</code>  函数的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法</h3>\n<p>对于一个出现次数超过数组长度一半的数字，如果把数组排序，那么排序之后位于数组中间的数字一定就是所求的目标数字。即长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的数组中第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/2</span></span></span></span> 大的数字。对于数组中任意第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 大的数字，有时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法可以求得。</p>\n<p>这种算法受快速排序算法的启发。在随机快速排序算法中，先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个选中的数字的下标刚好是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/2</span></span></span></span>，那么这个数字就是数组的中位数；如果它的下标大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/2</span></span></span></span>，那么中位数位于它的左边，可以接着在它的左边部分的数组中查找；如果它的下标小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/2</span></span></span></span>，那么中位数位于它的右边，可以接着在它的右边部分的数组中查找。</p>\n<h3 id=\"解法二基于数组特点的时间复杂度为-on-的算法\"><a class=\"anchor\" href=\"#解法二基于数组特点的时间复杂度为-on-的算法\">#</a> 解法二：基于数组特点的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法</h3>\n<p>数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此，可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字；另一个是该数字出现的次数。当遍历到下一个数字的时候，如果下一个数字和之前保存的数字相同，则次数加 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；如果和之前保存的数字不同，则次数减 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。如果次数为零，那么需要保存下一个数字，并把次数设为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。由于要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 时对应的数字。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<h3 id=\"解法一\"><a class=\"anchor\" href=\"#解法一\">#</a> 解法一</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint partition(vector&lt;int&gt; &amp;numbers, int start, int end) &#123;\n    if (start == end) &#123;\n        return start;\n    &#125;\n    int pivot = numbers[start];\n    int left = start, right = end;\n    while (left &lt; right) &#123;\n        while (numbers[right] &gt;= pivot) &#123;\n            --right;\n        &#125;\n        numbers[left] = numbers[right];\n        while (numbers[left] &lt;= pivot) &#123;\n            ++left;\n        &#125;\n        numbers[right] = numbers[left];\n    &#125;\n\n    numbers[left] = pivot;\n    return left;\n&#125;\n\nint more_than_half_number(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.empty()) &#123;\n        return 0;\n    &#125;\n\n    int mid = numbers.size() &gt;&gt; 2;\n    int start = 0;\n    int end = numbers.size() - 1;\n    int index = partition(numbers, start, end);\n    while (index != mid) &#123;\n        if (index &gt; mid) &#123;\n            end = index - 1;\n            index = partition(numbers, start, end);\n        &#125; else &#123;\n            start = index + 1;\n            index = partition(numbers, start, end);\n        &#125;\n    &#125;\n\n    int result = numbers[mid];\n    return result;\n&#125;\n\n</code></pre>\n<h3 id=\"解法二\"><a class=\"anchor\" href=\"#解法二\">#</a> 解法二</h3>\n<pre><code class=\"language-cpp\">int more_than_half_numbers(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.empty()) &#123;\n        return 0;\n    &#125;\n    int result = numbers[0];\n    int times = 1;\n    for (int i = 1; i &lt; numbers.size(); ++i) &#123;\n        if (times == 0) &#123;\n            result = numbers[i];\n            times = 1;\n        &#125; else if (numbers[i] == result) &#123;\n            ++times;\n        &#125; else &#123;\n            --times;\n        &#125;\n    &#125;\n    return result;\n&#125;\n</code></pre>\n<h1 id=\"面试题-40最小的-k-个数\"><a class=\"anchor\" href=\"#面试题-40最小的-k-个数\">#</a> 面试题 40：最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>输入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个整数，找出其中最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数。例如，输入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">7</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 个数字，则最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span> 个数字是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<h3 id=\"解法一时间复杂度为-on-的算法需要修改输入的数组\"><a class=\"anchor\" href=\"#解法一时间复杂度为-on-的算法需要修改输入的数组\">#</a> 解法一：时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法，需要修改输入的数组</h3>\n<p>可以基于  <code>partition</code>  函数来解决这个问题。如果基于数组的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字来调整，则使得比第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字小的所有数字都位于数组的左边，比第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字大的所有数字都位于数组的右边。这样调整之后，位于数组中左边的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字就是最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字（这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字不一定是有序的）。</p>\n<h3 id=\"解法二时间复杂度为-onlog-k-的算法适合处理海量数据\"><a class=\"anchor\" href=\"#解法二时间复杂度为-onlog-k-的算法适合处理海量数据\">#</a> 解法二：时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> 的算法，适合处理海量数据</h3>\n<p>可以选择用最大堆来实现存储这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数据。在最大堆中，根节点的值总是大于它的子树中任意节点的值，可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间内得到己有的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字中的最大值，但需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> 时间完成删除及插入操作。</p>\n<p>如果容器中己有的数字少于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个，则直接把这次读入的整数放入容器之中；如果容器中己有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字了，找出这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数中的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前己有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个整数之一，于是可以丢弃这个数。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<h3 id=\"解法一-2\"><a class=\"anchor\" href=\"#解法一-2\">#</a> 解法一</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint partition(vector&lt;int&gt; &amp;numbers, int start, int end) &#123;\n    if (start == end) &#123;\n        return start;\n    &#125;\n    int pivot = numbers[start];\n    int left = start, right = end;\n    while (left &lt; right) &#123;\n        while (numbers[right] &gt;= pivot) &#123;\n            --right;\n        &#125;\n        numbers[left] = numbers[right];\n        while (numbers[left] &lt;= pivot) &#123;\n            ++left;\n        &#125;\n        numbers[right] = numbers[left];\n    &#125;\n\n    numbers[left] = pivot;\n    return left;\n&#125;\n\nvector&lt;int&gt; get_least_k_numbers(vector&lt;int&gt; &amp;numbers, int k) &#123;\n    vector&lt;int&gt; ans;\n    if (numbers.empty() || k &gt; numbers.size() || k &lt;= 0) &#123;\n        return ans;\n    &#125;\n\n    int start = 0;\n    int end = numbers.size() - 1;\n    int index = partition(numbers, start, end);\n    while (index != k - 1) &#123;\n        if (index &gt; k - 1) &#123;\n            end = index - 1;\n            index = partition(numbers, start, end);\n        &#125; else &#123;\n            start = index + 1;\n            index = partition(numbers, start, end);\n        &#125;\n    &#125;\n\n    for (int i = 0; i &lt; k; ++i) &#123;\n        ans.push_back(numbers[i]);\n    &#125;\n\n    return ans;\n&#125;\n</code></pre>\n<h3 id=\"解法二-2\"><a class=\"anchor\" href=\"#解法二-2\">#</a> 解法二</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;functional&gt;\n\nusing namespace std;\n\ntypedef multiset&lt;int, greater&lt;int&gt;&gt; int_set;\ntypedef multiset&lt;int, greater&lt;int&gt;&gt;::iterator set_iterator;\n\nvoid get_least_k_numbers(const vector&lt;int&gt; &amp;data, int_set &amp;least_k_numbers, int k) &#123;\n    least_k_numbers.clear();\n\n    if (k &lt; 1 || data.size() &lt; k) &#123;\n        return;\n    &#125;\n\n    vector&lt;int&gt;::const_iterator iter = data.begin();\n    for ( ; iter != data.end(); ++iter) &#123;\n        if (least_k_numbers.size() &lt; k) &#123;\n            least_k_numbers.insert(*iter);\n        &#125; else &#123;\n            set_iterator iter_greatest = least_k_numbers.begin();\n\n            if (*iter &lt; *(least_k_numbers.begin())) &#123;\n                least_k_numbers.erase(iter_greatest);\n                least_k_numbers.insert(*iter);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"面试题-42数据流中的中位数\"><a class=\"anchor\" href=\"#面试题-42数据流中的中位数\">#</a> 面试题 42：数据流中的中位数</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>可以用两个容器储存数据流中的数据。左边的容器存储当前已读取数据的较小的一部分，右边的容器存储当前已读取数据的较大的一部分。两个容器存储的数据数量尽可能均分。我们关心的其实是数据流中间的数字。可以用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。只需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间就可以得到位于堆顶的数据，因此得到中位数的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>为了实现平均分配，可以在数据的总数目是偶数时把新数据插入最小堆，否则插入最大堆。还要保证最大堆中的所有数据都要小于最小堆中的数据。当数据的总数目是偶数时，可以先把这个新的数据插入最大堆，接着把最大堆中最大的数字拿出来插入最小堆。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass DynamicArray &#123;\npublic:\n    void insert(T num) &#123;\n        if (((min.size() + max.size()) &amp; 1) == 0) &#123;\n            if (max.size() &gt; 0 &amp;&amp; num &lt; max[0]) &#123;\n                max.push_back(num);\n                push_heap(max.begin(), max.end(), less&lt;T&gt;());\n\n                num = max[0];\n\n                pop_heap(max.begin(), max.end(), less&lt;T&gt;());\n                max.pop_back();\n            &#125;\n\n            min.push_back(num);\n            push_heap(min.begin(), min.end(), greater&lt;T&gt;());\n        &#125; else &#123;\n            if (min.size() &gt; 0 &amp;&amp; min[0] &lt; num) &#123;\n                min.push_back(num);\n                push_heap(min.begin(), min.end(), greater&lt;T&gt;());\n\n                num = min[0];\n\n                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());\n                min.pop_back();\n            &#125;\n\n            max.push_back(num);\n            push_heap(max.begin(), max.end(), less&lt;T&gt;());\n        &#125;\n    &#125;\n\n    T get_median() &#123;\n        int size = min.size() + max.size();\n        if (size == 0) &#123;\n            throw &quot;No numbers are available&quot;;\n        &#125;\n\n        T median = 0;\n        if ((size &amp; 1) == 1) &#123;\n            median = min[0];\n        &#125; else &#123;\n            median = (min[0] + max[0]) / 2;\n        &#125;\n        return median;\n    &#125;\n\nprivate:\n    vector&lt;T&gt; min;\n    vector&lt;T&gt; max;\n&#125;;\n</code></pre>\n<h1 id=\"面试题-42连续子数组的最大和\"><a class=\"anchor\" href=\"#面试题-42连续子数组的最大和\">#</a> 面试题 42：连续子数组的最大和</h1>\n<h2 id=\"题目-4\"><a class=\"anchor\" href=\"#题目-4\">#</a> 题目</h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>动态规划的转移函数：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mtext> or </mtext><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>0</mn><mo separator=\"true\">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>i</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn><mtext> and </mtext><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">f(i) = \\begin{cases}\nA[i], &amp; i = 0 \\text{ or } f(i-1) \\le 0;\\\\\nf(i-1) + A[i], &amp; i \\ne 0 \\text{ and } f(i-1) &gt; 0\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> or </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">;</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> and </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>当以第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个数字结尾的子数组中所有数字的和小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 时，如果把这个负数与第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数累加，则得到的结果比第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字本身还要小，所以这种情况下以第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字结尾的子数组就是第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字本身。如果以第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个数字结尾的子数组中所有数字的和大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，则与第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字累加就得到以第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字结尾的子数组中所有数字的和。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint find_greatest_sum_of_subarray(vector&lt;int&gt; &amp;data) &#123;\n    if (data.empty()) &#123;\n        return 0;\n    &#125;\n\n    int current_sum = 0;\n    int greatest_sum = 0x80000000;\n    for (int i = 0; i &lt; data.size(); ++i) &#123;\n        if (current_sum &lt;= 0) &#123;\n            current_sum = data[i];\n        &#125; else &#123;\n            current_sum += data[i];\n        &#125;\n\n        if (current_sum &gt; greatest_sum) &#123;\n            greatest_sum = current_sum;\n        &#125;\n    &#125;\n\n    return greatest_sum;\n&#125;\n</code></pre>\n<h1 id=\"面试题-431~n-整数中-1-出现的次数\"><a class=\"anchor\" href=\"#面试题-431~n-整数中-1-出现的次数\">#</a> 面试题 43：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext> </mtext><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1~n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\">n</span></span></span></span> 整数中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 出现的次数</h1>\n<h2 id=\"题目-5\"><a class=\"anchor\" href=\"#题目-5\">#</a> 题目</h2>\n<p>输入一个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，求 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个整数的十进制表示中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 出现的次数。</p>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>详细思路见<a href=\"https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/\">链接</a>.</p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nint counti_digit_one(int n) &#123;\n    unsigned int digit = 1;\n    int res = 0;\n    int high = n / 10, cur = n % 10, low = 0;\n    while(high != 0 || cur != 0) &#123;\n        if(cur == 0) res += high * digit;\n        else if(cur == 1) res += high * digit + low + 1;\n        else res += (high + 1) * digit;\n        low += cur * digit;\n        cur = high % 10;\n        high /= 10;\n        digit *= 10;\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h1 id=\"面试题-44数字序列中某一位的数字\"><a class=\"anchor\" href=\"#面试题-44数字序列中某一位的数字\">#</a> 面试题 44：数字序列中某一位的数字</h1>\n<h2 id=\"题目-6\"><a class=\"anchor\" href=\"#题目-6\">#</a> 题目</h2>\n<p>数字以  <code>0123456789101112131415...</code>  的格式序列化到一个字符序列中。在这个序列中，第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 位（从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 开始计数）是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span>，第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>13</mn></mrow><annotation encoding=\"application/x-tex\">13</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">13</span></span></span></span> 位是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>19</mn></mrow><annotation encoding=\"application/x-tex\">19</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">19</span></span></span></span> 位是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>，等等。请写一个函数，求任意第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 位对应的数字。</p>\n<h2 id=\"思路-6\"><a class=\"anchor\" href=\"#思路-6\">#</a> 思路</h2>\n<p>见<a href=\"https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/\">链接</a>。</p>\n<h2 id=\"代码-6\"><a class=\"anchor\" href=\"#代码-6\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nint find_Nth_digit(int n) &#123;\n    int digit = 1;\n    long long start = 1;\n    long long count = 9;\n    while (n &gt; count) &#123; // 1.\n        n -= count;\n        digit += 1;\n        start *= 10;\n        count = digit * start * 9;\n    &#125;\n    long long num = start + (n - 1) / digit; // 2.\n    return to_string(num)[(n - 1) % digit] - '0'; // 3.\n&#125;\n</code></pre>\n<h1 id=\"面试题-45把数组排成最小的数\"><a class=\"anchor\" href=\"#面试题-45把数组排成最小的数\">#</a> 面试题 45：把数组排成最小的数</h1>\n<h2 id=\"题目-7\"><a class=\"anchor\" href=\"#题目-7\">#</a> 题目</h2>\n<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如，输入数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>32</mn><mo separator=\"true\">,</mo><mn>321</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{3,32,321\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">32</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">321</span><span class=\"mclose\">}</span></span></span></span>，则打印出这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 个数字能排成的最小数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>321323</mn></mrow><annotation encoding=\"application/x-tex\">321323</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">321323</span></span></span></span>。</p>\n<h2 id=\"思路-7\"><a class=\"anchor\" href=\"#思路-7\">#</a> 思路</h2>\n<p>根据题目的要求，两个数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 能拼接成数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">mn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">mn</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">nm</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">nm</span></span></span></span>。如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>n</mi><mo>&lt;</mo><mi>n</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">mn &lt; nm</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">mn</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">nm</span></span></span></span>，那么应该打印出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">mn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">mn</span></span></span></span>，也就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 应该排在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的前面，我们定义此时 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>。反之，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>m</mi><mo>&lt;</mo><mi>m</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">nm &lt; mn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">nm</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">mn</span></span></span></span>，则我们定义 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>；如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>n</mi><mo>=</mo><mi>n</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">mn = nm</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">mn</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">nm</span></span></span></span>，则 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>。</p>\n<p>关于定义的自反性、对称性和传递性的证明，见<a href=\"https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/\">链接</a></p>\n<h2 id=\"代码-7\"><a class=\"anchor\" href=\"#代码-7\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;sstream&gt;\n\nusing namespace std;\n\nstring minNumber(vector&lt;int&gt;&amp; nums) &#123;\n    sort(nums.begin(), nums.end(), [](int a, int b) &#123;\n        string a_str = to_string(a);\n        string b_str = to_string(b);\n        return a_str + b_str &lt; b_str + a_str;\n    &#125;);\n    ostringstream output;\n    for (int i = 0; i &lt; nums.size(); ++i) &#123;\n        output &lt;&lt; to_string(nums[i]);\n    &#125;\n    return output.str();\n&#125;\n</code></pre>\n<h1 id=\"面试题-46把数字翻译成字符串\"><a class=\"anchor\" href=\"#面试题-46把数字翻译成字符串\">#</a> 面试题 46：把数字翻译成字符串</h1>\n<h2 id=\"题目-8\"><a class=\"anchor\" href=\"#题目-8\">#</a> 题目</h2>\n<p>给定一个数字，我们按照如下规则把它翻译为字符串：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 翻译成  <code>a</code> ，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 翻译成  <code>b</code> ，……，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>11</mn></mrow><annotation encoding=\"application/x-tex\">11</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">11</span></span></span></span> 翻译成  <code>11</code> ，……，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>25</mn></mrow><annotation encoding=\"application/x-tex\">25</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">25</span></span></span></span> 翻译成  <code>z</code> 。一个数字可能有多个翻译。例如，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>12258</mn></mrow><annotation encoding=\"application/x-tex\">12258</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">12258</span></span></span></span> 有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 种不同的翻译，分别是  <code>bccfi</code> 、 <code>bwfi</code> 、 <code>bczi</code> 、 <code>mcfi</code>  和  <code>mzi</code> 。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>\n<h2 id=\"思路-8\"><a class=\"anchor\" href=\"#思路-8\">#</a> 思路</h2>\n<p>定义函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> 表小从第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 位数字开始的不同翻译的数目，那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)=f(i+1)+g(i,i+1)\\times f(i+2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span>。当第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 位和第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 位两位数字拼接起来的数字在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>25</mn></mrow><annotation encoding=\"application/x-tex\">25</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">25</span></span></span></span> 的范围内时，函数的值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>；否则为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>。</p>\n<h2 id=\"代码-8\"><a class=\"anchor\" href=\"#代码-8\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint translate_num(int num) &#123;\n    string str = to_string(num);\n    int len = str.size();\n    if(len &lt; 2) return len;\n    vector&lt;int&gt; dp(len+1);\n    dp[1] = 1;\n    dp[0] = 1;\n    for(int i = 2;i &lt;= len;i++)&#123;\n        if(str[i-2] == '1' || (str[i-2] == '2' &amp;&amp; str[i-1] &lt;= '5')) dp[i] = dp[i-2]+dp[i-1];\n        else dp[i] = dp[i-1];\n    &#125;\n    return dp[len];\n&#125;\n</code></pre>\n<h1 id=\"面试题-47礼物的最大价值\"><a class=\"anchor\" href=\"#面试题-47礼物的最大价值\">#</a> 面试题 47：礼物的最大价值</h1>\n<h2 id=\"题目-9\"><a class=\"anchor\" href=\"#题目-9\">#</a> 题目</h2>\n<p>在一个的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>)。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>\n<h2 id=\"思路-9\"><a class=\"anchor\" href=\"#思路-9\">#</a> 思路</h2>\n<p>这是一个典型的能用动态规划解决的问题。先用递归的思路来分析。定义第一个函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 表示到达坐标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的格子时能拿到的礼物总和的最大值。根据题目的要求，有两种可能的途径到达坐标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的格子：通过格子 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i-1,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i, j-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。所以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mtext>gift</mtext><mo stretchy=\"false\">[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f(i,j)=\\max(f(i-1,j),f(i,j-1)) + \\text{gift}[i,j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">gift</span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>gift</mtext><mo stretchy=\"false\">[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\text{gift}[i,j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">gift</span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 表示坐标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的格子里礼物的价值。</p>\n<p>为了缓存中间计算结果，需要一个辅助的二维数组。数组中坐标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的元素表示到达坐标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的格子时能拿到的礼物价值总和的最大值。</p>\n<h2 id=\"代码-9\"><a class=\"anchor\" href=\"#代码-9\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n    if (grid.empty()) &#123;\n        return 0;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; dp(grid.size() + 1, vector&lt;int&gt;(grid[0].size() + 1, 0));\n    for (int i = 1; i &lt;= grid.size(); ++i) &#123;\n        for (int j = 1; j &lt;= grid[0].size(); ++j) &#123;\n            int val = grid[i - 1][j - 1];\n            dp[i][j] = val + max(dp[i][j - 1], dp[i - 1][j]);\n        &#125;\n    &#125;\n    return dp[grid.size()][grid[0].size()];\n&#125;\n</code></pre>\n<h1 id=\"面试题-48最长不含重复字符的子字符串\"><a class=\"anchor\" href=\"#面试题-48最长不含重复字符的子字符串\">#</a> 面试题 48：最长不含重复字符的子字符串</h1>\n<h2 id=\"题目-10\"><a class=\"anchor\" href=\"#题目-10\">#</a> 题目</h2>\n<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含  <code>a</code> ~ <code>z</code>  的字符。例如，在字符串  <code>arabcacfr</code>  中，最长的不含重复字符的子字符串是  <code>acfr</code> ，长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>。</p>\n<h2 id=\"思路-10\"><a class=\"anchor\" href=\"#思路-10\">#</a> 思路</h2>\n<p>定义函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> 表示以第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符为结尾的不包含重复字符的子字符串的最长长度。我们从左到右逐一扫描字符串中的每个字符。当我们计算以第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符为结尾的不包含重复字符的子字符串的最长长度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> 时，己经知道 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 了。</p>\n<p>如果第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符之前没有出现过，那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f(i) = f(i-1) + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<p>如果第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符之前已经出现过，先计算第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符和它上次出现在字符串中的位置的距离，并记为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>。接着分两种情形分析。</p>\n<p>第一种情形是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> 小于或者等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，此时第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符上次出现在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 对应的最长子字符串之中，因此 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">f(i) = d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>。同时这也意味着在第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符出现两次所夹的子字符串中再也没有其他重复的字符了。</p>\n<p>第二种情形是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> 大于此时第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符上次出现在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 对应的最长子字符串之前，因此仍然有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f(i) = f(i-1) + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<h2 id=\"代码-10\"><a class=\"anchor\" href=\"#代码-10\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint longest_substring_without_duplication(string &amp;str) &#123;\n    int current_len = 0;\n    int max_len = 0;\n\n    vector&lt;int&gt; position(26, -1);\n\n    for (int i = 0; i &lt; str.size(); ++i) &#123;\n        int prev_index = position[str[i] - 'a'];\n        if (prev_index &lt; 0 || i - prev_index &gt; current_len) &#123;\n            ++current_len;\n        &#125; else &#123;\n            if (current_len &gt; max_len) &#123;\n                max_len = current_len;\n            &#125;\n\n            current_len = i - prev_index;\n        &#125;\n        position[str[i] - 'a'] = i;\n    &#125;\n\n    if (current_len &gt; max_len) &#123;\n        max_len = current_len;\n    &#125;\n\n    return max_len;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-7/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-7/",
            "title": "剑指 Offer （七）",
            "date_published": "2021-09-29T06:17:06.000Z",
            "content_html": "<h1 id=\"面试题-35复杂链表的复制\"><a class=\"anchor\" href=\"#面试题-35复杂链表的复制\">#</a> 面试题 35：复杂链表的复制</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>请实现函数  <code>ComplexListNode *clone(ComplexListNode *pHead)</code> ，复制一个复杂链表。在复杂链表中，每个节点除了有一个  <code>m_next</code>  指针指向下一个节点，还有一个  <code>m_sibling</code>  指针指向链表中的任意点或者 <code>nullptr</code> 。节点的  <code>C++</code>  定义如下：</p>\n<pre><code class=\"language-cpp\">struct ComplexListNode &#123;\n    int m_value;\n    ComplexListNode *m_next;\n    ComplexListNode *m_random;\n&#125;;\n</code></pre>\n<p>在复杂链表的节点中，除了有指向下一个节点的指针之外，还有另一个指针指向任意一个节点。</p>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p>最朴素的做法是复制原始链表上的每个节点，之后再复制  <code>m_sibling</code>  的指针。对于一个含有  <code>n</code>  个节点的链表，需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间才能定位  <code>m_sibling</code>  节点，因此总的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>利用哈希表记录每个节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 对应的复制后的节点 N^'。在复制了原始节点之后，通过  <code>m_random</code>  查找哈希表获取其对应的复制后的节点。如此可通过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的时间定位对应的节点。</p>\n<p>另一种方法是将复制后的节点直接连接在原始节点之后，在对  <code>m_random</code>  赋值时，通过原始节点的  <code>m_random</code>  指针可以定位到  <code>m_random</code>  的复制后的节点，即  <code>m_random-&gt;m_next</code> 。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct ComplexListNode &#123;\n    int m_value;\n    ComplexListNode *m_next;\n    ComplexListNode *m_random;\n    ComplexListNode() : m_value(-1), m_next(nullptr), m_random(nullptr) &#123;&#125;\n&#125;;\n\nvoid clone_nodes(ComplexListNode *head) &#123;\n    ComplexListNode *node = head;\n    while (node != nullptr) &#123;\n        ComplexListNode *cloned = new ComplexListNode();\n        cloned-&gt;m_value = node-&gt;m_value;\n        cloned-&gt;m_next = node-&gt;m_next;\n\n        node-&gt;m_next = cloned;\n        node = cloned-&gt;m_next;\n    &#125;\n&#125;\n\nvoid connect_random_nodes(ComplexListNode *head) &#123;\n    ComplexListNode *node = head;\n    while (node != nullptr) &#123;\n        ComplexListNode *cloned = node-&gt;m_next;\n        if (node-&gt;m_random != nullptr) &#123;\n            cloned-&gt;m_random = node-&gt;m_random-&gt;m_next;\n        &#125;\n        node = cloned-&gt;m_next;\n    &#125;\n&#125;\n\nComplexListNode *reconnect_nodes(ComplexListNode *head) &#123;\n    ComplexListNode *node = head;\n    ComplexListNode *cloned_head = nullptr;\n    ComplexListNode *cloned_node = nullptr;\n\n    if (node != nullptr) &#123;\n        cloned_head = cloned_node = node-&gt;m_next;\n        node-&gt;m_next = cloned_node-&gt;m_next;\n        node = node-&gt;m_next;\n    &#125;\n\n    while (node != nullptr) &#123;\n        cloned_node-&gt;m_next = node-&gt;m_next;\n        cloned_node = cloned_node-&gt;m_next;\n        node-&gt;m_next = cloned_node-&gt;m_next;\n        node = node-&gt;m_next;\n    &#125;\n\n    return cloned_head;\n&#125;\n\nComplexListNode *clone(ComplexListNode *head) &#123;\n    clone_nodes(head);\n    connect_random_nodes(head);\n    return reconnect_nodes(head);\n&#125;\n</code></pre>\n<h1 id=\"面试题-36二叉搜索树与双向链表\"><a class=\"anchor\" href=\"#面试题-36二叉搜索树与双向链表\">#</a> 面试题 36：二叉搜索树与双向链表</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表，要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>在将二叉搜索树转换成排序双向链表时，原先指向左子节点的指针调整为链表中指向前一个节点的指针，原先指向右子节点的指针调整为链表中指向后一个节点的指针。由于要求转换之后的链表是排好序的，我们可以中序遍历树中的每个节点。</p>\n<p>当遍历到一个节点时，它的左子树已经转换成了一个有序的链表，将链表和当前节点连接，接着继续转换该节点的右子树。该过程是一个递归过程。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\n\nvoid convert_node(BinaryTreeNode *node, BinaryTreeNode **last_node_of_list) &#123;\n    if (node == nullptr) &#123;\n        return;\n    &#125;\n\n    BinaryTreeNode *current = node;\n\n    if (current-&gt;m_left != nullptr) &#123;\n        convert_node(current-&gt;m_left, last_node_of_list);\n    &#125;\n\n    current-&gt;m_left = *last_node_of_list;\n    if (*last_node_of_list != nullptr) &#123;\n        (*last_node_of_list)-&gt;m_right = current;\n    &#125;\n\n    *last_node_of_list = current;\n\n    if (current-&gt;m_right != nullptr) &#123;\n        convert_node(current-&gt;m_right, last_node_of_list);\n    &#125;\n&#125;\n\nBinaryTreeNode *convert(BinaryTreeNode *root) &#123;\n    BinaryTreeNode *last_node_of_list = nullptr;\n    convert_node(root, &amp;last_node_of_list);\n\n    BinaryTreeNode *head_of_list = last_node_of_list;\n    while (head_of_list != nullptr &amp;&amp; head_of_list-&gt;m_left != nullptr) &#123;\n        head_of_list = head_of_list-&gt;m_left;\n    &#125;\n\n    return head_of_list;\n&#125;\n</code></pre>\n<h1 id=\"面试题-37序列化二叉树\"><a class=\"anchor\" href=\"#面试题-37序列化二叉树\">#</a> 面试题 37：序列化二叉树</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>根据前序遍历的顺序来序列化二叉树，因为前序遍历是从根节点开始的。在遍历二叉树碰到  <code>nullptr</code>  指针时，这些  <code>nullptr</code>  指针序列化为一个殊的字符（如  <code>$</code> ）。另外，节点的数值之间要用一个特殊字符（如  <code>,</code> ）分隔。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n    BinaryTreeNode() : m_value(-1), m_left(nullptr), m_right(nullptr) &#123;&#125;\n&#125;;\n\nbool read_stream(istream &amp;stream, int *number) &#123;\n    char c;\n    bool result = true;\n    int num = 0;\n    while (stream &gt;&gt; c) &#123;\n        if (c == ',') &#123;\n            break;\n        &#125; else if (c == '$') &#123;\n            result = false;\n            continue;\n        &#125; else &#123;\n            num *= 10;\n            num += c - '0';\n        &#125;\n    &#125;\n\n    if (result) &#123;\n        *number = num;\n    &#125;\n    return result;\n&#125;\n\nvoid serialize(BinaryTreeNode *root, ostream &amp;stream) &#123;\n    if (root == nullptr) &#123;\n        stream &lt;&lt; &quot;$,&quot;;\n        return;\n    &#125;\n\n    stream &lt;&lt; root-&gt;m_value &lt;&lt; ',';\n    serialize(root-&gt;m_left, stream);\n    serialize(root-&gt;m_right, stream);\n&#125;\n\nvoid deserialize(BinaryTreeNode **root, istream &amp;stream) &#123;\n    int number;\n    if (read_stream(stream, &amp;number)) &#123;\n        *root = new BinaryTreeNode();\n        (*root)-&gt;m_value = number;\n\n        deserialize(&amp;((*root)-&gt;m_left), stream);\n        deserialize(&amp;((*root)-&gt;m_right), stream);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"面试题-38字符串的排列\"><a class=\"anchor\" href=\"#面试题-38字符串的排列\">#</a> 面试题 38：字符串的排列</h1>\n<h2 id=\"题目-4\"><a class=\"anchor\" href=\"#题目-4\">#</a> 题目</h2>\n<p>输入一个字符串，打印出该字符串中字符的所有排列。例如，输入字符串  <code>abc</code> ，则打印出由字符  <code>a</code> 、 <code>b</code> 、 <code>c</code>  所能排列出来的所有字符串  <code>abc</code> 、 <code>acb</code> 、 <code>bac</code> 、 <code>bca</code> 、 <code>cab</code>  和  <code>cba</code> 。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>求整个字符串的排列，可以看成两步。第一步求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。第二步固定第一个字符，求后面所有字符的排列。这时候仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。这是典型的递归思路。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nvoid permutation(string &amp;str, int idx) &#123;\n    if (idx == str.size()) &#123;\n        cout &lt;&lt; str &lt;&lt; endl;\n    &#125; else &#123;\n        for (int i = idx; i &lt; str.size(); ++i) &#123;\n            swap(str[i], str[idx]);\n            permutation(str, idx + 1);\n            swap(str[i], str[idx]);\n        &#125;\n    &#125;\n&#125;\n\nvoid permutation(string &amp;str) &#123;\n    if (str.empty()) &#123;\n        return;\n    &#125;\n\n    permutation(str, 0);\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-6/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-6/",
            "title": "剑指 Offer （六）",
            "date_published": "2021-09-27T07:03:48.000Z",
            "content_html": "<h1 id=\"面试题-27二叉树的镜像\"><a class=\"anchor\" href=\"#面试题-27二叉树的镜像\">#</a> 面试题 27：二叉树的镜像</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>请完成一个函数，输入一棵二叉树，该函数输出它的镜像。二叉树节点的定义如下：</p>\n<pre><code class=\"language-cpp\">struct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;\n</code></pre>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p><img loading=\"lazy\" data-src=\"/images/coding_interviews_binary_tree_mirror.jpg\" alt=\"二叉树镜像\" /></p>\n<p>通过图像可以看到，互为镜像的两个二叉树的根节点相同，但它们的左、右两个子节点位置相反。对于接下来的节点，依然继续上述的交换过程。</p>\n<p>通过总结，我们得出求一棵树的镜像的过程：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有非叶节点的左、右子节点之后，就得到了树的镜像。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nvoid mirror_recursively(BinaryTreeNode *node) &#123;\n    if (node == nullptr) &#123;\n        return;\n    &#125;\n\n    if (node-&gt;m_left == nullptr &amp;&amp; node-&gt;m_right == nullptr) &#123;\n        return;\n    &#125;\n\n    swap(node-&gt;m_left, node-&gt;m_right);\n\n    if (node-&gt;m_left) &#123;\n        mirror_recursively(node-&gt;m_left);\n    &#125;\n\n    if (node-&gt;m_right) &#123;\n        mirror_recursively(node-&gt;m_right);\n    &#125;\n\n&#125;\n</code></pre>\n<h1 id=\"面试题-28对称的二叉树\"><a class=\"anchor\" href=\"#面试题-28对称的二叉树\">#</a> 面试题 28：对称的二叉树</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>通常我们有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 种不同的二叉树遍历算法，即前序遍历、中序遍历和后序遍历。在这 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 种遍历算法中，都是先遍历左子节点再遍历右子节点。我们可以定义一种遍历算法，先遍历右子节点再遍历左子节点，可以称之为对称前序遍历。这样，互为镜像的两个二叉树在前序遍历和对称前序遍历下的结果相同。</p>\n<p>可以通过比较二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。如果两个序列是一样的，那么二叉树就是对称的。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nbool is_symmetrical(BinaryTreeNode *root_A, BinaryTreeNode *root_B) &#123;\n    if (root_A == nullptr &amp;&amp; root_B == nullptr) &#123;\n        return true;\n    &#125;\n\n    if (root_A == nullptr || root_B == nullptr) &#123;\n        return false;\n    &#125;\n\n    if (root_A-&gt;m_value != root_B-&gt;m_value) &#123;\n        return false;\n    &#125;\n\n    return is_symmetrical(root_A-&gt;m_left, root_B-&gt;m_right) &amp;&amp;\n           is_symmetrical(root_A-&gt;m_right, root_B-&gt;m_left);\n&#125;\n\nbool is_symmetrical(BinaryTreeNode *root) &#123;\n    return is_symmetrical(root, root);\n&#125;\n</code></pre>\n<h1 id=\"面试题-29顺时针打印矩阵\"><a class=\"anchor\" href=\"#面试题-29顺时针打印矩阵\">#</a> 面试题 29：顺时针打印矩阵</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>例如，如果输入如下矩阵：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo fence=\"true\">(</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>4</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>6</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>8</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>10</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>11</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>12</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>13</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>14</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>15</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>16</mn></mstyle></mtd></mtr></mtable><mo fence=\"true\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\begin{pmatrix}\n 1 &amp; 2 &amp; 3 &amp; 4 \\\\\n 5 &amp; 6 &amp; 7 &amp; 8 \\\\\n 9 &amp; 10 &amp; 11 &amp; 12 \\\\\n 13 &amp; 14 &amp; 15 &amp; 16   \n\\end{pmatrix}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:4.8em;vertical-align:-2.15em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.65em;\"><span style=\"top:-4.65em;\"><span class=\"pstrut\" style=\"height:6.8em;\"></span><span style=\"width:0.875em;height:4.800em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.875em\" height=\"4.800em\" viewBox=\"0 0 875 4800\"><path d=\"M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0,1284c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-1292c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.65em;\"><span style=\"top:-4.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">9</span></span></span><span style=\"top:-1.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">13</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.15em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.65em;\"><span style=\"top:-4.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">6</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">10</span></span></span><span style=\"top:-1.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">14</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.15em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.65em;\"><span style=\"top:-4.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">3</span></span></span><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">7</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">11</span></span></span><span style=\"top:-1.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">15</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.15em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.65em;\"><span style=\"top:-4.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">4</span></span></span><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">8</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">12</span></span></span><span style=\"top:-1.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">16</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.65em;\"><span style=\"top:-4.65em;\"><span class=\"pstrut\" style=\"height:6.8em;\"></span><span style=\"width:0.875em;height:4.800em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.875em\" height=\"4.800em\" viewBox=\"0 0 875 4800\"><path d=\"M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,1209\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-1344c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.15em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>则依次打印出数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>12</mn><mo separator=\"true\">,</mo><mn>16</mn><mo separator=\"true\">,</mo><mn>15</mn><mo separator=\"true\">,</mo><mn>14</mn><mo separator=\"true\">,</mo><mn>13</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>11</mn><mo separator=\"true\">,</mo><mn>10</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">12</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">16</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">15</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">14</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">13</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">11</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">10</span><span class=\"mclose\">}</span></span></span></span>。</p>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>参考此  <code>LeetCode</code>  的<a href=\"https://leetcode-cn.com/problems/spiral-matrix/solution/cxiang-xi-ti-jie-by-youlookdeliciousc-3/\">解析</a>。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; spiral_order(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n    vector &lt;int&gt; ans;\n    if(matrix.empty()) return ans; //若数组为空，直接返回答案\n    int u = 0; //赋值上下左右边界\n    int d = matrix.size() - 1;\n    int l = 0;\n    int r = matrix[0].size() - 1;\n    while(true)\n    &#123;\n        for(int i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右\n        if(++ u &gt; d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同\n        for(int i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); //向下\n        if(-- r &lt; l) break; //重新设定有边界\n        for(int i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); //向左\n        if(-- d &lt; u) break; //重新设定下边界\n        for(int i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); //向上\n        if(++ l &gt; r) break; //重新设定左边界\n    &#125;\n    return ans;\n&#125;\n\n作者：youlookdeliciousc\n链接：https://leetcode-cn.com/problems/spiral-matrix/solution/cxiang-xi-ti-jie-by-youlookdeliciousc-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n<h1 id=\"面试题-30包含-min-函数的栈\"><a class=\"anchor\" href=\"#面试题-30包含-min-函数的栈\">#</a> 面试题 30：包含  <code>min</code>  函数的栈</h1>\n<h2 id=\"题目-4\"><a class=\"anchor\" href=\"#题目-4\">#</a> 题目</h2>\n<p>定义桟的数据结构，请在该类型中实现一个能够得到桟的最小元素的  <code>min</code>  函数。在该找中，调用 <code>min</code> 、 <code>push</code>  及  <code>pop</code>  的时间复杂度都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>使用一个辅助栈，当每次有新插入的元素的时候，把每次的最小元素（之前的最小元素和新压入栈的元素两者的较小值）都保存辅助栈里。当弹出元素的时候，将辅助栈中的元素也同时弹出。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;cassert&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass stack_with_min &#123;\npublic:\n    void push(const T &amp;value);\n    void pop();\n    const T&amp; min() const;\nprivate:\n    stack&lt;T&gt; m_data;\n    stack&lt;T&gt; m_min;\n&#125;;\n\n\ntemplate&lt;typename T&gt;\nvoid stack_with_min&lt;T&gt;::push(const T&amp; value) &#123;\n    m_data.push(value);\n\n    if (m_min.empty() || value &lt; m_min.top()) &#123;\n        m_min.push(value);\n    &#125; else &#123;\n        m_min.push(m_min.top());\n    &#125;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid stack_with_min&lt;T&gt;::pop() &#123;\n    assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0);\n\n    m_data.pop();\n    m_min.pop();\n&#125;\n\ntemplate&lt;typename T&gt;\nconst T&amp; stack_with_min&lt;T&gt;::min() const &#123;\n    assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0);\n\n    return m_min.top();\n&#125;\n</code></pre>\n<h1 id=\"面试题-31栈的压入-弹出序列\"><a class=\"anchor\" href=\"#面试题-31栈的压入-弹出序列\">#</a> 面试题 31：栈的压入、弹出序列</h1>\n<h2 id=\"题目-5\"><a class=\"anchor\" href=\"#题目-5\">#</a> 题目</h2>\n<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,3,4,5\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">}</span></span></span></span> 是某栈的压栈序列，序列 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{4,5,3,2,1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> 是该压栈序列对应的一个弹出序列，但 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{4,3,5,1,2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span> 就不可能是该压栈序列的弹出序列。</p>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入桟的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nbool is_pop_order(vector&lt;int&gt; &amp;push_seq, vector&lt;int&gt; &amp;pop_seq) &#123;\n    bool is_possible = false;\n\n    if (!push_seq.empty() &amp;&amp; !pop_seq.empty()) &#123;\n        vector&lt;int&gt;::iterator push_it = push_seq.begin();\n        vector&lt;int&gt;::iterator pop_it = pop_seq.begin();\n\n        stack&lt;int&gt; data;\n\n        while (push_it != push_seq.end() &amp;&amp; pop_it != pop_seq.end()) &#123;\n            while (data.empty() || data.top() != *pop_it) &#123;\n                if (push_it != push_seq.end()) &#123;\n                    break;\n                &#125;\n\n                data.push(*push_it);\n\n                ++push_it;\n            &#125;\n\n            if (data.top() != *pop_it) &#123;\n                break;\n            &#125;\n\n            data.pop();\n            ++pop_it;\n        &#125;\n\n        if (data.empty() &amp;&amp; pop_it == pop_seq.end()) &#123;\n            is_possible = true;\n        &#125;\n    &#125;\n\n    return is_possible;\n&#125;\n</code></pre>\n<h1 id=\"面试题-32从上到下打印二叉树\"><a class=\"anchor\" href=\"#面试题-32从上到下打印二叉树\">#</a> 面试题 32：从上到下打印二叉树</h1>\n<h2 id=\"题目一不分行从上到下打印二叉树\"><a class=\"anchor\" href=\"#题目一不分行从上到下打印二叉树\">#</a> 题目一：不分行从上到下打印二叉树</h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<h2 id=\"思路-6\"><a class=\"anchor\" href=\"#思路-6\">#</a> 思路</h2>\n<p>使用队列，打印一个节点时，将其子节点按从左到右的顺序加入队列。直到队列中的元素数量为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>。</p>\n<h2 id=\"代码-6\"><a class=\"anchor\" href=\"#代码-6\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nvoid print_from_top_to_bottom(BinaryTreeNode *root) &#123;\n    if (root == nullptr) &#123;\n        return;\n    &#125;\n\n    deque&lt;BinaryTreeNode *&gt; nodes;\n\n    nodes.push_back(root);\n    while (!nodes.empty()) &#123;\n        BinaryTreeNode *node = nodes.front();\n        nodes.pop_front();\n\n        cout &lt;&lt; node-&gt;m_value &lt;&lt; &quot; &quot;;\n\n        if (node-&gt;m_left) &#123;\n            nodes.push_back(node-&gt;m_left);\n        &#125;\n\n        if (node-&gt;m_right) &#123;\n            nodes.push_back(node-&gt;m_right);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"题目二分行从上到下打印二叉树\"><a class=\"anchor\" href=\"#题目二分行从上到下打印二叉树\">#</a> 题目二：分行从上到下打印二叉树</h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<h2 id=\"思路-7\"><a class=\"anchor\" href=\"#思路-7\">#</a> 思路</h2>\n<p>为了把二叉树的每一行单独打印到一行里，需要有一个变量记录当前层的节点数量。</p>\n<h2 id=\"代码-7\"><a class=\"anchor\" href=\"#代码-7\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nvoid print_layer(BinaryTreeNode *root) &#123;\n    if (root == nullptr) &#123;\n        return;\n    &#125;\n\n    queue&lt;BinaryTreeNode *&gt; nodes;\n    nodes.push(root);\n    while (!nodes.empty()) &#123;\n        int size = nodes.size();\n        for (int i = 0; i &lt; size; ++i) &#123;\n            BinaryTreeNode *node = nodes.front();\n            cout &lt;&lt; node-&gt;m_value &lt;&lt; &quot; &quot;;\n            nodes.pop();\n\n            if (node-&gt;m_left) &#123;\n                nodes.push(node-&gt;m_left);\n            &#125;\n\n            if (node-&gt;m_right) &#123;\n                nodes.push(node-&gt;m_right);\n            &#125;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"题目三之字形打印二叉树\"><a class=\"anchor\" href=\"#题目三之字形打印二叉树\">#</a> 题目三：之字形打印二叉树</h2>\n<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>\n<h2 id=\"思路-8\"><a class=\"anchor\" href=\"#思路-8\">#</a> 思路</h2>\n<p>按之字形顺序打印二叉树需要两个栈。我们在打印某一层的节点时，把下一层的子节点保存到相应的栈里。如果当前打印的是奇数层（第一层、第三层等），则先保存左子节点再保存右子节点到第一个栈里；如果当前打印的是偶数层（第二层、第四层等），则先保存右子节点再保存左子节点到第二个桟里。</p>\n<h2 id=\"代码-8\"><a class=\"anchor\" href=\"#代码-8\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nvoid print_BST_zigzag(BinaryTreeNode *root) &#123;\n    if (root == nullptr) &#123;\n        return;\n    &#125;\n\n    stack&lt;BinaryTreeNode *&gt; levels[2];\n    int current = 0;\n    int next = 1;\n\n    levels[current].push(root);\n    while (!levels[0].empty() || !levels[1].empty()) &#123;\n        BinaryTreeNode *node = levels[current].top();\n        levels[current].pop();\n\n        cout &lt;&lt; node-&gt;m_value &lt;&lt; &quot; &quot;;\n\n        if (current == 0) &#123;\n            if (node-&gt;m_left != nullptr) &#123;\n                levels[next].push(node-&gt;m_left);\n            &#125;\n\n            if (node-&gt;m_right != nullptr) &#123;\n                levels[next].push(node-&gt;m_right);\n            &#125;\n        &#125; else &#123;\n            if (node-&gt;m_right != nullptr) &#123;\n                levels[next].push(node-&gt;m_right);\n            &#125;\n\n            if (node-&gt;m_left != nullptr) &#123;\n                levels[next].push(node-&gt;m_left);\n            &#125;\n        &#125;\n\n        if (levels[current].empty()) &#123;\n            cout &lt;&lt; endl;\n            current = 1 - current;\n            next = 1 - next;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"面试题-33二叉搜索树的后序遍历序列\"><a class=\"anchor\" href=\"#面试题-33二叉搜索树的后序遍历序列\">#</a> 面试题 33：二叉搜索树的后序遍历序列</h1>\n<h2 id=\"题目-6\"><a class=\"anchor\" href=\"#题目-6\">#</a> 题目</h2>\n<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回  <code>true</code> ，否则返回  <code>false</code> 。假设输入的数组的任意两个数字都互不相同。例如，输入数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>11</mn><mo separator=\"true\">,</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>8</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{5,7,6,9,11,10,8\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">11</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">10</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mclose\">}</span></span></span></span>，则返回  <code>true</code> 。如果输入的数组是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{7,4,6,5\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">}</span></span></span></span>，则由于没有哪棵二叉搜索树的后序遍历结果是这个序列，因此返回  <code>false</code> 。</p>\n<h2 id=\"思路-9\"><a class=\"anchor\" href=\"#思路-9\">#</a> 思路</h2>\n<p>在后序遍历得到的序列中，最后一个数字是树的根节点的值。数组中前面的数字可以分为两部分：第一部分是左子树节点的值，它们都比根节点的值小；第二部分是右子树节点的值，它们都比根节点的值大。</p>\n<p>以数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>11</mn><mo separator=\"true\">,</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>8</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{5,7,6,9,11,10,8\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">11</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">10</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mclose\">}</span></span></span></span> 为例，后序遍历结果的最后一个数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 就是根节点的值。在这个数组中，前 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 个数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">7</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span> 都比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 小，是值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 的节点的左子树节点；后 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 个数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>11</mn></mrow><annotation encoding=\"application/x-tex\">11</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">11</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10</span></span></span></span> 都比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 大，是值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 的节点的右子树节点。</p>\n<p>接下来用同样的方法确定与数组每一部分对应的子树的结构。这其实就是一个递归的过程。</p>\n<h2 id=\"代码-9\"><a class=\"anchor\" href=\"#代码-9\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nbool verify_sequence_of_BST(vector&lt;int&gt; &amp;sequence, int begin, int end) &#123;\n    if (sequence.empty()) &#123;\n        return false;\n    &#125;\n\n    int root = sequence[end - 1];\n\n    // 在二叉搜索树中左子树节点的值小于根节点的值\n    int i = begin;\n    for ( ; i &lt; end - 1; ++i) &#123;\n        if (sequence[i] &gt; root) &#123;\n            break;\n        &#125;\n    &#125;\n\n    // 在二叉搜索树中右子树节点的值大于根节点的值\n    int j = i;\n    for ( ; j &lt; begin - 1; ++j) &#123;\n        if (sequence[j] &lt; root) &#123;\n            return false;\n        &#125;\n    &#125;\n\n    // 判断左子树是否是二叉搜索树\n    bool left = true;\n    if (i &gt; 0) &#123;\n        left = verify_sequence_of_BST(sequence, begin, i);\n    &#125;\n\n    // 判断右子树是否是二叉搜索树\n    bool right = true;\n    if (i &lt; end - 1) &#123;\n        right = verify_sequence_of_BST(sequence, begin + i, end);\n    &#125;\n\n    return (left &amp;&amp; right);\n&#125;\n</code></pre>\n<h1 id=\"面试题-34二叉树中和为某一值的路径\"><a class=\"anchor\" href=\"#面试题-34二叉树中和为某一值的路径\">#</a> 面试题 34：二叉树中和为某一值的路径</h1>\n<h2 id=\"题目-7\"><a class=\"anchor\" href=\"#题目-7\">#</a> 题目</h2>\n<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>\n<h2 id=\"思路-10\"><a class=\"anchor\" href=\"#思路-10\">#</a> 思路</h2>\n<p>当用前序遍历的方式访问到某一节点时，我们把该节点添加到路径上，并累加该节点的值。如果该节点为叶节点，并且路径中节点值的和刚好等于输入的整数，则当前路径符合要求。如果当前节点不是叶节点，则继续访问它的子节点。当前节点访问结束后，递归函数将自动回到它的父节点。因此，我们在函数退出之前要在路径上删除当前节点并减去当前节点的值，以确保返回父节点时路径刚好是从根节点到父节点。</p>\n<h2 id=\"代码-10\"><a class=\"anchor\" href=\"#代码-10\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nvoid find_path(BinaryTreeNode *root, int target, vector&lt;int&gt; &amp;path, int current_sum) &#123;\n    current_sum += root-&gt;m_value;\n    path.push_back(root-&gt;m_value);\n\n    bool is_leaf = root-&gt;m_left == nullptr &amp;&amp; root-&gt;m_right == nullptr;\n    if (current_sum == target &amp;&amp; is_leaf) &#123;\n        cout &lt;&lt; &quot;A path is found: &quot;;\n        vector&lt;int&gt;::iterator it = path.begin();\n        for ( ; it != path.end(); ++it) &#123;\n            cout &lt;&lt; *it &lt;&lt; &quot;\\t&quot;;\n        &#125;\n\n        cout &lt;&lt; endl;\n    &#125;\n\n    if (root-&gt;m_left != nullptr) &#123;\n        find_path(root-&gt;m_left, target, path, current_sum);\n    &#125;\n    if (root-&gt;m_right != nullptr) &#123;\n        find_path(root-&gt;m_right, target, path, current_sum);\n    &#125;\n\n    path.pop_back();\n&#125;\n\nvoid find_path(BinaryTreeNode *root, int target) &#123;\n    if (root == nullptr) &#123;\n        return;\n    &#125;\n\n    vector&lt;int&gt; path;\n    int current_sum = 0;\n    find_path(root, target, path, current_sum);\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-5/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-5/",
            "title": "剑指 Offer （五）",
            "date_published": "2021-09-22T15:39:44.000Z",
            "content_html": "<h1 id=\"面试题-22链表倒数第-k-个节点\"><a class=\"anchor\" href=\"#面试题-22链表倒数第-k-个节点\">#</a> 面试题 22：链表倒数第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个节点</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>输入一个链表，输出该链表中倒数第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个节点。为了符合大多数人的习惯，本题从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 幵始计数，即链表的尾节点是倒数第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个节点。例如，一个链表有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span> 个节点，从头节点开始，它们的值依次是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span>。这个链表的倒数第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 个节点是值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span> 的节点。链表节点定义如下：</p>\n<pre><code class=\"language-cpp\">struct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n</code></pre>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p>假设整个链表有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个节点，那么倒数第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个节点就是从头节点开始的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个节点。如果我们能够得到链表中节点的个数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 那么只要从头节点开始往后走 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 步就可以了。</p>\n<p>定义两个指针。第一个指针从链表的头指针幵始遍历向前走 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 步，第二个指针保持不动；从第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 步幵始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，当第一个（走在前面的）指针到达链表的尾节点时，第二个（走在后面的）指针正好指向倒数第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个节点。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n\nListNode *find_kth_to_tail(ListNode *head, unsigned int k) &#123;\n    ListNode *fast = head;\n    ListNode *slow = head;\n\n    for (unsigned i = 0; i &lt; k; ++i) &#123;\n        fast = fast-&gt;m_next;\n    &#125;\n\n    while (fast-&gt;m_next != nullptr) &#123;\n        fast = fast-&gt;m_next;\n        slow = slow-&gt;m_next;\n    &#125;\n\n    return slow;\n&#125;\n\n</code></pre>\n<h1 id=\"面试题-23链表中环的入口节点\"><a class=\"anchor\" href=\"#面试题-23链表中环的入口节点\">#</a> 面试题 23：链表中环的入口节点</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>如果一个链表中包含环，如何找出环的入口节点？</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>使用双指针的方法。详情参考<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/\">链接</a>。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n\nListNode *meeting_node(ListNode *head) &#123;\n    ListNode *slow = head, *fast = head;\n\n    while (fast != nullptr) &#123;\n        slow = slow-&gt;m_next;\n        if (fast-&gt;m_next == nullptr) &#123;\n            return nullptr;\n        &#125;\n\n        fast = fast-&gt;m_next-&gt;m_next;\n        if (slow == fast) &#123;\n            ListNode *ptr = head;\n            while (ptr != slow) &#123;\n                ptr = ptr-&gt;m_next;\n                slow = slow-&gt;m_next;\n            &#125;\n            return ptr;\n        &#125;\n    &#125;\n    return nullptr;\n&#125;\n\n</code></pre>\n<h1 id=\"面试题-24反转链表\"><a class=\"anchor\" href=\"#面试题-24反转链表\">#</a> 面试题 24：反转链表</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。链表节点定义如下：</p>\n<pre><code class=\"language-cpp\">struct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;\n</code></pre>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>略。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nstruct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n    ListNode() &#123;\n        m_value = -1;\n        m_next = nullptr;\n    &#125;\n&#125;;\n\n\nListNode *reverse_list(ListNode *head) &#123;\n    ListNode dummy;\n    dummy.m_next = head;\n\n    ListNode *prev = &amp;dummy;\n    ListNode *cur = head;\n    while (cur != nullptr) &#123;\n        ListNode *next = cur-&gt;m_next;\n        cur-&gt;m_next = prev-&gt;m_next;\n        prev = cur;\n        cur = next;\n    &#125;\n    return prev-&gt;m_next;\n&#125;\n</code></pre>\n<h1 id=\"面试题-25合并两个排序的链表\"><a class=\"anchor\" href=\"#面试题-25合并两个排序的链表\">#</a> 面试题 25：合并两个排序的链表</h1>\n<h2 id=\"题目-4\"><a class=\"anchor\" href=\"#题目-4\">#</a> 题目</h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下:</p>\n<pre><code class=\"language-cpp\">struct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n\n</code></pre>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>类似于归并排序。需要注意的是，当某一个链表的元素已经遍历完毕时，仍然需要将另一个链表的元素继续合并到链表中。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nstruct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n    ListNode() &#123;\n        m_value = -1;\n        m_next = nullptr;\n    &#125;\n&#125;;\n\n\nListNode *merge_list(ListNode *head1, ListNode *head2) &#123;\n    if (head1 == nullptr) &#123;\n        return head2;\n    &#125;\n\n    if (head2 == nullptr) &#123;\n        return head1;\n    &#125;\n\n    ListNode dummy;\n    ListNode *prev = &amp;dummy;\n\n    while (head1 &amp;&amp; head2) &#123;\n        if (head1-&gt;m_value &lt; head2-&gt;m_value) &#123;\n            prev-&gt;m_next = head1;\n            head1 = head1-&gt;m_next;\n        &#125; else &#123;\n            prev-&gt;m_next = head2;\n            head2 = head2-&gt;m_next;\n        &#125;\n        prev = prev-&gt;m_next;\n    &#125;\n\n    if (head1) &#123;\n        prev-&gt;m_next = head1;\n    &#125; else &#123;\n        prev-&gt;m_next = head2;\n    &#125;\n\n    return dummy.m_next;\n&#125;\n</code></pre>\n<h1 id=\"面试题-26树的子结构\"><a class=\"anchor\" href=\"#面试题-26树的子结构\">#</a> 面试题 26：树的子结构</h1>\n<h2 id=\"题目-5\"><a class=\"anchor\" href=\"#题目-5\">#</a> 题目</h2>\n<p>输入两棵二叉树  <code>A</code>  和  <code>B</code> ，判断  <code>B</code>  是不是  <code>A</code>  的子结构。二叉树节点的定义如下：</p>\n<pre><code class=\"language-cpp\">struct BinaryTreeNode &#123;\n    double m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n</code></pre>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>我们可以分成两步来判断树的子结构是否相同：</p>\n<ol>\n<li>在树  <code>A</code>  中找到和树  <code>B</code>  的根节点的值一样的节点  <code>R</code> ；</li>\n<li>判断树  <code>A</code>  中以  <code>R</code>  为根节点的子树是不是包含和树  <code>B</code>  一样的结构。</li>\n</ol>\n<p>上面这个过程可以很明显地写成递归的形式。</p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    double m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nbool equal(double a, double b) &#123;\n    return abs(a - b) &lt; 1e-6;\n&#125;\n\nbool does_tree_has_subtree(BinaryTreeNode *root, BinaryTreeNode *subtree_root) &#123;\n    if (subtree_root == nullptr) &#123;\n        return true;\n    &#125;\n\n    if (root == nullptr) &#123;\n        return false;\n    &#125;\n\n    if (equal(root-&gt;m_value, subtree_root-&gt;m_value) == false) &#123;\n        return false;\n    &#125;\n\n    return does_tree_has_subtree(root-&gt;m_left, subtree_root-&gt;m_left) &amp;&amp;\n           does_tree_has_subtree(root-&gt;m_right, subtree_root-&gt;m_right);\n&#125;\n\nbool has_subtree(BinaryTreeNode *root_A, BinaryTreeNode *root_B) &#123;\n    bool result = false;\n    if (root_A != nullptr &amp;&amp; root_B  != nullptr) &#123;\n        if (equal(root_A-&gt;m_value, root_B-&gt;m_value)) &#123;\n            result = does_tree_has_subtree(root_A, root_B);\n        &#125;\n\n        if (result == false) &#123;\n            result = has_subtree(root_A-&gt;m_left, root_B);\n        &#125;\n\n        if (result == false) &#123;\n            result = has_subtree(root_B-&gt;m_right, root_B);\n        &#125;\n    &#125;\n    return result;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-4/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-4/",
            "title": "剑指 Offer （四）",
            "date_published": "2021-09-19T11:30:06.000Z",
            "content_html": "<h1 id=\"面试题-16数值的整数次方\"><a class=\"anchor\" href=\"#面试题-16数值的整数次方\">#</a> 面试题 16：数值的整数次方</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>实现函数  <code>double_power(double base,int exponent)</code> ，求  <code>base</code>  的  <code>exponent</code>  次方。不得使用库函数，同时不需要考虑大数问题。</p>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p>本题的直接思路是通过循环不断计算乘法，直到算出最终的结果。</p>\n<p>需要注意的是， <code>exponent</code>  有可能为负数的情况，此时需要先取其绝对值，最后返回计算值的倒数。对于其他的特殊输入，如底数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 的情形，也需要特殊考虑。对于无效输入，使用  <code>g_INVALID_INPUT</code>  这个全局变量作为标识。</p>\n<p>更高效的做法是使用快速幂的思想，利用如下公式求解 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次方：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><msup><mi>a</mi><mrow><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow></msup><mo>⋅</mo><msup><mi>a</mi><mrow><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow></msup><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mtext> 为偶数</mtext><mo separator=\"true\">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><msup><mi>a</mi><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow></msup><mo>⋅</mo><msup><mi>a</mi><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow></msup><mo>⋅</mo><mi>a</mi><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mtext> 为奇数</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">a^n = \\begin{cases}\na^{n/2} \\cdot a^{n/2}, &amp; n \\text{ 为偶数};\\\\\na^{(n-1)/2} \\cdot a^{(n-1)/2} \\cdot a, &amp; n \\text{ 为奇数}\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mtight\">/2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mtight\">/2</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mord mtight\">/2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mord mtight\">/2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">为偶数</span></span><span class=\"mpunct\">;</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">为奇数</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\ndouble double_power(double base, unsigned int exponent) &#123;\n    if (exponent == 0) &#123;\n        return 1;\n    &#125;\n\n    if (exponent == 1) &#123;\n        return base;\n    &#125;\n\n    double result = 1;\n    while (exponent) &#123;\n        if (exponent &amp; 1) &#123; // exponent 的二进制最后一位为 1\n            result *= base;\n        &#125;\n        base *= base;\n        exponent &gt;&gt;= 1;\n    &#125;\n    return result;\n&#125;\n\n\nbool g_INVALID_INPUT = false;\n\ndouble double_power(double base, int exponent) &#123;\n    g_INVALID_INPUT = false;\n    if (abs(base - 0.0) &lt;= 1e-6 &amp;&amp; exponent &lt; 0) &#123;\n        g_INVALID_INPUT = true;\n        return 0.0;\n    &#125;\n\n    unsigned int abs_exponent = (unsigned int)exponent;\n    if (exponent &lt; 0) &#123;\n        abs_exponent = (unsigned int)(-exponent);\n    &#125;\n\n    double result = power_with_unsigned_exponent(base, abs_exponent);\n    if (exponent &lt; 0) &#123;\n        result = 1.0 / result;\n    &#125;\n\n    return result;\n&#125;\n</code></pre>\n<h1 id=\"面试题-17打印从-1-到最大的-n-位数\"><a class=\"anchor\" href=\"#面试题-17打印从-1-到最大的-n-位数\">#</a> 面试题 17：打印从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 到最大的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 位数</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>输入数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，按顺序打印出从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 到最大的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 位十进制数。比如输入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>，则打印出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 一直到最大的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 位数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>999</mn></mrow><annotation encoding=\"application/x-tex\">999</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">999</span></span></span></span>。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>对于输入的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 较小的情况，可以直接计算 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>10</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">10^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>，然后通过循环输出。但是对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 较大的情形，会遇到数字溢出的情形。因此需要使用字符或者数组来表示大整数，通过逐次对大整数自增 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的操作，不断输出整数。</p>\n<p>另一种方法是通过全排列的思想，将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 位数视作 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span> 的全排列，依次输出每个整数。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n\nvoid print_number(string &amp;number) &#123;\n    int begin_index = 0;\n    for (int i = 0; i &lt; number.size(); ++i) &#123;\n        if (number[i] != '0') &#123;\n            begin_index = i;\n            break;\n        &#125;\n    &#125;\n    cout &lt;&lt; number.substr(begin_index) &lt;&lt; endl;\n&#125;\n\nbool increment(string &amp;number) &#123;\n    bool is_overflow = false;\n    int carry = 0;\n    for (int i = number.size() - 1; i &gt;= 0; --i) &#123;\n        int sum = number[i] - '0' + carry;\n        if (i == number.size() - 1) &#123;\n            ++sum;\n        &#125;\n        if (sum &gt;= 10) &#123;\n            if (i == 0) &#123;\n                is_overflow = true;\n            &#125; else &#123;\n                sum -= 10;\n                carry = 1;\n                number[i] = '0' + sum;\n            &#125;\n        &#125; else &#123;\n            number[i] = '0' + sum;\n            break;\n        &#125;\n    &#125;\n    return is_overflow;\n&#125;\n\nvoid print_to_max_of_n_digits(int n) &#123;\n    if (n &lt;= 0) &#123;\n        return;\n    &#125;\n\n    string number(n, '0');\n    while (!increment(number)) &#123;\n        print_number(number);\n    &#125;\n&#125;\n</code></pre>\n<p>递归解法</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n\nvoid print_number(string &amp;number) &#123;\n    int begin_index = 0;\n    for (int i = 0; i &lt; number.size(); ++i) &#123;\n        if (number[i] != '0') &#123;\n            begin_index = i;\n            break;\n        &#125;\n    &#125;\n    cout &lt;&lt; number.substr(begin_index) &lt;&lt; endl;\n&#125;\n\n\nvoid print_number_recursively(string &amp;number, int index) &#123;\n    if (index == number.size()) &#123;\n        print_number(number);\n        return;\n    &#125;\n\n    for (int i = 0; i &lt; 10; ++i) &#123;\n        number[index] = '0' + i;\n        print_number_recursively(number, index + 1);\n    &#125;\n&#125;\n\n\nvoid print_to_max_of_n_digits(int n) &#123;\n    if (n &lt;= 0) &#123;\n        return;\n    &#125;\n\n    string number(n, '0');\n    print_number_recursively(number, 0);\n&#125;\n</code></pre>\n<h1 id=\"面试题-18删除链表的节点\"><a class=\"anchor\" href=\"#面试题-18删除链表的节点\">#</a> 面试题 18：删除链表的节点</h1>\n<h2 id=\"题目一在-o1-时间内删除链表节点\"><a class=\"anchor\" href=\"#题目一在-o1-时间内删除链表节点\">#</a> 题目一：在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间内删除链表节点</h2>\n<p>给定单向链表的头指针和一个节点指针，定义一个函数在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间内删除该节点。链表节点与函数的定义如下：</p>\n<pre><code class=\"language-cpp\">struct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n</code></pre>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>删除链表中节点的通常做法是遍历链表，找到目标节点后删除。但是本题中要求的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，因此不能通过遍历的方式进行查找。</p>\n<p>本题中给定了要被删除的节点，如果我们按照通常的做法，还需要找到该节点的前一个节点，这在单链表中是无法在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间内做到的。因此通常的删除节点，修改指针的办法在本题中是行不通的。</p>\n<p>我们可以换一种做法，对于被删除的节点，我们可以很快的找到它的下一个节点，那么我们可以将下一个节点的内容复制到本节点，然后删除下一个节点，如此一来，便可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间内做到删除链表节点（对于更复杂的结构体，可能无法满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的时间复杂度要求）。而对于最后的尾节点，则不得不遍历链表，寻找它的前一个节点。</p>\n<p>综上，对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个非尾节点，可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间内删除，而对于尾节点，时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，总的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{n}[(n-1)*O(1)+(n)]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">[(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)]</span></span></span></span>，仍然满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的要求。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\n\nusing namespace std;\n\nstruct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n\nvoid delete_node(ListNode **head, ListNode **to_be_deleted) &#123;\n    if (*head == nullptr || *to_be_deleted == nullptr) &#123;\n        return;\n    &#125;\n\n    ListNode *node_deleted = *to_be_deleted;\n    if (node_deleted-&gt;m_next != nullptr) &#123; // 非尾节点\n        ListNode *next = node_deleted-&gt;m_next;\n        node_deleted-&gt;m_value = next-&gt;m_value;\n        node_deleted-&gt;m_next = next-&gt;m_next;\n        delete next;\n        next = nullptr;\n        *to_be_deleted = nullptr;\n    &#125; else &#123;\n        if (*head == node_deleted) &#123;\n            delete node_deleted;\n            *head = nullptr;\n        &#125; else &#123;\n            ListNode *node = *head;\n            while (node-&gt;m_next != node_deleted) &#123;\n                node = node-&gt;m_next;\n            &#125;\n            node-&gt;m_next = nullptr;\n            delete *to_be_deleted;\n            *to_be_deleted = nullptr;\n        &#125;\n    &#125;\n&#125;\n\n#include &lt;iostream&gt;\n\n\nusing namespace std;\n\nstruct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n&#125;;\n\nvoid delete_node(ListNode *head, ListNode *to_be_deleted) &#123;\n    if (head == nullptr || to_be_deleted == nullptr) &#123;\n        return;\n    &#125;\n\n    if (to_be_deleted-&gt;m_next != nullptr) &#123; // 非尾节点\n        ListNode *next = to_be_deleted-&gt;m_next;\n        to_be_deleted-&gt;m_value = next-&gt;m_value;\n        to_be_deleted-&gt;m_next = next-&gt;m_next;\n        delete next;\n        next = nullptr;\n    &#125; else &#123;\n        if (head == to_be_deleted) &#123;\n            delete to_be_deleted;\n            head = nullptr;\n        &#125; else &#123;\n            ListNode *node = head;\n            while (node-&gt;m_next != to_be_deleted) &#123;\n                node = node-&gt;m_next;\n            &#125;\n            node-&gt;m_next = nullptr;\n            delete to_be_deleted;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"题目二删除链表中重复的节点\"><a class=\"anchor\" href=\"#题目二删除链表中重复的节点\">#</a> 题目二：删除链表中重复的节点</h2>\n<p>删除一个有序链表中值重复的节点。例如，对于链表 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,3,3,5\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">}</span></span></span></span>，删除重复的节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 后，变成了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,5\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">}</span></span></span></span>。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>在遍历链表的过程中，应当使用双指针  <code>prev</code>  和  <code>cur</code> ，当  <code>cur</code>  和  <code>cur-&gt;m_next</code>  指向的节点值重复时，停止  <code>prev</code>  的移动，让  <code>cur</code>  继续查找相同值，直到找到最后一个重复的节点，将  <code>prev-&gt;m_next</code>  到  <code>cur</code>  的节点全部删除。之后继续遍历链表，直到删除所有重复的节点。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct ListNode &#123;\n    int m_value;\n    ListNode *m_next;\n\n    ListNode(int val, ListNode *ptr = nullptr): m_value(val), m_next(ptr) &#123;&#125;\n&#125;;\n\n\nvoid delete_duplicate_node(ListNode **head) &#123;\n    if (head == nullptr) &#123;\n        return;\n    &#125;\n\n    ListNode dummy(-1, *head);\n    ListNode *prev = &amp;dummy;\n    ListNode *cur = *head;\n    while (cur != nullptr) &#123;\n        while (cur-&gt;m_next &amp;&amp; cur-&gt;m_next-&gt;m_value == cur-&gt;m_value) &#123;\n            cur = cur-&gt;m_next;\n        &#125;\n\n        if (prev-&gt;m_next != cur) &#123;\n            ListNode *tmp = prev-&gt;m_next;\n            prev-&gt;m_next = cur-&gt;m_next;\n            cur-&gt;m_next = nullptr;\n            cur = prev-&gt;m_next;\n            // delete nodes from tmp to cur\n            while (tmp != nullptr) &#123;\n                ListNode *node = tmp;\n                tmp = tmp-&gt;m_next;\n                delete node;\n            &#125;\n        &#125; else &#123;\n            prev = cur;\n            cur = cur-&gt;m_next;\n        &#125;\n    &#125;\n    *head = dummy.m_next;\n&#125;\n</code></pre>\n<h1 id=\"面试题-19正则表达式匹配\"><a class=\"anchor\" href=\"#面试题-19正则表达式匹配\">#</a> 面试题 19：正则表达式匹配</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>请实现一个函数用来匹配包含  <code>.</code>  和  <code>*</code>  的正则表达式。模式中的字符  <code>.</code>  表示任意一个字符，而  <code>*</code>  表示它前面的字符可以出现任意次（含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串  <code>aaa</code>  与模式  <code>a.a</code>  和  <code>ab*ac*a</code>  匹配，但与  <code>aa.a</code>  和  <code>ab*a</code>  均不匹配。</p>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>正则表达式最容易理解的解决方法是通过有限状态机来实现。</p>\n<p><img loading=\"lazy\" data-src=\"/images/coding_interviews_regex_finite_state_machine.jpg\" alt=\"finite_state_machine\" /></p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n\nbool match_core(const string &amp;str, int str_idx, const string &amp;pattern, int pattern_idx) &#123;\n    int str_len = str.size();\n    int pattern_len = pattern.size();\n\n    if (str_idx == str_len &amp;&amp; pattern_idx == pattern_len) &#123;\n        return true;\n    &#125;\n\n    if (str_idx != str_len &amp;&amp; pattern_idx == pattern_len) &#123;\n        return false;\n    &#125;\n\n    if (pattern_idx + 1 &lt; pattern_len &amp;&amp; pattern[pattern_idx + 1] == '*') &#123;\n        if (pattern[pattern_idx] == str[str_idx] || pattern[pattern_idx] == '.') &#123;\n            return match_core(str, str_idx + 1, pattern, pattern_idx + 2) ||    // move to next state\n                   match_core(str, str_idx + 1, pattern, pattern_idx) ||    // stay on current state\n                   match_core(str, str_idx, pattern, pattern_idx + 2);  // ignore a '*'\n        &#125; else &#123;\n            return match_core(str, str_idx, pattern, pattern_idx + 2);  // ignore a '*'\n        &#125;\n    &#125;\n\n    if (str[str_idx] == pattern[pattern_idx] || pattern[pattern_idx] == '.') &#123;\n        return match_core(str, str_idx + 1, pattern, pattern_idx + 1);\n    &#125;\n\n    return false;\n&#125;\n\n\nbool match(const string &amp;str, const string &amp;pattern) &#123;\n    if (str.empty() || pattern.empty()) &#123;\n        return false;\n    &#125;\n\n    return match_core(str, 0, pattern, 0);\n&#125;\n</code></pre>\n<h1 id=\"面试题-20表示数值的字符串\"><a class=\"anchor\" href=\"#面试题-20表示数值的字符串\">#</a> 面试题 20：表示数值的字符串</h1>\n<h2 id=\"题目-4\"><a class=\"anchor\" href=\"#题目-4\">#</a> 题目</h2>\n<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串  <code>&quot;+100&quot;</code> 、 <code>&quot;5e2&quot;</code> 、 <code>&quot;-123&quot;</code> 、 <code>&quot;3.1416&quot;</code>  及  <code>&quot;-1E-16&quot;</code>  都表示数值，但  <code>&quot;12e&quot;</code> 、 <code>&quot;1a3.14&quot;</code> 、 <code>&quot;1.2.3&quot;</code> 、 <code>&quot;+-5&quot;</code>  及  <code>&quot;12e+5.4&quot;</code>  都不是。</p>\n<h2 id=\"思路-6\"><a class=\"anchor\" href=\"#思路-6\">#</a> 思路</h2>\n<p>表示数值的字符串遵循  <code>A[.[B]][e|EC]</code>  或者  <code>.B[e|EC]</code>  的模式，其中  <code>A</code>  为数值的整数部分， <code>B</code>  为紧跟着小数点的小数部分， <code>C</code>  为紧跟着  <code>e</code>  或者  <code>E</code>  的指数部分。当整数部分为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 时，小数可能会省略掉其整数部分，如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0.123</mn></mrow><annotation encoding=\"application/x-tex\">0.123</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.123</span></span></span></span> 写成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>.123</mn></mrow><annotation encoding=\"application/x-tex\">.123</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">.123</span></span></span></span>，即  <code>A</code>  在某些时候是不必要的。</p>\n<p>其中  <code>A</code>  和  <code>C</code>  可能以  <code>+</code>  或者  <code>-</code>  开头， <code>B</code>  的前面不能有正负号。</p>\n<h2 id=\"代码-6\"><a class=\"anchor\" href=\"#代码-6\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n\nbool scan_unsigned_integer(const string &amp;str, int &amp;index) &#123;\n    int original_index = index;\n    while (index &lt; str.size() &amp;&amp; str[index] &gt;= '0' &amp;&amp; str[index] &lt;= '9') &#123;\n        ++index;\n    &#125;\n\n    return index &gt; original_index;\n&#125;\n\n\nbool scan_integer(const string &amp;str, int &amp;index) &#123;\n    if (index &lt; str.size() &amp;&amp; (str[index] == '+' || str[index] == '-')) &#123;\n        ++index;\n    &#125;\n\n    return scan_unsigned_integer(str, index);\n&#125;\n\nbool is_numeric(const string &amp;str) &#123;\n    if (str.empty()) &#123;\n        return false;\n    &#125;\n\n    int index = 0;\n    bool numeric = scan_integer(str, index);\n\n    if (index &lt; str.size() &amp;&amp; str[index] == '.') &#123; // 包含小数部分\n        ++index;\n\n        // 使用 || 的原因\n        // 1. 小数可以没有整数部分\n        // 2. 小数点后面可以没有数字\n        // 3. 小数点前面和后面可以都有数字\n        numeric = scan_unsigned_integer(str, index) || numeric;\n    &#125;\n\n    if (index &lt; str.size() &amp;&amp; (str[index] == 'e' || str[index] == 'E')) &#123;\n        ++index;\n\n        // 使用 &amp;&amp; 的原因\n        // 1. 当 e 或者 E 前面没有数字时，整个字符串不能表示数字\n        // 2. 当 e 或者 E 后面没有数字时，整个字符串不能表示数字\n        numeric = numeric &amp;&amp; scan_integer(str, index);\n    &#125;\n\n    return numeric &amp;&amp; index == str.size();\n&#125;\n</code></pre>\n<h1 id=\"面试题调整数组顺序使奇数位于偶数前面\"><a class=\"anchor\" href=\"#面试题调整数组顺序使奇数位于偶数前面\">#</a> 面试题：调整数组顺序使奇数位于偶数前面</h1>\n<h2 id=\"题目-5\"><a class=\"anchor\" href=\"#题目-5\">#</a> 题目</h2>\n<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>\n<h2 id=\"思路-7\"><a class=\"anchor\" href=\"#思路-7\">#</a> 思路</h2>\n<p>利用双指针  <code>left</code>  和  <code>right</code> ， <code>left</code>  先正向遍历，当发现指向的数字不是奇数时，和  <code>right</code>  指针指向的内容进行交换，此时换为  <code>right</code>  指针反向遍历。当  <code>right</code>  指针指向的数字不是偶数时，和  <code>left</code>  指针指向的内容进行交换，换为  <code>left</code>  指针继续正向遍历。重复上述过程直到  <code>left</code>  和  <code>right</code>  指针指向相同的内容。</p>\n<h2 id=\"代码-7\"><a class=\"anchor\" href=\"#代码-7\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nbool is_even(int n) &#123;\n    return (n &amp; 1) == 0;\n&#125;\n\nvoid reorder(vector&lt;int&gt; &amp;data, bool (*func)(int)) &#123;\n    if (data.empty()) &#123;\n        return;\n    &#125;\n\n    int left = 0, right = data.size() - 1;\n    while (left &lt; right) &#123;\n        while (left &lt; right &amp;&amp; (func(data[left]) == false)) &#123;\n            ++left;\n        &#125;\n        while (left &lt; right &amp;&amp; func(data[right])) &#123;\n            --right;\n        &#125;\n        if (left &lt; right) &#123;\n            swap(data[left], data[right]);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-3/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-3/",
            "title": "剑指 Offer （三）",
            "date_published": "2021-09-19T05:11:21.000Z",
            "content_html": "<h1 id=\"面试题-10斐波那契数列\"><a class=\"anchor\" href=\"#面试题-10斐波那契数列\">#</a> 面试题 10：斐波那契数列</h1>\n<h2 id=\"题目一求斐波那契数列的第-n-项\"><a class=\"anchor\" href=\"#题目一求斐波那契数列的第-n-项\">#</a> 题目一：求斐波那契数列的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 项</h2>\n<p>写一个函数，输入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，求斐波那契 (Fibonacci) 数列的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 项。斐波那契数列的定义如下：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>0</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>=</mo><mn>0</mn><mo separator=\"true\">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>1</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mo separator=\"true\">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">f(n) = \\begin{cases}\n0, &amp; n = 0; \\\\\n1, &amp; n = 1; \\\\\nf(n-1) + f(n-2), &amp; n &gt; 1\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:4.32em;vertical-align:-1.91em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.35em;\"><span style=\"top:-2.2em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎩</span></span></span><span style=\"top:-2.192em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-3.15em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎨</span></span></span><span style=\"top:-4.292em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-4.6em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎧</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.85em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">;</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">;</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p>递归解法很容易解决这个问题，但是递归的时间复杂度是指数级别的。</p>\n<p>从公式可以看出，斐波那契数列的每一项只和前两项有关，因此在计算的时候，可以利用数组记录前两项，从过这两项计算出下一项的数字。之后更新数组。</p>\n<p>另一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的思路是通过矩阵乘法来实现。这个方法基于以下的公式：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><mo>=</mo><msup><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\begin{bmatrix}\n    f(n) &amp; f(n-1) \\\\\n    f(n-1) &amp; f(n-2)\n\\end{bmatrix} = \n\\begin{bmatrix}\n    1 &amp; 1 \\\\\n    1 &amp; 0\n\\end{bmatrix}\n^{n-1}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4em;vertical-align:-0.95em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.604em;vertical-align:-0.95em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.654em;\"><span style=\"top:-3.9029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>通过以上公式，只需要求得 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.604em;vertical-align:-0.95em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.654em;\"><span style=\"top:-3.9029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 即可得到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。而求矩阵的乘方可以通过快速幂的方法在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间内获得。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n\nlong long fibonacci(unsigned int n) &#123;\n    vector&lt;int&gt; result = &#123;0, 1&#125;;\n    if (n &lt; 2) &#123;\n        return result[n];\n    &#125;\n\n    long long first_term = 0;\n    long long second_term = 1;\n    long long n_th_term = 0;\n    for (unsigned int i = 2; i &lt;= n; ++i) &#123;\n        n_th_term = first_term + second_term;\n        first_term = second_term;\n        second_term = n_th_term;\n    &#125;\n\n    return n_th_term;\n&#125;\n</code></pre>\n<h2 id=\"题目二青蛙跳台阶\"><a class=\"anchor\" href=\"#题目二青蛙跳台阶\">#</a> 题目二：青蛙跳台阶</h2>\n<p>一只青蛙一次可以跳上 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 级台阶，也可以跳上 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 级台阶。求该青蛙跳上一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 级的台阶总共有多少种跳法。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>我们把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 级台阶时的跳法看成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的函数，记为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n&gt;2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 时，第一次跳的时候就有两种不同的选择：一是第一次只跳 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 级，此时跳法数目等于后面剩下的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 级台阶的跳法数目，即为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>；二是第一次跳 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 级，此时跳法数目等于后面剩下的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n-2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 级台阶的跳法数目，即为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n-2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span>。因此，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 级台阶的不同跳法的总数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n)=f(n-1)+f(n-2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span>，不难看出这实际上就是斐波那契数列。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<p>略</p>\n<h1 id=\"面试题-11旋转数组的最小数字\"><a class=\"anchor\" href=\"#面试题-11旋转数组的最小数字\">#</a> 面试题 11：旋转数组的最小数字</h1>\n<h1 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h1>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{3,4,5,1,2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,3,4,5\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">}</span></span></span></span> 的一个旋转，该数组的最小值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<h1 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h1>\n<p>原来的数组是有序的，旋转之后的数组可以划分为两个有序的子数组，且第一个有序子数组的数字均大于第二个有序子数组。最小元素即这两个有序子数组的分界线。</p>\n<p>用两个指针  <code>left</code>  和  <code>right</code>  分别指向数组的第一个元素和最后一个元素。按照题目中旋转的规则，第一个元素应该是大于或者等于最后一个元素。</p>\n<p>接着可以找到数组中间的元素  <code>mid</code> 。如果  <code>mid</code>  位于前面的递增子数组，那么应当有  <code>mid</code>  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo></mrow><annotation encoding=\"application/x-tex\">\\ge</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≥</span></span></span></span>  <code>left</code> 。此时数组中最小的元素应该位于  <code>mid</code>  的后面。可以把  <code>left</code>  指向  <code>mid</code>  指向的元素，这样可以缩小寻找的范围。移动之后的  <code>left</code>  指针仍然位于前面的递增子数组。</p>\n<p>同样，如果  <code>mid</code>  位于后面的递增子数组，那么应当有  <code>mid</code>  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span></span></span></span>  <code>right</code> 。此时该数组中最小的元素应该位于  <code>mid</code>  的前面。我们可以把  <code>right</code>  指向  <code>mid</code>  指向的元素，这样也可以缩小寻找的范围。移动之后的  <code>right</code>  指针仍然位于后面的递增子数组。</p>\n<p>按照上述思路， <code>left</code>  指针总是指向前面递增数组的元素，而  <code>right</code>  指针总是指向后面递增数组的元素。最终  <code>left</code>  指针将指向前面子数组的最后一个元素，而  <code>right</code>  指针会指向后面子数组的第一个元素。它们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。<strong>这就是循环结束的条件</strong>。</p>\n<p><img loading=\"lazy\" data-src=\"/images/coding_interviews_rotation_array.jpg\" alt=\"rotation_array\" /></p>\n<p>对于  <code>left</code>  指针和  <code>right</code>  指针指向的数字相同的情况，无法判断中间的数字属于哪一个子数组。此时必须采用顺序查找的办法，移动  <code>left</code>  或者  <code>right</code>  指针，直到两个指针指向的数字不相同。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint find_min_inorder(vector&lt;int&gt; &amp;numbers, int left_ptr, int right_ptr) &#123;\n    int ans = numbers[left_ptr];\n    for (int i = left_ptr; i &lt;= right_ptr; ++i) &#123;\n        if (ans &gt; numbers[i]) &#123;\n            ans = numbers[i];\n        &#125;\n    &#125;\n    return ans;\n&#125;\n\n\nint find_min(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.empty()) &#123;\n        throw &quot;Invalid parameters&quot;;\n    &#125;\n\n    int left_ptr = 0;\n    int right_ptr = numbers.size() - 1;\n    int mid_ptr = left_ptr;\n\n    while (numbers[left_ptr] &gt;= numbers[right_ptr]) &#123;\n        if (right_ptr - left_ptr == 1) &#123;\n            mid_ptr = right_ptr;\n            break;\n        &#125;\n\n        mid_ptr = left_ptr + (right_ptr - left_ptr) / 2;\n\n        // 如果 left_ptr，right_ptr，mid_ptr 指向的三个数字相等，需要顺序查找\n        if (numbers[left_ptr] == numbers[right_ptr] &amp;&amp;\n            numbers[mid_ptr] == numbers[left_ptr]) &#123;\n            return find_min_inorder(numbers, left_ptr, right_ptr);\n        &#125;\n\n        if (numbers[mid_ptr] &gt;= numbers[left_ptr]) &#123;\n            left_ptr = mid_ptr;\n        &#125; else if (numbers[mid_ptr] &lt;= numbers[right_ptr]) &#123;\n            right_ptr = mid_ptr;\n        &#125;\n    &#125;\n\n    return numbers[mid_ptr];\n&#125;\n</code></pre>\n<h1 id=\"面试题-12矩阵中的路径\"><a class=\"anchor\" href=\"#面试题-12矩阵中的路径\">#</a> 面试题 12：矩阵中的路径</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>回溯法典型例题。在矩阵中任选一个点作为起点，进行深度优先遍历。第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个各自对应于字符串的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个字符，如果两个字符不相同，那么该路径必然不是所求的目标路径。如果相同，那么以该位置作为起点，继续进行搜索。重复上述过程直到找到目标路径或者发现无目标路径。</p>\n<p>由于路径不能重复经过某一个位置，因此还需要一个矩阵记录每个位置是否被访问过。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n\nbool has_path_core(const vector&lt;vector&lt;char&gt;&gt; &amp;matrix, int i, int j, const string &amp;str,\n                   int &amp;path_len, vector&lt;vector&lt;bool&gt;&gt; &amp;visited) &#123;\n    if (str.size() == path_len) &#123;\n        return true;\n    &#125;\n\n    int row = matrix.size();\n    int col = matrix[0].size();\n    bool is_has_path = false;\n    if (i &gt;= 0 &amp;&amp; i &lt; row &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; col &amp;&amp;\n        matrix[i][j] == str[path_len] &amp;&amp;\n        visited[i][j] == false) &#123;\n        ++path_len;\n        visited[i][j] = true;\n\n        is_has_path = has_path_core(matrix, i, j - 1, str, path_len, visited) ||\n                      has_path_core(matrix, i - 1, j, str, path_len, visited) ||\n                      has_path_core(matrix, i, j + 1, str, path_len, visited) ||\n                      has_path_core(matrix, i + 1, j, str, path_len, visited);\n\n        if (is_has_path == false) &#123;\n            --path_len;\n            visited[i][j] = false;\n        &#125;\n    &#125;\n\n    return is_has_path;\n&#125;\n\n\nbool has_path(vector&lt;vector&lt;char&gt;&gt; &amp;matrix, const string &amp;str) &#123;\n    if (matrix.empty() || matrix[0].size() == 0 || str.size() == 0) &#123;\n        return false;\n    &#125;\n\n    int row = matrix.size();\n    int col = matrix[0].size();\n    vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col, false));\n\n    int path_len = 0;\n    for (int i = 0; i &lt; row; ++i) &#123;\n        for (int j = 0; j &lt; col; ++j) &#123;\n            if (has_path_core(matrix, i, j, str, path_len, visited)) &#123;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n</code></pre>\n<h1 id=\"面试题-13机器人的运动范围\"><a class=\"anchor\" href=\"#面试题-13机器人的运动范围\">#</a> 面试题 13：机器人的运动范围</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>地上有一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 列的方格。一个机器人从坐标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(0,0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> 的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的格子。例如，当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>18</mn></mrow><annotation encoding=\"application/x-tex\">18</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">18</span></span></span></span> 时，机器人能够进入方格 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>35</mn><mo separator=\"true\">,</mo><mn>37</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(35,37)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">35</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">37</span><span class=\"mclose\">)</span></span></span></span>，因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>7</mn><mo>=</mo><mn>18</mn></mrow><annotation encoding=\"application/x-tex\">3+5+3+7=18</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">7</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">18</span></span></span></span>。但它不能进入方格 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>35</mn><mtext>，</mtext><mn>38</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(35，38)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">35</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\">38</span><span class=\"mclose\">)</span></span></span></span>，因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>8</mn><mo>=</mo><mn>19</mn></mrow><annotation encoding=\"application/x-tex\">3+5+3+8=19</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">19</span></span></span></span>。请问该机器人能够到达多少个格子？</p>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>机器人从坐标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(0,0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> 开始移动。当它准备进入坐标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的格子时，通过检査坐标的数位和来判断机器人是否能够进入。如果机器人能够进入坐标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i, j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的格子，则再判断它能否进入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span> 个相邻的格子 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">i-1,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i, j+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i+1,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n\nusing namespace std;\n\nint get_digit_sum(int number) &#123;\n    int sum = 0;\n    while (number &gt; 0) &#123;\n        sum += number % 10;\n        number /= 10;\n    &#125;\n    return sum;\n&#125;\n\nbool check(int threshold, int rows, int cols, int i, int j, vector&lt;vector&lt;bool&gt;&gt; &amp;visited) &#123;\n    if (i &gt;= 0 &amp;&amp; i &lt; rows &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; cols &amp;&amp;\n            get_digit_sum(i) + get_digit_sum(j) &lt;= threshold &amp;&amp;\n            visited[i][j] == false) &#123;\n        return true;\n    &#125;\n    return false;\n&#125;\n\n\nint moving_count_core(int threshold, int rows, int cols, int i, int j, vector&lt;vector&lt;bool&gt;&gt; &amp;visited) &#123;\n    int count = 0;\n    if (check(threshold, rows, cols, i, j, visited)) &#123;\n        visited[i][j] = true;\n\n        count = 1 + moving_count_core(threshold, rows, cols, i - 1, j, visited) +\n                    moving_count_core(threshold, rows, cols, i, j - 1, visited) +\n                    moving_count_core(threshold, rows, cols, i + 1, j, visited) +\n                    moving_count_core(threshold, rows, cols, i, j + 1, visited);\n    &#125;\n    return count;\n&#125;\n\n\nint moving_count(int threshold, int rows, int cols) &#123;\n    if (threshold &lt; 0 || rows &lt;= 0 || cols &lt;= 0) &#123;\n        return 0;\n    &#125;\n\n    vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(cols, false));\n\n    int count = moving_count_core(threshold, rows, cols, 0, 0, visited);\n\n    return count;\n&#125;\n</code></pre>\n<h1 id=\"面试题-14剪绳子\"><a class=\"anchor\" href=\"#面试题-14剪绳子\">#</a> 面试题 14：剪绳子</h1>\n<h2 id=\"题目-4\"><a class=\"anchor\" href=\"#题目-4\">#</a> 题目</h2>\n<p>给定一根长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的绳子，把绳子剪成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 段 （<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 都是整数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n&gt;1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 并且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">m&gt;1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>），每段绳子的长度记为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">[</mo><mi>m</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[0],k[1],\\cdots,k[m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span></span></span></span>。请问 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo>×</mo><mi>k</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>×</mo><mo>⋯</mo><mo>×</mo><mi>k</mi><mo stretchy=\"false\">[</mo><mi>m</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[0]\\times k[1] \\times \\cdots \\times k[m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span></span></span></span> 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 的三段，此时得到的最大乘积是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>18</mn></mrow><annotation encoding=\"application/x-tex\">18</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">18</span></span></span></span>。</p>\n<h2 id=\"思路-6\"><a class=\"anchor\" href=\"#思路-6\">#</a> 思路</h2>\n<h3 id=\"动态规划\"><a class=\"anchor\" href=\"#动态规划\">#</a> 动态规划</h3>\n<p>定义函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 为把长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀的时候，有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 种可能的选择，因此 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><munder><mrow><mi mathvariant=\"normal\">arg max</mi><mo>⁡</mo></mrow><mi>i</mi></munder><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo separator=\"true\">,</mo><mspace width=\"1em\"/><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">f(n)=\\argmax\\limits_{i}{f(i)\\times f(n-1)}, \\quad 0&lt;i&lt;n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.6721em;vertical-align:-0.9221em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4306em;\"><span style=\"top:-2.1779em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop\"><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">arg</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">max</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9221em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>。</p>\n<p>这个公式如果直接计算，会有很多重复的子问题，造成大量不必要的计算。更好的方法是按照自底向上的顺序计算。</p>\n<p>当绳子长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 时，只可能将其剪成长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的两端，故 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f(2)=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。当绳子长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 时，有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">{1,2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{1,1,1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span></span></span></span></span> 两种方式，由于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>×</mo><mn>2</mn><mo>&gt;</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1\\times 2 &gt; 1\\times 1 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，故 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">f(3) = 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>。</p>\n<h3 id=\"贪心算法\"><a class=\"anchor\" href=\"#贪心算法\">#</a> 贪心算法</h3>\n<p>一个满足题目所求的贪心方法是：当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">n\\ge5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span> 时，尽可能多地将绳子剪长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 的绳子；当剩余的绳子长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span> 时，把绳子剪成长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 的绳子。</p>\n<p>原书上的证明过于简单，可以参考  <code>LeetCode</code>  上的<a href=\"https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/\">链接</a>。</p>\n<h2 id=\"代码-6\"><a class=\"anchor\" href=\"#代码-6\">#</a> 代码</h2>\n<h3 id=\"动态规划-2\"><a class=\"anchor\" href=\"#动态规划-2\">#</a> 动态规划</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nint cut_rope_dp(int length) &#123;\n    if (length &lt; 2) &#123;\n        return 0;\n    &#125;\n    if (length == 2) &#123;\n        return 1;\n    &#125;\n    if (length == 3) &#123;\n        return 2;\n    &#125;\n\n    vector&lt;int&gt; products(length + 1, 0);\n    products[0] = 0;\n    products[1] = 1;\n    products[2] = 2;    // 这里为 2 是因为绳子长度大于 3，长度为 2 的绳子不剪时的乘积更大\n    products[3] = 3;    // 理由同上\n\n    int max_product = 0;\n    for (int i = 4; i &lt;= length; ++i) &#123;\n        max_product = 0;\n        for (int j = 1; j &lt;= i/2; ++j) &#123;\n            int product = products[i] * products[i - j];\n            max_product = max(product, max_product);\n            products[i] = max_product;\n        &#125;\n    &#125;\n\n    max_product = products[length];\n    return max_product;\n&#125;\n\n</code></pre>\n<h3 id=\"贪心算法-2\"><a class=\"anchor\" href=\"#贪心算法-2\">#</a> 贪心算法</h3>\n<pre><code class=\"language-cpp\">int cut_rope_greedy(int length) &#123;\n    if (length &lt; 2) &#123;\n        return 0;\n    &#125;\n    if (length == 2) &#123;\n        return 1;\n    &#125;\n    if (length == 3) &#123;\n        return 2;\n    &#125;\n\n    // 尽可能多地剪去长度为 3 的绳子段\n    int num_of_three = length / 3;\n    // 当绳子最后的长度为 4 的时候，不能再剪去长度为 3 的绳子段\n    // 因为剪成两端长度为 2 的绳子的乘积更大\n    if (length - num_of_three * 3 == 1) &#123;\n        num_of_three -= 1;\n    &#125;\n\n    int num_of_two = (length - num_of_three * 3) / 2;\n    return static_cast&lt;int&gt;(pow(3, num_of_three)) * static_cast&lt;int&gt;(pow(2, num_of_two));\n&#125;\n</code></pre>\n<h1 id=\"面试题-15二进制中-1-的个数\"><a class=\"anchor\" href=\"#面试题-15二进制中-1-的个数\">#</a> 面试题 15：二进制中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的个数</h1>\n<h2 id=\"题目-5\"><a class=\"anchor\" href=\"#题目-5\">#</a> 题目</h2>\n<p>请实现一个函数，输入一个整数，输出该数二进制表示中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的个数。例如，把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span> 表示成二进制是  <code>1001</code> ， 有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 位是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。因此，如果输入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span>，则该函数输出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>。</p>\n<h2 id=\"思路-7\"><a class=\"anchor\" href=\"#思路-7\">#</a> 思路</h2>\n<p>常规思路是每次判断最低为是否为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，判断之后进行右移运算。对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">32</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">32</span></span></span></span> 位的整数需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">32</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">32</span></span></span></span> 次循环。</p>\n<p>除了这种方法之外，可以通过  <code>n &amp; (n-1)</code>  快速计算。分析如下：</p>\n<ul>\n<li>如果一个整数不等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，那么该整数的二进制表示中至少有一位是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。</li>\n<li>如果这个数的最右边一位是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，那么减去 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 时，最后一位变成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 而其他所有位都保持不变。也就是最后一位相当于做了取反操作，由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 变成了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>。</li>\n<li>最后一位不是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 而是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 的情况。如果该整数的二进制表示中最右边的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 位于第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 位，那么减去 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 时，第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 位由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 变成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，而第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 位之后的所有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 都变成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, 整数中第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 位之前的所有位都保持不变。举个例子：一个二进制数  <code>1100</code> ，它的第二位是从最右边数起的一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。减去 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 后，第二位变成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，它后面的两位 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 变成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，而前面的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 保持不变，因此得到的结果是  <code>1011</code> 。</li>\n<li>把一个整数减去 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，再和原整数做与运算，会把该整数最右边的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 变成 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>。</li>\n</ul>\n<h2 id=\"代码-7\"><a class=\"anchor\" href=\"#代码-7\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nint number_of_one(int n) &#123;\n    int count = 0;\n    while (n) &#123;\n        ++count;\n        n = (n - 1) &amp; n;\n    &#125;\n    return count;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-2/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-2/",
            "title": "剑指 Offer （二）",
            "date_published": "2021-09-18T06:57:49.000Z",
            "content_html": "<h1 id=\"面试题-7重建二叉树\"><a class=\"anchor\" href=\"#面试题-7重建二叉树\">#</a> 面试题 7：重建二叉树</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，输入前序遍历序列 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>8</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,4,7,3,5,6,8\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mclose\">}</span></span></span></span> 和中序遍历序列<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>6</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{4,7,2,1,5,3,8,6\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mclose\">}</span></span></span></span>，则重建如图所示的二叉树并输出它的头节点。二叉树节点的定义如下：</p>\n<pre><code class=\"language-cpp\">struct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"/images/coding_interviews_binary_tree_rebuild.jpg\" alt=\"binary_tree_rebuild\" /></p>\n<h2 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h2>\n<p>在二叉树的前序遍历序列中，第一个数字总是树的根节点的值。但在中序遍历序列中，根节点的值在序列的中间，左子树的节点的值位于根节点的值的左边，而右子树的节点的值位于根节点的值的右边。因此我们需要扫描中序遍历序列，才能找到根节点的值。</p>\n<p>根据前序遍历序列，我们能够找到当前树的根节点；然后在中序遍历序列中，根据根节点的位置，判断左子树和右子树的节点数量。由此可以在前序遍历的序列中确定左子树和右子树的分界点。之后，对于左子树和右子树重复上述过程，即可完成重建。</p>\n<h2 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nBinaryTreeNode *build_core(vector&lt;int&gt;::iterator pre_begin, vector&lt;int&gt;::iterator pre_end,\n                           vector&lt;int&gt;::iterator in_begin, vector&lt;int&gt;::iterator in_end) &#123;\n     if (pre_begin == pre_end || in_begin == in_end) &#123;\n        return nullptr;\n    &#125;\n\n    int root_val = *pre_begin;\n    BinaryTreeNode *root = new BinaryTreeNode();\n    root-&gt;m_value = root_val;\n    root-&gt;m_left = root-&gt;m_right = nullptr;\n\n    vector&lt;int&gt;::iterator root_inorder_it = in_begin;\n    while (root_inorder_it &lt; in_end &amp;&amp; *root_inorder_it != root_val) &#123;\n        ++root_inorder_it;\n    &#125;\n\n    if (root_inorder_it == in_end) &#123;\n        return nullptr;\n    &#125;\n\n    int left_len = root_inorder_it - in_begin;\n    int right_len = in_end - root_inorder_it - 1;\n    if (left_len &gt; 0) &#123;\n        root-&gt;m_left = build_core(pre_begin + 1, pre_begin + left_len + 1, in_begin, root_inorder_it);\n    &#125;\n    if (right_len &gt; 0) &#123;\n        root-&gt;m_right = build_core(pre_begin + left_len + 1, pre_end, root_inorder_it + 1, in_end);\n    &#125;\n\n    return root;\n&#125;\n\nBinaryTreeNode *build(vector&lt;int&gt; preorder, vector&lt;int&gt; inorder) &#123;\n    if (preorder.empty() || inorder.empty() || preorder.size() != inorder.size()) &#123;\n        return nullptr;\n    &#125;\n\n    return build_core(preorder.begin(), preorder.end(), inorder.begin(), inorder.end());\n&#125;#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n&#125;;\n\nBinaryTreeNode *build_core(vector&lt;int&gt;::iterator pre_begin, int pre_len,\n                           vector&lt;int&gt;::iterator in_begin, int in_len) &#123;\n    int root_val = *pre_begin;\n    BinaryTreeNode *root = new BinaryTreeNode();\n    root-&gt;m_value = root_val;\n    root-&gt;m_left = root-&gt;m_right = nullptr;\n\n    if (pre_len == 1) &#123;\n        if (in_len == 1 &amp;&amp; *pre_begin == *in_begin) &#123;\n            return root;\n        &#125; else &#123;\n            throw exception(&quot;Invalid input.&quot;);\n        &#125;\n    &#125; else if (pre_len != in_len) &#123;\n        throw exception(&quot;Invalid input.&quot;);\n    &#125;\n\n    vector&lt;int&gt;::iterator root_inorder_it = in_begin;\n    while (root_inorder_it &lt; in_begin + in_len &amp;&amp; *root_inorder_it != root_val) &#123;\n        ++root_inorder_it;\n    &#125;\n\n    if (root_inorder_it == in_begin + in_len) &#123;\n        throw exception(&quot;Invalid input.&quot;);\n    &#125;\n\n    int left_len = root_inorder_it - in_begin;\n    int right_len = in_len - left_len - 1;\n    if (left_len &gt; 0) &#123;\n        root-&gt;m_left = build_core(pre_begin + 1, left_len, in_begin, left_len);\n    &#125;\n    if (right_len &gt; 0) &#123;\n        root-&gt;m_right = build_core(pre_begin + left_len + 1, right_len, in_begin, right_len);\n    &#125;\n\n    return root;\n&#125;\n\nBinaryTreeNode *build(vector&lt;int&gt; preorder, vector&lt;int&gt; inorder) &#123;\n    if (preorder.empty() || inorder.empty() || preorder.size() != inorder.size()) &#123;\n        return nullptr;\n    &#125;\n\n    return build_core(preorder.begin(), preorder.size(), inorder.begin(), inorder.size());\n&#125;\n</code></pre>\n<h1 id=\"面试题-8二叉树的下一个节点\"><a class=\"anchor\" href=\"#面试题-8二叉树的下一个节点\">#</a> 面试题 8：二叉树的下一个节点</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</p>\n<h2 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h2>\n<p>如果一个节点有右子树，那么它的下一个节点就是它的右子树中的最左节点。</p>\n<p>如果一个节点没有右子树，并且是其父节点的左子节点，那么它的下一个节点就是它的父节点。</p>\n<p>如果一个节点没有右子树，并且是其父节点的右子节点，那么需要沿着父节点遍历，直到找到一个节点，这个节点是它的父节点的左子节点。如果这样的节点不存在，说明最开始的节点是树中的最右节点，没有下一个节点。</p>\n<p>上述的下一个节点，即一个节点的后继 (successor)；对应地，前一个节点称为前驱 (predecessor)。</p>\n<p>针对不同的遍历方式，如前序遍历和后序遍历，前驱和后继表示的节点也不相同，这里暂时不详细讨论。</p>\n<h2 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n\nstruct BinaryTreeNode &#123;\n    int m_value;\n    BinaryTreeNode *m_left;\n    BinaryTreeNode *m_right;\n    BinaryTreeNode *m_parent;\n&#125;;\n\nBinaryTreeNode *inorder_successor(BinaryTreeNode *node) &#123;\n    if (node == nullptr) &#123;\n        return nullptr;\n    &#125;\n\n    BinaryTreeNode *next = nullptr;\n    // 如果节点有右子树，寻找右子树的最左节点\n    if (node-&gt;m_right != nullptr) &#123;\n        BinaryTreeNode *right = node-&gt;m_right;\n        while (right-&gt;m_left != nullptr) &#123;\n            right = right-&gt;m_left;\n        &#125;\n        next = right;\n    &#125; else if (node-&gt;m_parent != nullptr) &#123;\n        BinaryTreeNode *cur = node;\n        BinaryTreeNode *parent = node-&gt;m_parent;\n        while (parent != nullptr &amp;&amp; cur == parent-&gt;m_right) &#123;\n            cur = parent;\n            parent = parent-&gt;m_parent;\n        &#125;\n        next = parent;\n    &#125;\n    return next;\n&#125;\n</code></pre>\n<h1 id=\"面试题-9用两个栈实现队列\"><a class=\"anchor\" href=\"#面试题-9用两个栈实现队列\">#</a> 面试题 9：用两个栈实现队列</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数  <code>append_tail</code>  和  <code>delete_head</code> ，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt; class Queue &#123;\npublic:\n    Queue();\n    ~Queue();\n\n    void append_tail(const T&amp; node);\n    T delete_head();\n\nprivate:\n    stack&lt;T&gt; stack1;\n    stack&lt;T&gt; stack2;\n&#125;\n</code></pre>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>对于两个栈  <code>stack1</code>  和  <code>stack2</code> ， <code>stack1</code>  用于插入元素，而  <code>stack2</code>  则用于删除元素。</p>\n<p>当有元素插入时，直接插入到  <code>stack1</code>  中；</p>\n<p>当删除元素时，如果  <code>stack2</code>  为空，则将  <code>stack1</code>  中的元素依次弹出插入到  <code>stack2</code>  中，这时  <code>stack2</code>  中的元素出栈的顺序和  <code>stack1</code>  中的元素入栈的顺序一致，即模拟了队列的先进先出的性质；而如果  <code>stack2</code>  不为空，此时栈顶的元素对应队列的队首元素，可以直接删除栈顶的元素。</p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt; class Queue &#123;\npublic:\n    Queue();\n    ~Queue();\n\n    void append_tail(const T&amp; element);\n    T delete_head();\n\nprivate:\n    stack&lt;T&gt; stack1;\n    stack&lt;T&gt; stack2;\n&#125;;\n\ntemplate&lt;typename T&gt;\nvoid Queue&lt;T&gt;::append_tail(const T &amp;element) &#123;\n    stack1.push(element);\n&#125;\n\ntemplate&lt;typename T&gt;\nT Queue&lt;T&gt;::delete_head() &#123;\n    if (stack2.size() &lt;= 0) &#123;\n        while (stack1.size() &gt; 0) &#123;\n            T &amp;data = stack1.top();\n            stack1.pop();\n            stack2.push(data);\n        &#125;\n    &#125;\n\n    if (stack2.size() == 0) &#123;\n        throw &quot;Queue is empty&quot;;\n    &#125;\n\n    T head = stack2.top();\n    stack2.pop();\n\n    return head;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        },
        {
            "id": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-1/",
            "url": "https://linn-ylz.com/Computer-Science/Coding-Interviews/coding-interviews-1/",
            "title": "剑指 Offer （一）",
            "date_published": "2021-09-15T02:20:11.000Z",
            "content_html": "<p>本系列文章是《剑指 Offer（第二版）》的个人笔记。主要是对作者的思路讲解在个人理解的基础上进行精炼，并且将其中的代码用更加偏  <code>C++</code>  的风格进行改写。</p>\n<h1 id=\"面试题-3数组中重复的数字\"><a class=\"anchor\" href=\"#面试题-3数组中重复的数字\">#</a> 面试题 3：数组中重复的数字</h1>\n<h2 id=\"题目一找出数组中重复的数字\"><a class=\"anchor\" href=\"#题目一找出数组中重复的数字\">#</a> 题目一：找出数组中重复的数字</h2>\n<p>在一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的数组里的所有数字都在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的范围内。数组中某些数字是重复的，但不知道有<strong>几个</strong>数字重复了，也不知道每个数字重复了<strong>几次</strong>。请找出数组中任意个重复的数字。例如，如果输入长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">7</span></span></span></span> 的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>3</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{2, 3, 1, 0, 2, 5, 3\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mclose\">}</span></span></span></span>，那么对应的输出是重复的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>。</p>\n<h3 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路</h3>\n<p>题目给定的数字都在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> ~ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的范围内，如果假定数组内的数字有序，并且数组中没有重复的数字，那么数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 应该出现在下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 对应的位置。</p>\n<p>现在，由于数组中可能有重复的数字，那么可能存在下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span>，不与数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 对应，数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 可能缺失，也有可能因为在前面位置的数字重复而导致位置在下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 之后。</p>\n<p>我们从头到尾依次遍历数组中的每个数字，当遍历到下标为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的数字时，首先比较该位置的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 是否等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>。如果相等，那么继续遍历；如果不相等，那么将其与第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个数字进行比较。如果其与第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个数字相等，就找到了一个重复的数字（出现在位置 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 和位置 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>）；如果不相等，那么将第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 个数字和第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个数字进行交换。接下来重复比较、交换的过程，直到发现一个重复的数字。</p>\n<h3 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h3>\n<pre><code class=\"language-cpp\">#include&lt;vector&gt;\nusing namespace std;\n\nbool duplicate(vector&lt;int&gt; &amp;numbers, int *duplication) &#123;\n    if (numbers.size() == 0) &#123;\n        return false;\n    &#125;\n\n    for (int i = 0; i &lt; numbers.size(); ++i) &#123;\n        if (numbers[i] &lt; 0 || numbers[i] &gt; numbers.size()) &#123;\n            return false;\n        &#125;\n    &#125;\n\n    for (int i = 0; i &lt; numbers.size(); ++i) &#123;\n        while(numbers[i] != i) &#123;\n            if (numbers[i] == numbers[numbers[i]]) &#123;\n                *duplication = numbers[i];\n                return true;\n&#125;\n\n            // swap numbers[i] and numbers[numbers[i]]\n            swap(numbers[i], numbers[numbers[i]]);\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<h2 id=\"题目二不修改数组找出重复的数字\"><a class=\"anchor\" href=\"#题目二不修改数组找出重复的数字\">#</a> 题目二：不修改数组找出重复的数字</h2>\n<p>在一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的数组里的所有数字都在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>7</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0, 3, 5, 4, 3, 2, 6, 7\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mclose\">}</span></span></span></span>，那么对应的输出是重复的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> 或者 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>。</p>\n<h3 id=\"思路-2\"><a class=\"anchor\" href=\"#思路-2\">#</a> 思路</h3>\n<p>这一题和上一题有些类似，但是不同点在于不能修改输入的数组。由于数组中的数字都属于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，而数组的长度又为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，那么必然有一个重复的数字。</p>\n<p>我们把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 的数字以中间的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 为界，将数组分为两个部分，前一半的数字为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>，后一半的数字为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">m+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>。如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 的数字的数目超过了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>，那么可以确定这一半之中必定包含重复的数字；否则在另一半中必定包含重复的数字。重复这一过程，将数组继续一分为二，直到找到一个重复的数字。</p>\n<h3 id=\"代码-2\"><a class=\"anchor\" href=\"#代码-2\">#</a> 代码</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n\nint count_range(vector&lt;int&gt; &amp;numbers, int lower, int upper) &#123;\n    if (lower &gt; upper) &#123;\n        return 0;\n    &#125;\n\n    int count = 0;\n    for (int i = 0; i &lt; numbers.size(); ++i) &#123;\n        if (numbers[i] &gt;= lower &amp;&amp; numbers[i] &lt;= upper) &#123;\n            ++count;\n        &#125;\n    &#125;\n\n    return count;\n&#125;\n\nint get_duplicate(vector&lt;int&gt; &amp;numbers) &#123;\n    if (numbers.size() &lt;= 0) &#123;\n        return -1;\n    &#125;\n\n    int lower = 1;\n    int upper = numbers.size() - 1;\n    while (lower &lt;= upper) &#123;\n        int mid = lower + ((upper - lower) &gt;&gt; 1);\n        int count = count_range(numbers, lower, mid);\n        if (lower == upper) &#123;\n            if (count &gt; 1) &#123;\n                return lower;\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n\n        if (count &gt; (mid - lower + 1)) &#123;\n            upper = mid;\n        &#125; else &#123;\n            lower = mid + 1;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n\n</code></pre>\n<h1 id=\"面试题-4二维数组中的查找\"><a class=\"anchor\" href=\"#面试题-4二维数组中的查找\">#</a> 面试题 4：二维数组中的查找</h1>\n<h2 id=\"题目\"><a class=\"anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h2 id=\"思路-3\"><a class=\"anchor\" href=\"#思路-3\">#</a> 思路</h2>\n<p>对于一维数组而言，可以使用二分查找很快的判断一个数是否在数组中。对于本题的数组而言，也可以使用二分法进行查找，关键点在于如何选取初始查找的位置。</p>\n<p>假如我们从左上角的开始查找，当前所处的位置是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{i,j\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">}</span></span></span></span>，以该点所在行和列为界限，将二维数组矩阵划分为四个区域。如果查找的数字大于当前的值，该值可能在右上、右下、左下的区域中，达不到将搜索区域减半的效果。例如上方矩阵中的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>。同理，从右下角开始，如果查找的数字比当前的值小，那么该值可能在左上、左下、右上三个区域，也无法决定接下来该选择哪个方向继续搜索。</p>\n<p>我们不妨换个思路，将二维数组看成是由多个一维数组组合而成。例如上方的矩阵，我们可以看成是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>12</mn><mo separator=\"true\">,</mo><mn>13</mn><mo separator=\"true\">,</mo><mn>15</mn><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>11</mn><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>8</mn><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mn>6</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,8,9,12,13,15\\}, \\{2,4,9,10,11\\},\\{4,7,8\\},\\{6\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">12</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">13</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">15</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">10</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">11</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">6</span><span class=\"mclose\">}</span></span></span></span> 组成的，它们都是有序的一维数组。</p>\n<p>对于一维数组，我们很容易知道是从其中点位置可是查找。因此第一个搜索的位置可以定在右上角的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span>；接着回忆，当目标值和当前值进行比较之后，我们可以将数组中一半的值丢弃。假如我们的查找值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">7</span></span></span></span>，那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>12</mn><mo separator=\"true\">,</mo><mn>13</mn><mo separator=\"true\">,</mo><mn>15</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,8,9,12,13,15\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">12</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">13</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">15</span><span class=\"mclose\">}</span></span></span></span> 这一数组中我们需要将后一半的数字丢弃。而在二维矩阵中，这一操作可以通过行号或者列号的变化来实现。比如说在上方矩阵中，丢弃 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>12</mn><mo separator=\"true\">,</mo><mn>13</mn><mo separator=\"true\">,</mo><mn>15</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{9,12,13,15\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">12</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">13</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">15</span><span class=\"mclose\">}</span></span></span></span> 这一操作对应列号的减少。</p>\n<p>经过这一操作之后，我们可以发现，新的矩阵可以视作 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>11</mn><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>7</mn><mo separator=\"true\">,</mo><mn>8</mn><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mn>6</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,8,9,10,11\\},\\{2,4,7,8\\},\\{6\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">10</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">11</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">7</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">6</span><span class=\"mclose\">}</span></span></span></span> 组成的。接下来我们可以进一步执行上述的操作，直到找到对应的数值，或者所有数值都查找完毕。</p>\n<p><img loading=\"lazy\" data-src=\"/images/coding_interviews_2d_matrix_search.jpg\" alt=\"2d_matrix_search\" /></p>\n<h2 id=\"代码-3\"><a class=\"anchor\" href=\"#代码-3\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n\nbool find(vector&lt;vector&lt;int&gt;&gt; matrix, int number) &#123;\n    bool is_found = false;\n\n    if (!matrix.empty()) &#123;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int i = 0, j = col - 1;\n        while (i &lt; row &amp;&amp; col &gt;= 0) &#123;\n            if (matrix[i][j] == number) &#123;\n                is_found = true;\n                break;\n            &#125; else if (matrix[i][j] &gt; number) &#123;\n                --j;\n            &#125; else &#123;\n                ++i;\n            &#125;\n        &#125;\n    &#125;\n    return is_found;\n&#125;\n</code></pre>\n<h1 id=\"面试题-5替换空格\"><a class=\"anchor\" href=\"#面试题-5替换空格\">#</a> 面试题 5：替换空格</h1>\n<h2 id=\"题目-2\"><a class=\"anchor\" href=\"#题目-2\">#</a> 题目</h2>\n<p>请实现一个函数，把字符串中的每个空格替换成 &quot;%20&quot;。例如输入 “We are happy.”，则输出 “We%20are%20happy.”。</p>\n<h2 id=\"思路-4\"><a class=\"anchor\" href=\"#思路-4\">#</a> 思路</h2>\n<p>如果不限制返回的字符串是在原字符串的基础上修改的话，那么可以很容易地分配一个新的字符串，然后遍历原字符串并替换空格，将结果写入到新的字符串中。</p>\n<p>如果限制返回的字符串是在原址上进行修改的，那么对于长度固定的字符串，我们可以通过遍历一遍字符串，统计出其中空格的数量，然后计算出替换之后的新的字符串的长度。之后在原址上通过倒序的方式进行替换。</p>\n<h2 id=\"代码-4\"><a class=\"anchor\" href=\"#代码-4\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nvoid replace_blank(char *str, int length) &#123;\n    if (str == nullptr || length &lt;= 0) &#123;\n        return;\n    &#125;\n\n    int original_len = 0;\n    int num_of_blank = 0;\n    int i = 0;\n    while (str[i] != '\\0') &#123;\n        ++original_len;\n        if (str[i] == ' ') &#123;\n            ++num_of_blank;\n        &#125;\n        ++i;\n    &#125;\n\n    int new_len = original_len + num_of_blank * 2;\n    if (new_len &gt; length) &#123;\n        return;\n    &#125;\n\n    int index_of_origin = original_len;\n    int index_of_new = new_len;\n    while (index_of_origin &gt;= 0 &amp;&amp; index_of_new &gt; index_of_origin) &#123;\n        if (str[index_of_origin] == ' ') &#123;\n            str[index_of_new--] = '0';\n            str[index_of_new--] = '2';\n            str[index_of_new--] = '%';\n        &#125; else &#123;\n            str[index_of_new--] = str[index_of_origin];\n        &#125;\n        --index_of_origin;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"面试题-6从尾到头打印链表\"><a class=\"anchor\" href=\"#面试题-6从尾到头打印链表\">#</a> 面试题 6：从尾到头打印链表</h1>\n<h2 id=\"题目-3\"><a class=\"anchor\" href=\"#题目-3\">#</a> 题目</h2>\n<p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下</p>\n<pre><code class=\"language-cpp\">struct ListNode &#123;\n    int m_key;\n    ListNode *m_next;    \n&#125;\n</code></pre>\n<h2 id=\"思路-5\"><a class=\"anchor\" href=\"#思路-5\">#</a> 思路</h2>\n<p>如果将链表逆序，可以很容易实现。如果不能改变链表的结构，那么可以利用栈的先进后出的性质，将值存储到栈中，然后输出其中的值。而递归本质上就是一个栈结构，也可以利用其实现。</p>\n<h2 id=\"代码-5\"><a class=\"anchor\" href=\"#代码-5\">#</a> 代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nstruct ListNode &#123;\n    int m_key;\n    ListNode *m_next;\n&#125;;\n\nvoid print_list_reversely_iteratively(ListNode *head) &#123;\n    stack&lt;ListNode*&gt; nodes;\n\n    ListNode *node = head;\n    while (node != nullptr) &#123;\n        nodes.push(node);\n        node = node-&gt;m_next;\n    &#125;\n\n    while (!nodes.empty()) &#123;\n        node = nodes.top();\n        cout &lt;&lt; node-&gt;m_key &lt;&lt; &quot;\\t&quot;;\n        nodes.pop();\n    &#125;\n&#125;\n\n\nvoid print_list_reversely_recursively(ListNode *head) &#123;\n    if (head != nullptr) &#123;\n        if (head-&gt;m_next != nullptr) &#123;\n            print_list_reversely_recursively(head-&gt;m_next);\n        &#125;\n        cout &lt;&lt; head-&gt;m_key &lt;&lt; &quot;\\t&quot;;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "Computer-Science",
                "Coding-Interviews"
            ]
        }
    ]
}